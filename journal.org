*Tips*
1. 這這裏是收集知識用的 org
2. 盡他應該維持的特點是:
   1. 便捷, 快速, 自由
   2.
--------------------------
* Chome Inbox
** DONE [[http://askubuntu.com/questions/684169/gtk-message-failed-to-load-module-pantheon-filechooser-module][Gtk-Message: Failed to load module "pantheon-filechooser-module" - Ask Ubuntu]]
   CLOSED: [2017-03-09 Thu 10:57]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-03-09 Thu 10:57]
   :END:
   Captured On: [2017-03-09 Thu 10:57]
   when i start emacs from command line ,appear this warnning, and i found this URL to solve
** DONE [[https://github.com/YiddishKop/org-capture-extension][YiddishKop/org-capture-extension: A Chrome extension facilitating org-capture in emacs]]
   CLOSED: [2017-03-09 Thu 11:00]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-03-09 Thu 11:00]
   :END:
   Captured On: [2017-03-09 Thu 10:59]
   how to add org-capture functionality in ubuntu. by add this to ~/.local/share/application

**  [[http://orgmode.org/worg/org-tutorials/org-protocol-custom-handler.html][Defining custom handlers for use with org-protocol]] :emacs:org-protocol:capture:
   Captured On: [2017-02-14 二 15:02]
**  [[https://github.com/sprig/org-capture-extension][sprig/org-capture-extension: A Chrome extension facilitating org-capture in emacs]] :emacs:org-protocol:capture:

   Captured On: [2017-02-14 二 15:02]
**  [[http://orgmode.org/worg/org-contrib/org-protocol.html][org-protocol.el – Intercept calls from emacsclient to trigger custom actions]] :emacs:org-protocol:capture:

   Captured On: [2017-02-14 二 15:03]
**  [[http://orgmode.org/worg/org-contrib/org-protocol.html#acrobat-reader-setup][org-protocol.el – Intercept calls from emacsclient to trigger custom actions]]  :emacs:org-protocol:capture:
   Captured On: [2017-02-14 二 15:04]
   Captured On: [2017-02-14 二 15:32]
** [[http://lifehacker.com/add-custom-keyboard-shortcuts-to-chrome-extensions-for-1595322121][Add Custom Keyboard Shortcuts to Chrome Extensions for Quick Launching]] :chrome:
   Source: [2017-02-14 二], [[http://lifehacker.com/add-custom-keyboard-shortcuts-to-chrome-extensions-for-1595322121][Add Custom Keyboard Shortcuts to Chrome Extensions for Quick Launching]]
   #+BEGIN_QUOTE
   Chrome: Chrome has all kinds of great keyboard shortcuts to make browsing quick and easy, but they're not really customizable. Digital Inspiration reminds us that you can also set custom keyboard shortcuts for certain extensions.

   Just head to chrome://extensions/ in your browser's address bar to open up the extensions page. Scroll down to the bottom and you'll see a Keyboard Shortcuts option. Click it, and you can set up custom shortcuts for some of you extensions.
   #+END_QUOTE
**  [[http://cn.linux.vbird.org/linux_basic/0310vi.php][鸟哥的 Linux 私房菜 -- vim 程序编辑器]] :vim:
   Captured On: [2017-02-14 二 16:00]
** [[http://heartnheart.github.io/blog/2015/01/15/SogouIME_on_English_Ubuntu_14.04/][在 Emacs 24.3 Ubuntu14.04 英文版中使用搜狗输入法 - org-page]]  :emacs:input-method:
   Source: [2017-02-14 二], [[http://heartnheart.github.io/blog/2015/01/15/SogouIME_on_English_Ubuntu_14.04/][在 Emacs 24.3 Ubuntu14.04 英文版中使用搜狗输入法 - org-page]]
   #+BEGIN_QUOTE
   在 Emacs 24.3 Ubuntu14.04 英文版中使用搜狗输入法

   从命令行启动

   LC_CTYPE='zh_CN.UTF-8' emacs
   从 Dash（搜索框）启动

   重命名默认启动的 emacs24-x
   sudo mv /usr/bin/emac24-x /usr/bin/emacs24-x_original
   创建新的名为 emacs24-x 的脚本
   echo "LC_CTYPE='zh_CN.UTF-8' emacs24-x_original" | sudo tee /usr/bin/emacs24-x
   sudo chmod a+x /usr/bin/emacs24-x
   #+END_QUOTE
** In macro    , expression as the variable will be the last  to expand and compute.
   In function , expression as the variable will be the first to expand and comupte.

   Source: [2017-02-15 三],

   In macro    , expression as the variable will be the last  to expand and compute.

   In function , expression everything away and staras the variable will be the first to expand and comupte.

   #+BEGIN_QUOTE

   #+END_QUOTE
** 完美解决 emacs 输入法无效问题
   Source: [2017-02-15 三], [[http://stackoverflow.com/questions/2901541/which-coding-system-should-i-use-in-emacs][character encoding - Which coding system should I use in Emacs? - Stack Overflow]]
   #+BEGIN_QUOTE
   Here's a pretty comprehensive group of magic invocations to make Emacs use UTF-8 everywhere by default:

   (setq utf-translate-cjk-mode nil) ; disable CJK coding/encoding (Chinese/Japanese/Korean characters)
   (set-language-environment 'utf-8)
   (set-keyboard-coding-system 'utf-8-mac) ; For old Carbon emacs on OS X only
   (setq locale-coding-system 'utf-8)
   (set-default-coding-systems 'utf-8)
   (set-terminal-coding-system 'utf-8)
   (unless (eq system-type 'windows-nt)
   (set-selection-coding-system 'utf-8))
   (prefer-coding-system 'utf-8)
   #+END_QUOTE
** [[http://xmodulo.com/how-to-configure-http-proxy-exceptions.html][How to configure http proxy exceptions on Linux - Xmodulo]]
   Source: [2017-02-16 四], [[http://xmodulo.com/how-to-configure-http-proxy-exceptions.html][How to configure http proxy exceptions on Linux - Xmodulo]]
   #+BEGIN_QUOTE
   How to configure http proxy exceptions on Linux
   Last updated on December 4, 2012 Authored by Dan Nanni  1 Comment
   When you are behind HTTP proxy, you need to configure proxy settings for your applications in one way or another. Typically you define http_proxy environment variable pointing to your proxy, so that all HTTP requests go through the proxy. But what if you want to bypass HTTP proxy for specific destination web servers? That's when you need to configure HTTP proxy exceptions.

   On Linux, you can define HTTP proxy exceptions via "no_proxy" environment variable. In "no_proxy" variable, you specify a list of domain names or IP addresses for which HTTP proxy should not be used. Along with domain names or IP addresses, you can also specify port number if necessary.

   If you would like to define HTTP proxy exceptions system wide, do the following.

   On Ubuntu, Debian or Mint:

   $ sudo vi /etc/environment
   http_proxy="http://proxy.com:8000"
   no_proxy="127.0.0.1, localhost, *.cnn.com, 192.168.1.10, domain.com:8080"
   On CentOS, Fedora or RHEL:

   $ sudo vi /etc/profile.d/proxy.sh
   export http_proxy="http://proxy.com:8000"
   export no_proxy="127.0.0.1, localhost, *.cnn.com, 192.168.1.10, domain.com:8080"
   The above example means that if you are reaching local host (e.g., 127.0.0.1, localhost), *.cnn.com, domain.com:8080, or a host with IP address 192.168.1.10, you will not use HTTP proxy. For all other destinations, you will use the designated HTTP proxy (proxy.com:8000).
   #+END_QUOTE
** [[http://www.powerxing.com/linux-environment-variable/][设置 Linux 环境变量的方法和区别_Ubuntu_给力星]]
   Source: [2017-02-16 四], [[http://www.powerxing.com/linux-environment-variable/][设置 Linux 环境变量的方法和区别_Ubuntu_给力星]]
   #+BEGIN_QUOTE
   设置 Linux 环境变量的方法和区别_Ubuntu
   2014-10-15 (updated: 2016-01-18) 25927 7
   设置 Linux 环境变量可以通过 export 实现，也可以通过修改几个文件来实现，有必要弄清楚这两种方法以及这几个文件的区别。


   通过文件设置 Linux 环境变量
   首先是设置全局环境变量，对所有用户都会生效：

   etc/profile: 此文件为系统的每个用户设置环境信息。当用户登录时，该文件被执行一次，并从 /etc/profile.d 目录的配置文件中搜集 shell 的设置。一般用于设置所有用户使用的全局变量。
   /etc/bashrc: 当 bash shell 被打开时，该文件被读取。也就是说，每次新打开一个终端 shell，该文件就会被读取。
   接着是与上述两个文件对应，但只对单个用户生效：

   ~/.bash_profile 或 ~/.profile: 只对单个用户生效，当用户登录时该文件仅执行一次。用户可使用该文件添加自己使用的 shell 变量信息。另外在不同的 LINUX 操作系统下，这个文件可能是不同的，可能是 ~/.bash_profile， ~/.bash_login 或 ~/.profile 其中的一种或几种，如果存在几种的话，那么执行的顺序便是：~/.bash_profile、 ~/.bash_login、 ~/.profile。比如 Ubuntu 系统一般是 ~/.profile 文件。
   ~/.bashrc: 只对单个用户生效，当登录以及每次打开新的 shell 时，该文件被读取。
   此外，修改 /etc/environment 这个文件也能实现环境变量的设置。/etc/environment 设置的也是全局变量，从文件本身的作用上来说， /etc/environment 设置的是整个系统的环境，而/etc/profile 是设置所有用户的环境。有几点需注意：

   系统先读取 etc/profile 再读取 /etc/environment（还是反过来？）
   /etc/environment 中不能包含命令，即直接通过 VAR="..." 的方式设置，不使用 export。
   使用 source /etc/environment 可以使变量设置在当前窗口立即生效，需注销/重启之后，才能对每个新终端窗口都生效。
   修改 Linux 环境变量实例
   以 Ubuntu 为例，修改 ~/.profile 文件：

   vim ~/.profile
   Shell 命令
   如果该文件存在，则在文件的最后看到如下代码，PATH 变量的值使用冒号(:)隔开的：

   # set PATH so it includes user's private bin if it exists
   if [ -d "$HOME/bin" ] ; then
   PATH="$HOME/bin:$PATH"
   fi
   Shell
   在最后加上代码 PATH="$PATH:/usr/local/hadoop/bin"，注意等号(=)两边不要有空格，即：

   # set PATH so it includes user's private bin if it exists
   if [ -d "$HOME/bin" ] ; then
   PATH="$HOME/bin:$PATH"
   fi
   PATH="$PATH:/usr/local/hadoop/bin"
   Shell
   因为这个文件是在用户登陆是才读取一次的，所以需要重启才会生效（修改 /etc/profile、/etc/environment 也是如此）。但可以使用命令 source ./.profile 使其立即生效。通过 echo $PATH 可以看到修改后的变量值：

   source ./.profile
   echo $PATH
   Shell 命令
   通过 Shell 命令 export 修改 Linux 环境变量
   另一种修改 Linux 环境变量的方式就是通过 Shell 命令 export，注意变量名不要有美元号 $，赋值语句中才需要有：

   export PATH=$PATH:/usr/local/hadoop/bin
   Shell 命令
   export 方式只对当前终端 Shell 有效
   使用 export 设置的变量，只对当前终端 Shell 有效，也就是说如果新打开一个终端，那这个 export 设置的变量在新终端中使无法读取到的。适合设置一些临时变量。

   根据变量所需，选择设置方式，例如 JAVA_HOME 这类变量，就适合将其设为为全局变量，可在 /etc/environment 中设置。



   文章很给力？微信扫一扫给作者打赏 2 元 :)
   ~感谢赞助者~

   http://www.powerxing.com/linux-environment-variable/
   笔记 Linux, Linux 操作, Ubuntu
   #+END_QUOTE
   []
** TODO [[http://vim.wikia.com/wiki/Search_and_replace][Search and replace | Vim Tips Wiki | Fandom powered by Wikia]]    :vim:
   Source: [2017-02-20 一], [[http://vim.wikia.com/wiki/Search_and_replace][Search and replace | Vim Tips Wiki | Fandom powered by Wikia]]
   #+BEGIN_QUOTE
   :s/foo/bar/g    Change each 'foo' to 'bar' in the current line.
   :%s/foo/bar/g   Change each 'foo' to 'bar' in all the lines.
   :5,12s/foo/bar/g    Change each 'foo' to 'bar' for all lines from line 5 to line 12 (inclusive).
   :'a,'bs/foo/bar/g   Change each 'foo' to 'bar' for all lines from mark a to mark b inclusive (see Note below).
   :'<,'>s/foo/bar/g   When compiled with +visual, change each 'foo' to 'bar' for all lines within a visual selection. Vim automatically appends the visual selection range ('<,'>) for any ex command when you select an area and enter :. Also, see Note below.
   :.,$s/foo/bar/g Change each 'foo' to 'bar' for all lines from the current line (.) to the last line ($) inclusive.
   :.,+2s/foo/bar/g    Change each 'foo' to 'bar' for the current line (.) and the two next lines (+2).
   :g/^baz/s/foo/bar/g Change each 'foo' to 'bar' in each line starting with 'baz'.
   Note: As of Vim 7.3, substitutions applied to a range defined by marks or a visual selection (which uses a special type of marks '< and '>) are not bounded by the column position of the marks by default. Instead, Vim applies the substitution to the entire line on which each mark appears unless the \%V atom is used in the pattern like: :'<,'>s/\%Vfoo/bar/g.
   #+END_QUOTE
** TODO   [[file://home/yiddi/Dropbox/evil.pdf][]]
   Captured On: [2017-02-20 一 21:53]
** TODO [[http://www.ctex.org/TeX][TeX 简介:CTEX]]
   Source: [2017-03-01 三], [[http://www.ctex.org/TeX][TeX 简介:CTEX]]
   #+BEGIN_QUOTE

　　TeX 提供了一套功能强大并且十分灵活的排版语言，它多达 900 多条指令，并且 TeX 有宏功能，用户可以不断地定义自己适用的新命令来扩展 TeX 系统的功能。许多人利用 TeX 提供的宏定义功能对 TeX 进行了二次开发，其中比较著名的有美国数学学会推荐的非常适合于数学家使用的 AMSTeX AMS-TeX 以及适合于一般文章、报告、书籍的 LaTeX 系统。

   #+END_QUOTE


   TeX 的另一个重要的特征就是它的输出是与设备无关的。TeX 的输出文件称为 DVI 文件，即是“Device Independent”。一旦 TeX 处理了你的文件，你所得到的 DVI 文件就可以被送到任何输出设备如打印机，屏幕等并且总会得到相同的结果，而这与这些输出设备的限制没有任何关系。这说明 DVI 文件中所有的元素，从页面设置到文本中字符的位置都被固定，不能更改。
** TODO   [[http://aty.sdsu.edu/bibliog/latex/LaTeXtoPDF.html][LaTeX to PDF]]
   Captured On: [2017-03-01 三 10:29]
** TODO   [[http://zchrissirhcz.github.io/blog/latex-in-linux/][在 Linux 下使用 Latex | zchrissirhcz.github.io]]
   Captured On: [2017-03-01 三 10:36]
** TODO   [[http://www.mikewootc.com/wiki/tool/doc_process/latex_chinese_ubuntu_setup.html][LaTex Ubuntu 中文环境安装与使用]]
   Captured On: [2017-03-01 三 10:37]
** TODO   [[http://www.jianshu.com/p/08c657bd34f1][Python--Virtualenv 简明教程 - 简书]]
   Captured On: [2017-03-01 三 13:31]
** TODO   [[https://virtualenv.pypa.io/en/stable/installation/][Installation — virtualenv 15.1.0 documentation]]
   Captured On: [2017-03-01 三 13:36]
** TODO   [[http://www.jianshu.com/p/08c657bd34f1][Python--Virtualenv 简明教程 - 简书]]
   Captured On: [2017-03-01 三 13:56]
** TODO [[https://github.com/proofit404/anaconda-mode/issues/164][Anaconda mode opening new windows with errors · Issue #164 · proofit404/anaconda-mode]]
   Source: [2017-03-01 三], [[https://github.com/proofit404/anaconda-mode/issues/164][Anaconda mode opening new windows with errors · Issue #164 · proofit404/anaconda-mode]]
   #+BEGIN_QUOTE
   I need the value of python-shell-interpreter and python-shell-virtualenv-path variables. Does minibuffer contain some error messages? What is the content of *anaconda-mode* buffer?
   #+END_QUOTE
** TODO [[https://my.oschina.net/u/89296/blog/42393][Python 和 egg 文件 - 甄码农]]
   Source: [2017-03-01 三], [[https://my.oschina.net/u/89296/blog/42393][Python 和 egg 文件 - 甄码农]]
   #+BEGIN_QUOTE
   4. 相关知识：egg 包和 setup tools

   python 的 egg 文件有点像 java 中的 jar 文件，是一个工程打包文件，便于安装部署，仅此一点，给多少 pythoner 带来了多少激动。而 setup tools 就是一个提供包管理的工具或者说是软件。

   egg 是一个包含所有包数据的文件包。在理想情况中，egg 是一个使用 zip 压缩的文件，其中包括了所有需要的包文件。但是在某些情况下，setuptools 会决定（或被开关告知）包不应该是 zip 压缩的。在这些情况下，egg 只是一个简单的未曾压缩的子目录，但是里面的内容是相同的。使用单一的版本可以方便地进行转换，并可以节省一点磁盘空间，但是 egg 目录从功能和组织结构上来说都是相同的。

   安装 package 是经常碰到事情, 而且安装也比较繁琐，最头疼就是包依赖的问题，有时候一个上午可能就为了安装一个包，就像我今天这样的。在 Java 里面有这样的包管理软件，那就是 Maven 了， 他会帮助你找到所依赖的包. 据说其他语言,比如, php, ruby, perl 等 也有类似的工具软件.
   #+END_QUOTE
** TODO   [[https://my.oschina.net/u/89296/blog/42393][Python 和 egg 文件 - 甄码农]]
   Captured On: [2017-03-01 三 20:45]
** TODO [[http://www.cnblogs.com/Tommy-Yu/p/4991853.html][python egg 文件解压 - tommy.yu - 博客园]]
   Source: [2017-03-01 三], [[http://www.cnblogs.com/Tommy-Yu/p/4991853.html][python egg 文件解压 - tommy.yu - 博客园]]
   #+BEGIN_QUOTE
   python egg 文件解压

   unzip 就可以了。

    

   由于项目需要将某些版本的库打包，然后 sys.path.insert 方式引用（避免升级包导致某些旧的系统崩掉）。

   在将 egg 文件打包时，发现不可用。但相关模块的__path__属性显示， 这些内容在 egg 里面，于是想到可能这只是个压缩包。

   谷歌了一番，找到了解压的方法：https://mail.python.org/pipermail/chicago/2007-July/002301.html

   即用 unzip 指令就可一了。

    

    

   ======后记===========

   python 的 egg 文件有点像 java 中的 jar 文件，是一个工程打包文件，便于安装部署，仅此一点，给多少 pythoner 带来了多少激动。而 setup tools 就是一个提供包管理的工具或者说是软件。

   egg 是一个包含所有包数据的文件包。在理想情况中，egg 是一个使用 zip 压缩的文件，其中包括了所有需要的包文件。但是在某些情况下，setuptools 会决定（或被开关告知）包不应该是 zip 压缩的。在这些情况下，egg 只是一个简单的未曾压缩的子目录，但是里面的内容是相同的。使用单一的版本可以方便地进行转换，并可以节省一点磁盘空间，但是 egg 目录从功能和组织结构上来说都是相同的。
   #+END_QUOTE
** TODO [[http://www.ibm.com/developerworks/cn/linux/l-cppeak3.html][可爱的 Python: 使用 setuptools 孵化 Python egg]]
   Source: [2017-03-01 三], [[http://www.ibm.com/developerworks/cn/linux/l-cppeak3.html][可爱的 Python: 使用 setuptools 孵化 Python egg]]
   #+BEGIN_QUOTE
   可爱的 Python: 使用 setuptools 孵化 Python egg
   改进安装和包管理后的 PEAK
   David 在本文中将带领我们了解一下 setuptools 框架，它是 Python Enterprise Application Kit（PEAK）的一个副项目。setuptools 替换了标准的 distutils 库，并为 Python 添加了版本化的包和依赖性管理。Perl 用户比较熟悉 CPAN，而 Ruby 用户则比较熟悉 Gems；引导 setuptools 的 ez_setup 工具和随之而生的扩展后的 easy_install 与 “Cheeseshop”（Python Package Index，也称为 “PyPI”）一起工作来实现相同的功能。另外，setuptools 还让我们可以将自己的库包装成一个称为 “egg” 的包，它与 Java™ 的 JAR 文件类似，不过是用于 Python 的。
   查看本系列更多内容 | 1 评论
   David Mertz (mertz@gnosis.cx), 开发人员, Gnosis Software, Inc.
   2006 年 11 月 30 日

   内容

   在 IBM Bluemix 云平台上开发并部署您的下一个应用。
   开始您的试用
   Python Enterprise Application Kit（PEAK）的基础知识在本专栏的前两部分中已经进行了介绍：“可爱的 Python: Python Enterprise Application Kit” 和 “深入 PEAK 的新特性”。简而言之，PEAK 是用来在 Python 中进行快速组件开发和代码重用的强大框架。
   本文介绍了 setuptools 框架的内容，它是 PEAK 的一个副项目，它提供了比 distutils 更加简单的包管理和发行功能。
   开始
   setuptools 模块很会 “规避”。例如，如果我们下载一个使用 setuptools 而不是使用 distutils 构建的包，那么安装就应该可以像我们期望的一样工作：通常使用 python setup.py install 就可以。为了实现这种功能，使用 setuptools 绑定在一起的包就会在归档文件中包含一个很小的引导模块 ez_setup.py。此处惟一需要注意的是 ez_setup.py 试图在后台下载并安装所需要的 setuptools —— 当然，这需要有一个连接网络的机器。如果 setuptools 早已在本地机器上安装了，那么这个后台步骤就不再需要执行；但是如果它需要手工进行安装，那么很多透明性就都丢失了。不过，大部分系统现在都有一个 Internet 连接了；为没有连接网络的机器多执行几个特殊步骤也并非特别麻烦。
   setuptools 的真正优点并不在于实现 distutils 所能实现的功能 —— 尽管它 的确 增强了 distutils 的功能并简化了 setup.py 脚本中的内容。setuptools 最大的优势是它在包管理能力方面的增强。它可以使用一种更加透明的方法来查找、下载并安装依赖包；并可以在一个包的多个版本中自由进行切换，这些版本都安装在同一个系统上；也可以声明对某个包的特定版本的需求；还可以只使用一个简单的命令就能更新到某个包的最新版本。给人印象最为深刻的是，即使有些包的开发人员可能还从未考虑过任何 setuptools 兼容性问题，我们依然可以使用这些包。
   下面让我们详细探讨一下。
   回页首
   引导
   工具 ez_setup.py 是一个简单的脚本，它可以引导 setuptools 中其余部分。有点让人困惑的是，完整 setuptools 包中所提供的 easy_install 脚本与 ez_setup.py 所实现的功能是相同的。不过前者假设 setuptools 早已安装了，因此它会跳过幕后的安装过程。这两个版本都可以接受相同的参数和开关。
   这个过程中的第一个步骤是下载一个小脚本 ez_setup.py：
   清单 1. 下载引导脚本
   % wget -q http://peak.telecommunity.com/dist/ez_setup.py
   然后，就可以不带任何参数运行脚本来安装 setuptools 中其余部分了（如果不作为一个单独的步骤来执行这个步骤，在首次安装其他包时，它还是会被完成）。会看到类似于下面的内容（当然，这要取决于所使用的版本）：
   清单 2. 引导 setuptools
   % python ez_setup.py
   Downloading http://cheeseshop.python.org/packages/2.4/s/
   setuptools/setuptools-0.6b1-py2.4.egg#md5=b79a8a403e4502fbb85ee3f1941735cb
   Processing setuptools-0.6b1-py2.4.egg
   creating /sw/lib/python2.4/site-packages/setuptools-0.6b1-py2.4.egg
   Extracting setuptools-0.6b1-py2.4.egg to /sw/lib/python2.4/site-packages
   Removing setuptools 0.6a11 from easy-install.pth file
   Adding setuptools 0.6b1 to easy-install.pth file
   Installing easy_install script to /sw/bin
   Installing easy_install-2.4 script to /sw/bin

   Installed /sw/lib/python2.4/site-packages/setuptools-0.6b1-py2.4.egg
   Processing dependencies for setuptools
   完毕。这就是我们需要确保在系统上安装 setuptools 而需要做的工作。
   回页首
   安装包
   对于很多 Python 包来说，要安装这些包，需要做的就是将这些包的名字作为一个参数传递给 ez_setup.py 或 easy_install。既然目前已经使用引导脚本加载了 setuptools，那就可以使用内部更加简化的 easy_install（实际上它与我们选择的版本的区别很小）了。
   例如，假设希望安装 SQLObject 包。过程非常简单，如清单 3 所示。注意消息中说 SQLObject 依赖于一个名为 FormEncode 的包；所幸的是，这会被很好地解决：
   清单 3. 安装一个典型的包
   % easy_install SQLObject
   Searching for SQLObject
   Reading http://www.python.org/pypi/SQLObject/
   Reading http://sqlobject.org
   Best match: SQLObject 0.7.0
   Downloading http://cheeseshop.python.org/packages/2.4/S/
   SQLObject/SQLObject-0.7.0-py2.4.egg#md5=71830b26083afc6ea7c53b99478e1b6a
   Processing SQLObject-0.7.0-py2.4.egg
   creating /sw/lib/python2.4/site-packages/SQLObject-0.7.0-py2.4.egg
   Extracting SQLObject-0.7.0-py2.4.egg to /sw/lib/python2.4/site-packages
   Adding SQLObject 0.7.0 to easy-install.pth file
   Installing sqlobject-admin script to /sw/bin

   Installed /sw/lib/python2.4/site-packages/SQLObject-0.7.0-py2.4.egg
   Processing dependencies for SQLObject
   Searching for FormEncode>=0.2.2
   Reading http://www.python.org/pypi/FormEncode/
   Reading http://formencode.org
   Best match: FormEncode 0.5.1
   Downloading http://cheeseshop.python.org/packages/2.4/F/
   FormEncode/FormEncode-0.5.1-py2.4.egg#md5=f8a19cbe95d0ed1b9d1759b033b7760d
   Processing FormEncode-0.5.1-py2.4.egg
   creating /sw/lib/python2.4/site-packages/FormEncode-0.5.1-py2.4.egg
   Extracting FormEncode-0.5.1-py2.4.egg to /sw/lib/python2.4/site-packages
   Adding FormEncode 0.5.1 to easy-install.pth file

   Installed /sw/lib/python2.4/site-packages/FormEncode-0.5.1-py2.4.egg
   正如可以从这些消息中看到的一样，easy_install 要在 www.python.org/pypi/ 上查找有关这个包的信息，然后查找真正可以下载它的地方（此处 egg 包就在 cheeseshop.python.org 上；后面将介绍有关 egg 的更多内容）。
   现在不仅仅可以安装某个包的最新版本（这是默认操作）。如果愿意，还可以为 easy_install 提供一个特定的版本需求。现在让我们尝试安装 SQLObject 的一个 post-beta 版本。
   清单 4. 安装某个包的最小版本
   % easy_install 'SQLObject>=1.0'
   Searching for SQLObject>=1.0
   Reading http://www.python.org/pypi/SQLObject/
   Reading http://sqlobject.org
   No local packages or download links found for SQLObject>=1.0
   error: Could not find suitable distribution for
   Requirement.parse('SQLObject>=1.0')
   如果（在本文编写时情况就是如此）SQLObject 的最新版本小于 1.0，那么这会什么也不安装。
   回页首
   安装 “naive” 包
   SQLObject 是可以识别 setuptools 的；但是如果要安装一个尚未兼容 setuptools 的包又该如何呢？例如，在本文之前，我从没有对自己的 “Gnosis Utilities” 使用过 setuptools。不过，现在让我们来尝试安装一下这个包，已知的只有它所在的 HTTP（或 FTP、SVN、CVS）位置（setuptools 可以理解所有这些协议）。我的下载 Web 站点上有各个 Gnosis Utilities 的版本，它们的命名采用了常见的版本风格：
   清单 5. 安装不识别 setuptools 的包
   % easy_install -f http://gnosis.cx/download/Gnosis_Utils.More/ Gnosis_Utils
   Searching for Gnosis-Utils
   Reading http://gnosis.cx/download/Gnosis_Utils.More/
   Best match: Gnosis-Utils 1.2.1
   Downloading http://gnosis.cx/download/Gnosis_Utils.More/
   Gnosis_Utils-1.2.1.zip
   Processing Gnosis_Utils-1.2.1.zip
   Running Gnosis_Utils-1.2.1/setup.py -q bdist_egg --dist-dir
   /tmp/easy_install-CCrXEs/Gnosis_Utils-1.2.1/egg-dist-tmp-Sh4DW1
   zip_safe flag not set; analyzing archive contents...
   gnosis.__init__: module references __file__
   gnosis.magic.__init__: module references __file__
   gnosis.xml.objectify.doc.__init__: module references __file__
   gnosis.xml.pickle.doc.__init__: module references __file__
   gnosis.xml.pickle.test.test_zdump: module references __file__
   Adding Gnosis-Utils 1.2.1 to easy-install.pth file

   Installed /sw/lib/python2.4/site-packages/Gnosis_Utils-1.2.1-py2.4.egg
   Processing dependencies for Gnosis-Utils
   所幸的是 easy_install 可以把这一切都完成得很好。它会查看给定的下载目录，识别出可用的最高版本，展开这个包，然后将其重新打包为 “egg” 格式，后者就可以用来进行安装了。导入 gnosis 现在可以在一个脚本中运行。但是假设现在需要对 Gnosis Utilities 之前的某个特定版本来测试一个脚本又该怎么做呢？这也非常简单：
   清单 6. 安装一个 “naive” 包的特定版本
   % easy_install -f http://gnosis.cx/download/Gnosis_Utils.More/
   "Gnosis_Utils==1.2.0"
   Searching for Gnosis-Utils==1.2.0
   Reading http://gnosis.cx/download/Gnosis_Utils.More/
   Best match: Gnosis-Utils 1.2.0
   Downloading http://gnosis.cx/download/Gnosis_Utils.More/
   Gnosis_Utils-1.2.0.zip
   [...]
   Removing Gnosis-Utils 1.2.1 from easy-install.pth file
   Adding Gnosis-Utils 1.2.0 to easy-install.pth file

   Installed /sw/lib/python2.4/site-packages/Gnosis_Utils-1.2.0-py2.4.egg
   Processing dependencies for Gnosis-Utils==1.2.0
   现在通常已经安装了两个版本的 Gnosis Utilities，当前活动版本是 1.2.0。将活动版本切换回 1.2.1 也非常简单：
   清单 7. 在系统范围修改 “活动” 版本
   % easy_install "Gnosis_Utils==1.2.1"
   Searching for Gnosis-Utils==1.2.1
   Best match: Gnosis-Utils 1.2.1
   Processing Gnosis_Utils-1.2.1-py2.4.egg
   Removing Gnosis-Utils 1.2.0 from easy-install.pth file
   Adding Gnosis-Utils 1.2.1 to easy-install.pth file

   Using /sw/lib/python2.4/site-packages/Gnosis_Utils-1.2.1-py2.4.egg
   Processing dependencies for Gnosis-Utils==1.2.1
   当然，这一次只能使一个版本是活动的。不过通过在各个脚本上面放上这样两行类似内容，就可以让脚本选择自己希望使用的版本：
   清单 8. 在脚本中使用某个版本的包
   from pkg_resources import require
   require("Gnosis_Utils==1.2.0")
   通过使用上述要求，setuptools 就可以在运行 import 语句时添加一个特定的版本（如果指定了大于比较，就是最新的可用版本）。
   回页首
   让包可以识别 setuptools
   我会更希望让用户不需要知道 Gnosis Utilities 的下载目录就可以安装它。这 通常都可以 工作，因为 Gnosis Utilities 在 Python Cheeseshop 上有一个信息清单。不幸的是，因为没有考虑 setuptools，所以我在 python.org 上为我的 Gnosis Utilities 建立了一个 “不匹配” 的入口 http://www.python.org/pypi/Gnosis%20Utilities/1.2.1。具体地说，这个归档文件是根据类似于 Gnosis_Utils-N.N.N.tar.gz 的模式进行命名的（这些工具也打包成了 .zip 和 .tar.bz2 文件，最新的几个版本还打包成了 win32.exe 的安装程序，所有这些文件 setuptools 都可以很好地处理）。不过 Cheeseshop 上的项目名的拼写与 “Gnosis Utilities” 稍微有点不同。实际上，在 Cheeseshop 的一个很小的管理版本的更改就会将 http://www.python.org/pypi/Gnosis_Utils/1.2.1-a 创建为一个发布后版本。发行版归档文件本身并没有什么变化，不过是在 Cheeseshop 里增加了一点元数据。只需要少量努力，就可以使用更加简单的安装程序（注意，出于测试目的，我运行了一个 easy_install -m 来删除所安装的包）。
   清单 9. 简单增加对 setuptools 的识别
   % easy_install Gnosis_Utils
   Searching for Gnosis-Utils
   Reading http://www.python.org/pypi/Gnosis_Utils/
   Reading http://www.gnosis.cx/download/Gnosis_Utils.ANNOUNCE
   Reading http://gnosis.cx/download/Gnosis_Utils.More/
   Best match: Gnosis-Utils 1.2.1
   Downloading [...]
   我把这个过程剩余的部分忽略掉了，因为这与您前面看到的内容没什么两样。惟一的区别在于 easy_install 要在 Cheeseshop（换言之 www.python.org/pypi/）上寻找可以匹配指定名字的元数据，并使用这些信息来查找真正的下载位置。在这种情况中，所列出的 .ANNOUNCE 文件没有包含任何有帮助的内容，不过 easy_install 还会继续查看另一个所列的 URL，这会证明它是一个下载目录。
   回页首
   关于 egg
   egg 是一个包含所有包数据的文件包。在理想情况中，egg 是一个使用 zip 压缩的文件，其中包括了所有需要的包文件。但是在某些情况下，setuptools 会决定（或被开关告知）包不应该是 zip 压缩的。在这些情况下，egg 只是一个简单的未曾压缩的子目录，但是里面的内容是相同的。使用单一的版本可以方便地进行转换，并可以节省一点磁盘空间，但是 egg 目录从功能和组织结构上来说都是相同的。一直使用 JAR 文件的 Java™ 技术的用户会发现 egg 非常熟悉。
   由于最新的 Python 版本中（需要 2.3.5+ 或 2.4）导入挂钩的更改，可以简单地通过设置 PYTHONPATH 或 sys.path 并像往常一样导入相应的包来使用 egg。如果希望采用这种方法，就不需要使用 setuptools 或 ez_setup.py 了。例如，在本文使用的工作目录中，我就为 PyYAML 包放入了一个 egg。现在我就可以使用这个包了，方法如下：
   清单 10. PYTHONPATH 上的 egg
   % export PYTHONPATH=~/work/dW/PyYAML-3.01-py2.4.egg
   % python -c 'import yaml; print yaml.dump({"foo":"bar",1:[2,3]})'
   1: [2, 3]
   foo: bar
   不过，PYTHONPATH 的（或者脚本或 Python shell 会话内的 sys.path 的）这种操作有些脆弱。egg 的发现最好是在新一点的 .pth 文件中进行。在 site-packages/ 或 PYTHONPATH 中的任何 .pth 文件都会进行解析来执行其他导入操作，其方法类似于检查可能包含包的那些目录位置一样。如果使用 setuptools 来处理包的管理功能，那么在安装、更新、删除包时，就需要修改一个名为 easy-install.pth 的文件。而且可以按照自己喜欢的方式对这个 .pth 进行命名（只要其扩展名是 .pth 即可）。例如，下面是我的 easy-install.pth 文件的内容：
   清单 11. 用作 egg 位置配置的 .pth 文件
   % cat /sw/lib/python2.4/site-packages/easy-install.pth
   import sys; sys.__plen = len(sys.path)
   setuptools-0.6b1-py2.4.egg
   SQLObject-0.7.0-py2.4.egg
   FormEncode-0.5.1-py2.4.egg
   Gnosis_Utils-1.2.1-py2.4.egg
   import sys; new=sys.path[sys.__plen:]; del sys.path[sys.__plen:];
   p=getattr(sys,'__egginsert',0); sys.path[p:p]=new;
   sys.__egginsert = p+len(new)
   这种格式有点特殊：它近似于一个 Python 脚本，但却不完全是。需要说明的是，可以在那里添加额外列出的 egg；更好的情况是，easy_install 会在运行时实现这种功能。也可以在 site-packages/ 下创建任意多个 .pth 文件；每个都可以列出有哪些 egg 是可用的。
   回页首
   增强安装脚本
   上面所述的这种安装 setuptools naive 包的能力（请参阅 清单 6）只部分有效。也就是说，包 Gnosis_Utils 的确安装上了，但是并不完整。所有常见的功能都可以工作，但是在自动生成 egg 时却忽略了很多支持文件 —— 大部分是扩展名为 .txt 的文档和扩展名为 .xml 的测试文件（还有一些其他的 README、.rnc、.rng、.xsl 和围绕子包的文件）。在安装时，所有这些支持文件都 “最好要有”，而没有严格要求一定要有。不过，我们仍然希望能够包含所有的支持文件。
   Gnosis_Utils 使用的 setup.py 脚本实际上非常复杂。除了列出基本的元数据之外，在第 467 行代码中，它还对 Python 版本的功能和 bug 进行完整测试；解决旧版本的 distutils 中的一些故障；回溯跳过对不支持部分的安装（例如，如果 pyexpat 在 Python 发行版中并没有包括）；处理 OS 行结束符的转换；创建多个归档/安装程序类型；根据测试结果重新构建 MANIFEST 文件。能够实现处理这些工作的能力要感谢此包的另外一个维护人员 Frank McIngvale；这些能力可以让 Gnosis_Utils 能成功安装回 Python 1.5.1 的版本，当然前提是需要这么做（早期版本中的功能没有这么丰富）。不过此处我要向大家展示的脚本并没有像 distutils 脚本一样做这么复杂的事情：它只是简单地假设系统中已经安装了一个 “普通的” 最新版本的 Python。即使这么讲，setuptools 能让安装脚本变得如此简单还是非常吸引人。
   在第一次尝试时，让我们来创建一个 setup.py 脚本，它是从 setuptools 手册中借用的，并试图使用它来创建一个 egg：
   清单 12. setuptools setup.py 脚本
   % cat setup.py
   from setuptools import setup, find_packages
   setup(
   name = "Gnosis_Utils",
   version = "1.2.2",
   packages = find_packages(),
   )
   % python setup.py -q bdist_egg
   zip_safe flag not set; analyzing archive contents...
   gnosis.__init__: module references __file__
   gnosis.doc.__init__: module references __file__
   gnosis.magic.__init__: module references __file__
   gnosis.xml.objectify.doc.__init__: module references __file__
   gnosis.xml.pickle.doc.__init__: module references __file__
   gnosis.xml.pickle.test.test_zdump: module references __file__
   这点努力就已经可以起作用；至少可以部分地起作用。使用这几行内容的确可以创建一个 egg，不过这个 egg 与使用 easy_install 创建的 egg 有一些相似的缺点：缺乏对不使用 .py 命名的文件的支持。因此让我们再试一次，只是需要稍微再努力一点：
   清单 13. 添加缺少的 package_data
   from setuptools import setup, find_packages
   setup(
   name = "Gnosis_Utils",
   version = "1.2.2",
   package_data = {'':['*.*']},
   packages = find_packages(),
   )
   这就是需要做的所有操作。当然，根据实际情况，通常希望对它进行一些调整。例如，它可能会列出下面的内容：
   清单 14. 打包特定类型文件类型
   package_data = {'doc':['*.txt'], 'xml':['*.xml', 'relax/*.rnc']}
   这段内容翻译一下就是：将 .txt 文件包括在 doc/ 子包中，将 .xml 文件包括在 xml/ 子包中，将所有 .rnc 文件包括在 xml/relax/ 子包中。
   回页首
   结束语
   本文实际上只介绍了用支持 setuptools 的发行版可以执行的定制操作的表层的知识。例如，假设您现在有一个发行版（可以是首选的 egg 格式或另外一种归档类型），您就可以使用一个命令将这个归档文件和元数据上载到 Cheeseshop 上。显然，完整的 setup.py 脚本应该包含旧版本 distutils 脚本中所包含的同样详细的元数据；为了简单起见，本文跳过了这些内容，但是其参数名与 distutils 是兼容的。
   尽管要完全适应 setuptools 所提供的巨大功能需要一些时间，但是实际上它确实可以让维护您自己的包和安装外来包都要比 distutils 更加简单。如果您所关心的内容仅仅是安装包，那么您所需要了解的内容在本文的介绍中已经全部包括了；只是您在描述您自己的包时可能会发现一些复杂性，不过仍然没有使用 distutils 那么复杂。
   #+END_QUOTE
** TODO [[http://www.cnblogs.com/mnzlichunyu/p/5982981.html][{spacemacs}anaconda 自动补全不工作 - 剑客西门吹雪 - 博客园]]
   Source: [2017-03-01 三], [[http://www.cnblogs.com/mnzlichunyu/p/5982981.html][{spacemacs}anaconda 自动补全不工作 - 剑客西门吹雪 - 博客园]]
   #+BEGIN_QUOTE
   [spacemacs]anaconda 自动补全不工作
   spacemacs 打开 python 源文件自动补全不工作，打开 anaconda-mode buffer 看到以下信息：
   1
   2
   3
   4
   5
   6
   7
   8
   9
   10
   11
   12
   Traceback (most recent call last):
     File "/Users/matthew/.emacs.d/.cache/anaconda-mode/0.1.5/service_factory-0.1.4-py2.7.egg/service_factory/providers/basehttp.py", line 40, in do_POST
       status, response = self.server.service(data)
     File "/Users/matthew/.emacs.d/.cache/anaconda-mode/0.1.5/service_factory-0.1.4-py2.7.egg/service_factory/service.py", line 50, in __call__
       result = self.apply(method, args)
     File "/Users/matthew/.emacs.d/.cache/anaconda-mode/0.1.5/service_factory-0.1.4-py2.7.egg/service_factory/service.py", line 105, in apply
       server_error(args['id'], error)
     File "/Users/matthew/.emacs.d/.cache/anaconda-mode/0.1.5/service_factory-0.1.4-py2.7.egg/service_factory/errors.py", line 91, in server_error
    
       raise ServiceException(500, dumps(response))
   ServiceException: (500, '{"jsonrpc": "2.0", "id": 1, "error": {"message": "Server error", "code": -32000, "data": "IOError(20, \'no such file or directory\')"}}')
   　　

   环境：
   OS：windows 7，
   emacs：emacs-w64-25.1
    
   原因：
   推测因为 jedi 以 egg 文件（一个 zip 文件）文件安装导致 IOError。
    
   解决方法：
   进入目录 C:\Users\<your user name>\.emacs.d\.cache\anaconda-mode\0.1.6\，解压 jedi-0.9.0-py2.7.egg 到当前目录
   ，然后把解压出来的文件夹改名为 jedi-0.9.0-py2.7.egg, 删除或者把以前的 egg 文件重命名为 jedi-0.9.0-py2.7.egg.bak。
   python 补全就可以正常工作了。 
    
   #+END_QUOTE
** TODO [[https://emacs-china.org/t/2016mbp-quickhelp/1644/16][新入了 2016mbp，无法安装 quickhelp 了，求解答 - Spacemacs - Emacs China]]
   Source: [2017-03-01 三], [[https://emacs-china.org/t/2016mbp-quickhelp/1644/16][新入了 2016mbp，无法安装 quickhelp 了，求解答 - Spacemacs - Emacs China]]
   #+BEGIN_QUOTE
   在你的配置中, 应该需要这样添加 auto-completion layer 才可以使得 company-quickhelp 生效.

   (auto-completion :variables
   auto-completion-enable-sort-by-usage t
   auto-completion-enable-help-tooltip t
   auto-completion-enable-snippets-in-popup t)

   设定 auto-completion-enable-help-tooltip 为 t 之后 spacemacs 就会为你安装 company-quickhelp 的，不需要再在其它地方添加任何设置。

   对我而言，没有很大的补全需求，macOS 和 Linux 在 emacs-lisp-mode 都可以用我给出的 auto-completion 的配置给出 tool-tip 的。
   #+END_QUOTE
** TODO   [[http://wkhtmltopdf.org/][wkhtmltopdf]]
   Captured On: [2017-03-02 四 14:43]
** TODO [[http://www.ubuntu-tw.org/modules/newbb/viewtopic.php?topic_id=62598][如何知道自己有哪些硬體驅動程式沒有安裝？ {論壇 - 新手村} | Ubuntu 正體中文站]]
   Source: [2017-03-06 一], [[http://www.ubuntu-tw.org/modules/newbb/viewtopic.php?topic_id=62598][如何知道自己有哪些硬體驅動程式沒有安裝？ {論壇 - 新手村} | Ubuntu 正體中文站]]
   #+BEGIN_QUOTE
   一般裝置 分爲 pci 裝置 及 usb 裝置
   1. lspci -cvv # 兩個 v
   可以看出 有沒有 kernel module in use
   如果 有 表示已經 驅動
   如果 看不出來 是什麼裝置
   可以到
   PCI Vendor and Device Lists
   查閱

   2. lsusb -v
   可以看出 有沒有 kernel module in use
   如果 有 表示已經 驅動
   如果 看不出來 是什麼裝置
   可以到
   The USB ID Repository
   查閱
   #+END_QUOTE
** TODO [[https://ubuntuforums.org/showthread.php?t=2011446][{ubuntu} mount point for wifi usb card]]             :ubuntu:error:fix:
   Source: [2017-03-06 一], [[https://ubuntuforums.org/showthread.php?t=2011446][{ubuntu} mount point for wifi usb card]]
   #+BEGIN_QUOTE
   Hi

   Udev should create a device node for it in /dev. Take a look in there.

   You can also see all the connected USB devices using (from the terminal)

   Code:
   *lsusb*
   You can check to see what the kernel did when mounting it by opeing a terminal and typing

   Code:

   *tail -f /var/log/syslog*
   Then plug the device in. As the kernel recognises the devices it will display a number of log messages that can tell you information about the device.

   That should get you started.

   Kind regards

   #+END_QUOTE
** TODO   [[https://my.oschina.net/kursk/blog/7896][ubuntu 下无线网卡解决经历 - yeyelei]]               :ubuntu:error:fix:
   Captured On: [2017-03-06 一 19:10]
** TODO   [[https://lists.gnu.org/archive/html/emacs-orgmode/2016-04/msg00298.html][Re: [O] [BUG] Failure to run sh source block]] :org:babel:
   Captured On: [2017-03-06 一 19:13]
** TODO   [[http://emacs.stackexchange.com/questions/28441/org-mode-9-unable-to-eval-code-blocks][org babel - Org-mode 9: unable to eval code-blocks - Emacs Stack Exchange]] :org:capture:
   Captured On: [2017-03-06 一 19:13]
** TODO [[http://emacs.stackexchange.com/questions/10549/org-mode-how-to-export-underscore-as-underscore-instead-of-highlight-in-html][org-mode: How to export underscore as underscore instead of highlight in HTML? - Emacs Stack Exchange]]
   Source: [2017-03-06 一], [[http://emacs.stackexchange.com/questions/10549/org-mode-how-to-export-underscore-as-underscore-instead-of-highlight-in-html][org-mode: How to export underscore as underscore instead of highlight in HTML? - Emacs Stack Exchange]]
   #+BEGIN_QUOTE
   org-mode exports _ as subscripts and ^ as superscripts

   The default export behavior can be customized using the menus Org -> Customize -> Browse Org Group. To update the default behavior for subscripts & superscripts, choose:

   [-]-\ Group Org Export
   [-]-\ Group Org Export General
   — Option Org Export With Sub Superscripts
   Org Export With Sub Superscripts Examples

   Examples

   *** Interpret them - Default
   Underscore_subscript becomes Underscoresubscript
   Hat^superscript becomes Hatsuperscript
   *** Curly brackets only
   Underscore_WithCurlyBrackets_{subscript} becomes Underscore_WithCurlyBracketssubscript
   Hat^WithCurlyBrackets^{superscript} becomes Hat^WithCurlyBracketssuperscript
   *** Do not interpret them
   Underscore_subscript becomes Underscore_subscript
   Hat^superscript becomes Hat^superscript
   Underscore_WithCurlyBrackets_{subscript} becomes Underscore_WithCurlyBrackets_{subscript}
   Hat^WithCurlyBrackets^{superscript} becomes Hat^WithCurlyBrackets^{superscript}
   #+END_QUOTE
** TODO   [[https://my.oschina.net/kursk/blog/7896][ubuntu 下无线网卡解决经历 - yeyelei]]
   Captured On: [2017-03-07 二 13:56]
   This text gives an introduction to the relationship between:
   hardware/driver/modules/load-modules
** TODO   [[http://www.draisberghof.de/usb_modeswitch/#download][Draisberghof - Software - USB_ModeSwitch]]
   Captured On: [2017-03-07 二 14:11]

   maybe used in later
** DONE [[https://m.baidu.com/from=844b/bd_page_type=1/ssid=0/uid=0/pu=usm%25400%252Csz%2540320_1001%252Cta%2540iphone_2_6.0_3_537/baiduid=FC1029C2B8CDDBB36A1A41EB34A5A170/w=0_10_/t=iphone/l=3/tc?ref=www_iphone&lid=13779130330335403338&order=1&fm=alop&tj=www_normal_1_0_10_title&vit=osres&m=8&srd=1&cltj=cloud_title&asres=1&title=Linuxsecureboot%2528%25E5%25AE%2589%25E5%2585%25A8%25E5%2590%25AF%25E5%258A%25A8%2529%25E6%2597%25B6%25E6%25B7%25BB%25E5%258A%25A0Nvidia%25E6%2598%25BE..._%25E5%258D%259A%25E5%25AE%25A2%25E5%259B%25AD&dict=30&w_qd=IlPT2AEptyoA_yimGUCsCSZsvQnMReGgEBuZLCzRqugrRwYyRVpn98C&sec=19275&di=4423311c9e5d9848&bdenc=1&tch=124.0.300.139.0.0&nsrc=IlPT2AEptyoA_yixCFOxXnANedT62v3IEQGG_ytK1DK6mlrte4viZQRAZiHqMXK4E587umP0sqdFtXLR_7Em9RJCrLIwdzZz&eqid=bf394e07cd73e0001000000258b8e53d&wd=&clk_info=%257B%2522srcid%2522%253A%25221599%2522%252C%2522tplname%2522%253A%2522www_normal%2522%252C%2522t%2522%253A1488512324271%252C%2522xpath%2522%253A%2522div-a-h3-em3%2522%257D][Linux secure boot(安全启动)时添加 Nvidia 显卡驱动 - 诸葛孔明没灯 - 博客园]] :ubuntu:nvidia:
   CLOSED: [2017-03-07 二 17:28]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-03-07 二 17:28]
   :END:
   Source: [2017-03-07 二], [[https://m.baidu.com/from=844b/bd_page_type=1/ssid=0/uid=0/pu=usm%25400%252Csz%2540320_1001%252Cta%2540iphone_2_6.0_3_537/baiduid=FC1029C2B8CDDBB36A1A41EB34A5A170/w=0_10_/t=iphone/l=3/tc?ref=www_iphone&lid=13779130330335403338&order=1&fm=alop&tj=www_normal_1_0_10_title&vit=osres&m=8&srd=1&cltj=cloud_title&asres=1&title=Linuxsecureboot%2528%25E5%25AE%2589%25E5%2585%25A8%25E5%2590%25AF%25E5%258A%25A8%2529%25E6%2597%25B6%25E6%25B7%25BB%25E5%258A%25A0Nvidia%25E6%2598%25BE..._%25E5%258D%259A%25E5%25AE%25A2%25E5%259B%25AD&dict=30&w_qd=IlPT2AEptyoA_yimGUCsCSZsvQnMReGgEBuZLCzRqugrRwYyRVpn98C&sec=19275&di=4423311c9e5d9848&bdenc=1&tch=124.0.300.139.0.0&nsrc=IlPT2AEptyoA_yixCFOxXnANedT62v3IEQGG_ytK1DK6mlrte4viZQRAZiHqMXK4E587umP0sqdFtXLR_7Em9RJCrLIwdzZz&eqid=bf394e07cd73e0001000000258b8e53d&wd=&clk_info=%257B%2522srcid%2522%253A%25221599%2522%252C%2522tplname%2522%253A%2522www_normal%2522%252C%2522t%2522%253A1488512324271%252C%2522xpath%2522%253A%2522div-a-h3-em3%2522%257D][Linux secure boot(安全启动)时添加 Nvidia 显卡驱动 - 诸葛孔明没灯 - 博客园]]
   #+BEGIN_QUOTE
   Linux secure boot(安全启动)时添加 Nvidia 显卡驱动
   开启 Secure boot 情况下，在 Fedora 21 下安装 Nvidia 显卡驱动的方法。
   Nvidia 显卡驱动可以从官网上下载最新版>> 点击进入
   下载后添加可执行权限：
   #chmod +x NVIDIA-Linux*.run
   注意，安装 Nvidia 显卡需要满足的两个条件是
   1. nouveau（默认的显卡驱动）驱动程序必须禁用
   2. Xserver（图形界面） 要停止运行
   以上两个问题的解决方法如下：

   首先按 Ctrl + Alt + F2 进入终端
   输入 root 的帐号和密码后执行以下操作

   1. 禁用 nouveau 显卡驱动
   #dracut --omit-drivers nouveau /boot/initramfs-$(uname -r).img $(uname -r) --force

   2. 停止 Xserver
   #service gdm stop
   #service lightgdm stop
   3. 安装编译所需的程序
   #yum install gcc kernel-devel

   然后进入放 NVIDIA-linux*.run 的目录，执行该文件，按照提示进行操作。
   由于我这台机器已经安装好了驱动程序，就不再执行了（所以截图也就没有了）。
   注意在执行过程中，会出现提示是否使用 dkms，由于在 secure boot 下使用 dkms 会导致无法开机，这里选择 NO(否)。
   经过编译后会提示是否 sign the kernel module（为内核模块签名），这里要选择是。接下来会继续问使用已有的密钥给模块签名还是重新生成。
   这里选在重新生成密钥。继续下去之后，密钥会在/usr/share/nvidia/下生成一个 nvidia*.der（私钥）文件和 nvidia*.key（公钥）文件，当提示是否删除已生成的密钥文件时，选择否，
   因为之后要用到这两个文件。继续安装程序到最后会提示无法启动模块。这是因为生成的密钥还没有添加到内核的信任库中。
   添加密钥到内核的信任列表中：

   #mokutil --import /usr/share/nvidia/nvida*.der

   接下来会提示输入密码，两次输入密码后重启系统。
   #reboot

   重启进入 bootloader 之后，由于进行了添加密钥操作，会触发 shim，shim 会要求输入上一步输入的密码来导入密钥。按步骤操作。

   导入密钥之后，启动时内核就可以成功加载编译过的 Nvidia 显卡驱动了。

   启动进入系统后，就可以正常使用了。需要注意的是，由于生成的密钥添加到了内核的信任列表中，所以对生成的私钥和公钥一定要妥善保管。
   #+END_QUOTE
** DONE [[http://luveelin.blog.163.com/blog/static/119492341201251943213676/][GoldenDict - luveelin 的日志 - 网易博客]]                   :ubuntu:app:
   CLOSED: [2017-03-08 三 09:38]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-03-08 三 09:38]
   :END:
   Source: [2017-03-08 三], [[http://luveelin.blog.163.com/blog/static/119492341201251943213676/][GoldenDict - luveelin 的日志 - 网易博客]]
   #+BEGIN_QUOTE
   GoldenDict
   =sudo apt-get install goldendict=
   #+END_QUOTE
** DONE [[http://luveelin.blog.163.com/blog/static/119492341201251943213676/][GoldenDict - luveelin 的日志 - 网易博客]]
   CLOSED: [2017-03-08 三 09:39]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-03-08 三 09:39]
   :END:
   Source: [2017-03-08 三], [[http://luveelin.blog.163.com/blog/static/119492341201251943213676/][GoldenDict - luveelin 的日志 - 网易博客]]
   #+BEGIN_QUOTE
   GoldenDict  
   how to setup dictionaries for goldendict
   #+END_QUOTE
** DONE [[http://www.jb51.net/LINUXjishu/501994.html][linux 下.run 文件的安装与卸载方法_LINUX_操作系统_脚本之家]] :ubuntu:command:
   CLOSED: [2017-03-08 三 10:19]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-03-08 三 10:19]
   :END:
   Source: [2017-03-08 三], [[http://www.jb51.net/LINUXjishu/501994.html][linux 下.run 文件的安装与卸载方法_LINUX_操作系统_脚本之家]]
   #+BEGIN_QUOTE
   比如安装 QT 编程软件
   安装方法如下
   命令第一步：chmod +x qt-unified-linux-x64-2.0.2-2-online.run
   命令第二步：./qt-unified-linux-x64-2.0.2-2-online.run
   之后就出现 QT 安装的可视化界面

   安装完后就可以用了 ,chmod 实际上是加权限命令 。＋x 表示可以执行

   chmod [-cfvR] [--help] [--version] mode file...

   说明 : Linux/Unix 的档案调用权限分为三级 : 档案拥有者、群组、其他。利用 chmod 可以藉以控制档案如何被他人所调用。

   参数 :
   mode : 权限设定字串，格式如下 : [ugoa...][[+-=][rwxX]...][,...]，其中
   u 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。
   + 表示增加权限、- 表示取消权限、= 表示唯一设定权限。
   r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。
   -c : 若该档案权限确实已经更改，才显示其更改动作
   -f : 若该档案权限无法被更改也不要显示错误讯息
   -v : 显示权限变更的详细资料
   -R : 对目前目录下的所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更)
   --help : 显示辅助说明
   --version : 显示版本 linux
   #+END_QUOTE
** DONE [[http://blog.csdn.net/ningzb/article/details/7174087][无法在模块路径中找到主题引擎 pixmap 解决办法 - ningzb 的专栏 - 博客频道 - CSDN.NET]] :ubuntu:error:
   CLOSED: [2017-03-08 三 10:42]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-03-08 三 10:42]
   :END:
   Captured On: [2017-03-08 三 10:36]
** DONE [[https://bbs.deepin.org/forum.php?mod=viewthread&tid=42163&extra=][无法在模块路径中找到主题引擎 adwaita-深度科技论坛|深度操作系统正在为全世界的电脑提供强劲动力！]] :ubuntu:error:
   CLOSED: [2017-03-08 三 10:42]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-03-08 三 10:42]
   :END:
   Captured On: [2017-03-08 三 10:39]
** TODO [[http://blog.csdn.net/bill_chuang/article/details/18087307][修改 Chrome 打开 mms 链接的默认程序 - bill_chuang 的专栏 - 博客频道 - CSDN.NET]]
   Source: [2017-03-09 Thu], [[http://blog.csdn.net/bill_chuang/article/details/18087307][修改 Chrome 打开 mms 链接的默认程序 - bill_chuang 的专栏 - 博客频道 - CSDN.NET]]
   #+BEGIN_QUOTE
   *the principle of org-capture extension in chrome*
   CentOS 中如果在 Chrome 中要打开 mms：//的链接，默认是用 totem 打开的，但是众所周知 totem 是比较搓的，所以我想用 smplayer 打开，怎么办呢？由于在点击 mms：//的链接是会弹出一个对话框让你启动应用程序，注意到 Chrome 是用 xdg-open 命令来打开外部程序的，由于 xdg-open 是一个 shell 程序，那么就我们修改一下 xdg-open 命令。

   #vi /usr/bin/xdg-open

   由于 CentOS 用的 gnome，所以找到 open_gnome()函数，其他桌面的找对应的函数，如下

   open_gnome()
   {
       if gvfs-open --help 2>/dev/null 1>&2; then
           gvfs-open "$1"
       else
           gnome-open "$1"
       fi
       if [ $? -eq 0 ]; then
           exit_success
       else
           exit_failure_operation_failed
       fi
   }
   可以在函数体前面添加一段判断语句，改成

   open_gnome()
   {
   if  echo "$1" | grep -q 'mms://'; then
       smplayer "$1"
   else
       if gvfs-open --help 2>/dev/null 1>&2; then
              totem "$1"
       else
              gnome-open "$1"
       fi
   fi
   if [ $? -eq 0 ]; then
       exit_success
   else
       exit_failure_operation_failed
   fi
   }
   然后保存，这样 Chrome 就可以用 smplayer 打开 mms 链接了


   #+END_QUOTE
** TODO [[http://blog.csdn.net/lidonghat/article/details/52891439][{emacs}dired mode - 烂笔头 - 博客频道 - CSDN.NET]]
   Source: [2017-03-09 Thu], [[http://blog.csdn.net/lidonghat/article/details/52891439][{emacs}dired mode - 烂笔头 - 博客频道 - CSDN.NET]]
   #+BEGIN_QUOTE
   应用实例：dired-mode 交互查找替换多个文件中的字符串

   Call dired to list files in dir, or call find-dired if you need all sub directories;
   Mark the files you want. You can mark by regex by typing 【% m】.
   Type Q to call “dired-do-query-replace-regexp”.
   Type your find regex and replace string.
   For each occurrence,
   y to replace
   n to skip
   Ctrl+g to abort the whole operation
   ! to replace all occurrences in current file without asking
   N to skip all possible replacement for rest of the current file
   YTo do the replacement on all files without further asking
   Call ibuffer to list all opened files. Type * u to mark all unsaved files, type S to save all marked files, type D to close them all.

   #+END_QUOTE
** TODO [[https://github.com/YiddishKop/org-capture-extension][YiddishKop/org-capture-extension: A Chrome extension facilitating org-capture in emacs]]
   Source: [2017-03-09 Thu], [[https://github.com/YiddishKop/org-capture-extension][YiddishKop/org-capture-extension: A Chrome extension facilitating org-capture in emacs]]
   #+BEGIN_QUOTE
   cat > "${HOME}/.local/share/applications/org-protocol.desktop" << EOF
   [Desktop Entry]
   Name=org-protocol
   Exec=emacsclient %u
   Type=Application
   Terminal=false
   Categories=System;
   MimeType=x-scheme-handler/org-protocol;
   EOF
   And then (for non-KDE)

   update-desktop-database ~/.local/share/applications/
   #+END_QUOTE
** DONE [[https://github.com/zsh-users/zsh-autosuggestions][zsh-users/zsh-autosuggestions: Fish-like autosuggestions for zsh]] :ubuntu:ohmyzsh:
   CLOSED: [2017-03-09 Thu 13:20]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-03-09 Thu 13:20]
   :END:
   Source: [2017-03-09 Thu], [[https://github.com/zsh-users/zsh-autosuggestions][zsh-users/zsh-autosuggestions: Fish-like autosuggestions for zsh]]
   #+BEGIN_QUOTE
   Oh My Zsh

   Clone this repository into $ZSH_CUSTOM/plugins (by default ~/.oh-my-zsh/custom/plugins)

   git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions
   Add the plugin to the list of plugins for Oh My Zsh to load:

   plugins=(zsh-autosuggestions)
   Start a new terminal session.
   #+END_QUOTE
** DONE [[https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md][zsh-syntax-highlighting/INSTALL.md at master · zsh-users/zsh-syntax-highlighting]] :ubuntu:ohmyzsh:
   CLOSED: [2017-03-09 Thu 13:19]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-03-09 Thu 13:19]
   :END:
   Source: [2017-03-09 Thu], [[https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md][zsh-syntax-highlighting/INSTALL.md at master · zsh-users/zsh-syntax-highlighting]]
   #+BEGIN_QUOTE
   Oh-my-zsh

   Clone this repository in oh-my-zsh's plugins directory:

   git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting
   Activate the plugin in ~/.zshrc:

   plugins=( [plugins...] zsh-syntax-highlighting)
   Source ~/.zshrc to take changes into account:

   source ~/.zshrc
   #+END_QUOTE
** DONE [[https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md][zsh-syntax-highlighting/INSTALL.md at master · zsh-users/zsh-syntax-highlighting]] :ubuntu:ohmyzsh:
   CLOSED: [2017-03-09 Thu 13:18]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-03-09 Thu 13:18]
   :END:
   #+BEGIN_QUOTE
   Oh-my-zsh

   Clone this repository in oh-my-zsh's plugins directory:

   git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting
   Activate the plugin in ~/.zshrc:

   plugins=( [plugins...] zsh-syntax-highlighting)
   Source ~/.zshrc to take changes into account:

   source ~/.zshrc
   #+END_QUOTE
** DONE Link directly to Server pc to surfer internet, but can not access google.com by chrom :ubuntu:network:dns:
   CLOSED: [2017-03-09 Thu 14:55]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-03-09 Thu 14:55]
   :END:
   Source: [2017-03-09 Thu], [[http://www.phillip.hk/?p=3852][我似朝露降人间 » Ubuntu14.04 修改/etc/resolv.conf]]
   #+BEGIN_QUOTE
   Ubuntu 14.04 手动修改/etc/resolv.conf 文件后，然后重启，发现修改并未生效。发现/etc/resolv.conf 文件头有以下文字:

   1
   2
   # Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
   #     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
   网上找到一则有效的方法，先使用以下命令创建文件

   1
   # vim /etc/resolvconf/resolv.conf.d/tail
   然后加入要添加的 DNS 服务器,

   1
   nameserver 202.96.134.133
   保存退出，然后重启 resolvconf 服务即可。

   1
   #/etc/init.d/resolvconf restart
   #+END_QUOTE
** DONE [[http://www.cnblogs.com/zhenfei/p/6144892.html][ubuntu 如何 su 到 root（作为 root 用户操作） - 震撼起飞 - 博客园]] :ubuntu:su:
   CLOSED: [2017-03-09 Thu 17:41]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-03-09 Thu 17:41]
   :END:
   Source: [2017-03-09 Thu], [[http://www.cnblogs.com/zhenfei/p/6144892.html][ubuntu 如何 su 到 root（作为 root 用户操作） - 震撼起飞 - 博客园]]
   #+BEGIN_QUOTE
   ubuntu 如何 su 到 root（作为 root 用户操作）
   ubuntu 安装后，root 用户默认被锁定，不允许登录，也不允许“su”到 root。对于桌面用户来说，这样安全性更高一些，但对于服务器可以设置成“允许 su 到 root，但不允许 root 用户直接登录”。为了开发时的方便，我们常希望都采用这种方式，那么我们应该怎么办呢？请参考本文讨论的方法与建议

   允许 su 到 root

   非常简单，下面是设置的方法：

   ~$ sudo passwd root
   Password: <--- 输入安装时那个用户的密码
   Enter new UNIX password: <--- 新的 Root 用户密码
   Retype new UNIX password: <--- 重复新的 Root 用户密码
   passwd：已成功更新密码  
   #+END_QUOTE
** TODO root 與 普通用戶的切換，以及用戶組的概念            :ubuntu:su:group:
   Source: [2017-03-09 Thu], [[http://www.2cto.com/os/201401/271643.html][{Linux}用户切换-su 和 sudo - Linux 操作系统：Ubuntu_Centos_Debian - 红黑联盟]]
   #+BEGIN_QUOTE
   su
   如果你当前的身份是 root，则可以通过 su 命令切换到其它任何用户（无需密码），如下所示：
   [root@lx200 ~]# su - oracle
   [oracle@lx200 ~ ]$
   如果你当前的身份不是 root（即普通用户），想通过 su 切换成 root，则必须输入 root 的密码：
   [oracle@lx15 ~ ]$ su -
   Password:
   [root@lx15 ~ ]#
   当我们的 Linux 是多人管理时，如果通过 su 切换 root，则每个人都需要知道 root 密码，这非常不安全，因此 su 这种方式虽然简单，但实际使用中很少使用。
   sudo
   sudo 可以让普通用户在不需要知道 root 密码的情况下切换成 root 用户，首先我们需要通过配置/etc/sudoers，如下所示：
   Defaults visiblepw
   User_Alias ADMIN = root,admin
   ADMIN   ALL=(ALL) NOPASSWD: ALL
   首先，我们定义了一个用户组（注意：用户组名必须大写），该用户组包含 root 和 admin 用户这个文件最重要的是第三行，下面分别解释它的意思：1）第 1 列：用户账号，表示哪个账号可以使用 sudo 这个命令 2）第 2 列：限制登录这的来源主机名，ALL 表示不做限制 3）第 3 列：可切换的身份，ALL 表示可以切换成任何身份，NOPASSWD 表示免密码输入（如果没有 NOPASSWD，则每次切换都要输入自己的密码）4）第 4 列：可执行的命令，ALL 表示所有命令，如果要对命令进行限制，可以采用如下定义：
   zabbix  ALL=(ALL) NOPASSWD: /sbin/fuser, /usr/sbin/lsof, /usr/sbin/dmidecode, /sbin/mii-tool, /usr/sbin/iptstate
   注意：不要通过 vi 直接编辑/etc/sudoers，应该通过执行 visudo 命令编辑该文件，因为在结束离开时，系统会去检查/etc/sudoers 的语法。
   通过上面的配置，admin 用户就可以通过执行 sudo su - 命令免密码切换至 root，是不是很方便呢。
   #+END_QUOTE
** DONE [[http://www.jb51.net/LINUXjishu/152395.html][Linux traceroute 命令详解和使用例子（追踪路由信息）_LINUX_操作系统_脚本之家]] :ubuntu:network:traceroute:
   CLOSED: [2017-03-10 Fri 09:25]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-03-10 Fri 09:25]
   :END:
   Source: [2017-03-10 Fri], [[http://www.jb51.net/LINUXjishu/152395.html][Linux traceroute 命令详解和使用例子（追踪路由信息）_LINUX_操作系统_脚本之家]]
   #+BEGIN_QUOTE
   Linux traceroute 命令详解和使用例子（追踪路由信息）

   作者：佚名 字体：[增加 减小] 来源：互联网 时间：04-10 15:38:10 我要评论
   通过 traceroute 我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的

   linux 系统中，我们称之为 traceroute,在 MS Windows 中为 tracert。 traceroute 通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备 traceroute 要测 3 次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其 IP 地址。
   在大多数情况下，我们会在 linux 主机系统下，直接执行命令行：traceroute hostname
   而在 Windows 系统下是执行 tracert 的命令：tracert hostname
   1.命令格式：
   traceroute[参数][主机]
   2.命令功能：
   traceroute 指令让你追踪网络数据包的路由途径，预设数据包大小是 40Bytes，用户可另行设置。
   具体参数格式：traceroute [-dFlnrvx][-f<存活数值>][-g<网关>...][-i<网络界面>][-m<存活数值>][-p<通信端口>][-s<来源地址>][-t<服务类型>][-w<超时秒数>][主机名称或 IP 地址][数据包大小]
   3.命令参数：
   -d 使用 Socket 层级的排错功能。
   -f 设置第一个检测数据包的存活数值 TTL 的大小。
   -F 设置勿离断位。
   -g 设置来源路由网关，最多可设置 8 个。
   -i 使用指定的网络界面送出数据包。
   -I 使用 ICMP 回应取代 UDP 资料信息。
   -m 设置检测数据包的最大存活数值 TTL 的大小。
   -n 直接使用 IP 地址而非主机名称。
   -p 设置 UDP 传输协议的通信端口。
   -r 忽略普通的 Routing Table，直接将数据包送到远端主机上。
   -s 设置本地主机送出数据包的 IP 地址。
   -t 设置检测数据包的 TOS 数值。
   -v 详细显示指令的执行过程。
   -w 设置等待远端主机回报的时间。
   -x 开启或关闭数据包的正确性检验。
   4.使用实例：
   实例 1：traceroute 用法简单、最常用的用法
   命令：traceroute www.baidu.com 
   输出：

   复制代码代码如下:

   [root@localhost ~]# traceroute www.baidu.com
   traceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets
   1 192.168.74.2 (192.168.74.2) 2.606 ms 2.771 ms 2.950 ms
   2 211.151.56.57 (211.151.56.57) 0.596 ms 0.598 ms 0.591 ms
   3 211.151.227.206 (211.151.227.206) 0.546 ms 0.544 ms 0.538 ms
   4 210.77.139.145 (210.77.139.145) 0.710 ms 0.748 ms 0.801 ms
   5 202.106.42.101 (202.106.42.101) 6.759 ms 6.945 ms 7.107 ms
   6 61.148.154.97 (61.148.154.97) 718.908 ms * bt-228-025.bta.net.cn (202.106.228.25) 5.177 ms
   7 124.65.58.213 (124.65.58.213) 4.343 ms 4.336 ms 4.367 ms
   8 202.106.35.190 (202.106.35.190) 1.795 ms 61.148.156.138 (61.148.156.138) 1.899 ms 1.951 ms
   9 * * *
   30 * * *
   [root@localhost ~]#
   说明：
   记录按序列号从 1 开始，每个纪录就是一跳 ，每跳表示一个网关，我们看到每行有三个时间，单位是 ms，其实就是-q 的默认参数。探测数据包向每个网关发送三个数据包后，网关响应后返回的时间；如果您用 traceroute -q 4 www.58.com ，表示向每个网关发送 4 个数据包。
   有时我们 traceroute 一台主机时，会看到有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了 ICMP 的返回信息，所以我们得不到什么相关的数据包返回数据。
   有时我们在某一网关处延时比较长，有可能是某台网关比较阻塞，也可能是物理设备本身的原因。当然如果某台 DNS 出现问题时，不能解析主机名、域名时，也会 有延时长的现象；您可以加-n 参数来避免 DNS 解析，以 IP 格式输出数据。
   如果在局域网中的不同网段之间，我们可以通过 traceroute 来排查问题所在，是主机的问题还是网关的问题。如果我们通过远程来访问某台服务器遇到问题时，我们用到 traceroute 追踪数据包所经过的网关，提交 IDC 服务商，也有助于解决问题；但目前看来在国内解决这样的问题是比较困难的，就是我们发现问题所在，IDC 服务商也不可能帮助我们解决。
   #+END_QUOTE
** DONE [[https://github.com/adobe-fonts/source-code-pro/issues/17#issuecomment-8967116][Add font installation instructions for Linux · Issue #17 · adobe-fonts/source-code-pro]] :ubuntu:font:
   CLOSED: [2017-03-10 Fri 10:21]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-03-10 Fri 10:21]
   :END:
   Captured On: [2017-03-10 Fri 09:43]
** DONE [[http://linux.vbird.org/linux_basic/0240tarcompress.php#untar][鳥哥的 Linux 私房菜 -- 第八章、檔案與檔案系統的壓縮,打包與備份]] :ubuntu:backup:vbird:
   CLOSED: [2017-03-10 Fri 10:19]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-03-10 Fri 10:19]
   :END:
   Source: [2017-03-10 Fri], [[http://linux.vbird.org/linux_basic/0240tarcompress.php#untar][鳥哥的 Linux 私房菜 -- 第八章、檔案與檔案系統的壓縮,打包與備份]]

   8.1 壓縮檔案的用途與技術

   你是否有過文件檔案太大，導致無法以正常的 email 方式發送出去 (很多 email 都有
   容量大約 25MB 每封信的限制啊！)？ 又或者學校、廠商要求使用 CD 或 DVD 來傳遞歸
   檔用的資料，但是你的單一檔案卻都比這些傳統的一次性儲存媒體還要大！那怎麼分成
   多片來燒錄呢？ 還有，你是否有過要備份某些重要資料，偏偏這些資料量太大了，耗掉
   了你很多的磁碟空間呢？ 這個時候，那個好用的『檔案壓縮』技術可就派的上用場了！

   因為這些比較大型的檔案透過所謂的檔案壓縮技術之後，可以將他的磁碟使用量降低，
   可以達到減低檔案容量的效果。此外，有的壓縮程式還可以進行容量限制， 使一個大型
   檔案可以分割成為數個小型檔案，以方便軟碟片攜帶呢！

   那麼什麼是『檔案壓縮』呢？我們來稍微談一談他的原理好了。目前我們使用的電腦系
   統中都是使用所謂的 bytes 單位來計量的！不過，事實上，電腦最小的計量單位應該是
   bits 才對啊。此外，我們也知道 1 byte = 8 bits。但是如果今天我們只是記憶一個
   數字，亦即是 1 這個數字呢？他會如何記錄？假設一個 byte 可以看成底下的模樣：

   □□□□□□□□

   Tips 由於 1 byte = 8 bits，所以每個 byte 當中會有 8 個空格，
   而每個空格可以是 0, 1，這裡僅是做為一個約略的介紹， 更多的詳細資料請參考第零
   章的計算機概論吧！

   由於我們記錄數字是 1，考慮電腦所謂的二進位喔，如此一來，1 會在最右邊佔據 1
   個 bit，而其他的 7 個 bits 將會自動的被填上 0 囉！你看看，其實在這樣的例子中，
   那 7 個 bits 應該是『空的』才對！不過，為了要滿足目前我們的作業系統資料的存取，
   所以就會將該資料轉為 byte 的型態來記錄了！而一些聰明的電腦工程師就利用一些複
   雜的計算方式， 將這些沒有使用到的空間『丟』出來，以讓檔案佔用的空間變小！這就
   是壓縮的技術啦！

   另外一種壓縮技術也很有趣，他是將重複的資料進行統計記錄的。舉例來說，如果你的
   資料為『111....』共有 100 個 1 時， 那麼壓縮技術會記錄為『100 個 1』而不是真的有 100
   個 1 的位元存在！這樣也能夠精簡檔案記錄的容量呢！ 非常有趣吧！

   簡單的說，你可以將他想成，其實檔案裡面有相當多的『空間』存在，並不是完全填滿
   的， 而『壓縮』的技術就是將這些『空間』填滿，以讓整個檔案佔用的容量下降！ 不
   過，這些『壓縮過的檔案』並無法直接被我們的作業系統所使用的，因此， 若要使用這
   些被壓縮過的檔案資料，則必須將他『還原』回來未壓縮前的模樣， 那就是所謂的『解
   壓縮』囉！而至於壓縮後與壓縮的檔案所佔用的磁碟空間大小， 就可以被稱為是『壓縮
   比』囉！更多的技術文件或許你可以參考一下：

   RFC 1952 文件：http://www.ietf.org/rfc/rfc1952.txt 鳥哥站上的備份：
   http://linux.vbird.org/linux_basic/0240tarcompress/0240tarcompress_gzip.php

   這個『壓縮』與『解壓縮』的動作有什麼好處呢？最大的好處就是壓縮過的檔案容量變小
   了， 所以你的硬碟容量無形之中就可以容納更多的資料。此外，在一些網路資料的傳輸
   中，也會由於資料量的降低， 好讓網路頻寬可以用來作更多的工作！而不是老是卡在一
   些大型的檔案傳輸上面呢！目前很多的 WWW 網站也是利用檔案壓縮的技術來進行資料的
   傳送，好讓網站頻寬的可利用率上升喔！

   Tips 上述的 WWW 網站壓縮技術蠻有趣的！他讓你網站上面『看的到的資料』在經過網路傳
   輸時，使用的是『壓縮過的資料』， 等到這些壓縮過的資料到達你的電腦主機時，再進
   行解壓縮，由於目前的電腦運算速度相當的快速， 因此其實在網頁瀏覽的時候，時間都
   是花在『資料的傳輸』上面，而不是 CPU 的運算啦！如此一來，由於壓縮過的資料量降
   低了，自然傳送的速度就會增快不少！

   若你是一位軟體工程師，那麼相信你也會喜歡將你自己的軟體壓縮之後提供大家下載來
   使用， 畢竟沒有人喜歡自己的網站天天都是頻寬滿載的吧？舉個例子來說，Linux
   3.10.81 (CentOS 7 用的延伸版本) 完整的核心大小約有 570 MB 左右，而由於核心主
   要多是 ASCII code 的純文字型態檔案，這種檔案的『多餘空間』最多了。而一個提供
   下載的壓縮過的 3.10.81 核心大約僅有 76MB 左右，差了幾倍呢？你可以自己算一算喔！

***  8.2 Linux 系統常見的壓縮指令

    在 Linux 的環境中，壓縮檔案的副檔名大多是：『*.tar, *.tar.gz, *.tgz, *.gz, *.Z,
    *.bz2, *.xz』，為什麼會有這樣的副檔名呢？不是說 Linux 的副檔名沒有什麼作用嗎？

    這是因為 Linux 支援的壓縮指令非常多，且不同的指令所用的壓縮技術並不相同，當然
    彼此之間可能就無法互通壓縮/解壓縮檔案囉。 所以，當你下載到某個壓縮檔時，自然
    就需要知道該檔案是由哪種壓縮指令所製作出來的，好用來對照著解壓縮啊！ 也就是說，
    雖然 Linux 檔案的屬性基本上是與檔名沒有絕對關係的， 但是為了幫助我們人類小小
    的腦袋瓜子，所以適當的副檔名還是必要的！ 底下我們就列出幾個常見的壓縮檔案副檔
    名吧：

    .Z compress 程式壓縮的檔案；
    .zip zip 程式壓縮的檔案；
    .gz gzip 程式壓縮的檔案；
    .bz2 bzip2 程式壓縮的檔案；
    .xz xz 程式壓縮的檔案；
    .tar tar 程式打包的資料，並沒有壓縮過；
    .tar.gz tar 程式打包的檔案，其中並且經過 gzip 的壓縮
    .tar.bz2.tar 程式打包的檔案，其中並且經過 bzip2 的壓縮
    .tar.xz tar 程式打包的檔案，其中並且經過 xz 的壓縮

    Linux 上常見的壓縮指令就是 gzip, bzip2 以及最新的 xz，至於 compress 已經退流
    行了。為了支援 windows 常見的 zip，其實 Linux 也早就有 zip 指令了！gzip 是由
    GNU 計畫所開發出來的壓縮指令，該指令已經取代了 compress。 後來 GNU 又開發出
    bzip2 及 xz 這幾個壓縮比更好的壓縮指令！不過，這些指令通常僅能針對一個檔案來
    壓縮與解壓縮，如此一來， 每次壓縮與解壓縮都要一大堆檔案，豈不煩人？此時，那個
    所謂的『打包軟體, tar』就顯的很重要啦！

    這個 tar 可以將很多檔案『打包』成為一個檔案！甚至是目錄也可以這麼玩。不過，單
    純的 tar 功能僅是『打包』而已，亦即是將很多檔案集結成為一個檔案， 事實上，他
    並沒有提供壓縮的功能，後來，GNU 計畫中，將整個 tar 與壓縮的功能結合在一起，如
    此一來提供使用者更方便並且更強大的壓縮與打包功能！ 底下我們就來談一談這些在
    Linux 底下基本的壓縮指令吧！

****   Top 8.2.1 gzip, zcat/zmore/zless/zgrep

     gzip 可以說是應用度最廣的壓縮指令了！目前 gzip 可以解開 compress, zip 與 gzip
     等軟體所壓縮的檔案。 至於 gzip 所建立的壓縮檔為 *.gz 的檔名喔！讓我們來看看這
     個指令的語法吧：

     [dmtsai@study ~]$ gzip [-cdtv#] 檔名
     [dmtsai@study ~]$ zcat 檔名.gz 選項與參數：
     -c：將壓縮的資料輸出到螢幕上，可透過資料流重導向來處理；
     -d：解壓縮的參數；
     -t：可以用來檢驗一個壓縮檔的一致性～看看檔案有無錯誤；
     -v：可以顯示出原檔案/壓縮檔案的壓縮比等資訊；
     -# ：# 為數字的意思，代表壓縮等級，-1 最快，但是壓縮比最差、-9 最慢，但是壓縮比最好！預設是 -6

     範例一：找出 /etc 底下 (不含子目錄) 容量最大的檔案，並將它複製到 /tmp，然後以 gzip 壓縮
     [dmtsai@study ~]$ ls -ldSr /etc/*
     # 忘記選項意義？請自行 man 囉！.....(前面省略).....
     -rw-r--r--. 1 root root 25213 Jun 10 2014 /etc/dnsmasq.conf
     -rw-r--r--. 1 root root 69768 May 4 17:55 /etc/ld.so.cache
     -rw-r--r--. 1 root root 670293 Jun 7 2013 /etc/services

     [dmtsai@study ~]$ cd /tmp
     [dmtsai@study tmp]$ cp /etc/services .
     [dmtsai@study tmp]$ gzip -v services
     services: 79.7% -- replaced with services.gz
     [dmtsai@study tmp]$ ll /etc/services /tmp/services*
     -rw-r--r--. 1 root   root   670293 Jun 7 2013 /etc/services
     -rw-r--r--. 1 dmtsai dmtsai 136088 Jun 30 18:40 /tmp/services.gz
     當你使用 gzip 進行壓縮時，在預設的狀態下原本的檔
     案會被壓縮成為 .gz 的檔名，原始檔案就不再存在了。 這點與一般習慣使用 windows
     做壓縮的朋友所熟悉的情況不同喔！要注意！要注意！ 此外，使用 gzip 壓縮的檔案在
     Windows 系統中，竟然可以被 WinRAR/7zip 這個軟體解壓縮呢！很好用吧！至於其他的
     用法如下：

     範例二：由於 services 是文字檔，請將範例一的壓縮檔的內容讀出來！
     [dmtsai@study tmp]$ zcat services.gz
     # 由於 services 這個原本的檔案是是文字檔，因此我們可以嘗試使用 zcat/zmore/zless 去讀取！
     # 此時螢幕上會顯示 servcies.gz 解壓縮之後的原始檔案內容！

     範例三：將範例一的檔案解壓縮
     [dmtsai@study tmp]$ gzip -d services.gz
     # 鳥哥不要使用 gunzip 這個指令，不好背！使用 gzip -d 來進行解壓縮！
     # 與 gzip 相反，gzip -d 會將原本的 .gz 刪除，回復到原本的 services 檔案。

     範例四：將範例三解開的 services 用最佳的壓縮比壓縮，並保留原本的檔案
     [dmtsai@study tmp]$ gzip -9 -c services > services.gz

     範例五：由範例四再次建立的 services.gz 中，找出 http 這個關鍵字在哪幾行？
     [dmtsai@study tmp]$ zgrep -n 'http' services.gz 14:#
     http://www.iana.org/assignments/port-numbers 89:http 80/tcp www www-http #
     WorldWideWeb HTTP 90:http 80/udp www www-http # HyperText Transfer Protocol
     .....(底下省略)..... 其實 gzip 的壓縮已經最佳化過了，所以雖然 gzip 提供 1~9
     的壓縮等級，不過使用預設的 6 就非常好用了！ 因此上述的範例四可以不要加入那個
     -9 的選項。範例四的重點在那個 -c 與 > 的使用囉！-c 可以將原本要轉成壓縮檔的資
     料內容，將它變成文字類型從螢幕輸出， 然後我們可以透過大於 (>) 這個符號，將原
     本應該由螢幕輸出的資料，轉成輸出到檔案而不是螢幕，所以就能夠建立出壓縮擋了。
     只是檔名也要自己寫， 當然最好還是遵循 gzip 的壓縮檔名要求較佳喔！！更多的 >
     這個符號的應用，我們會在 bash 章節再次提及！

     cat/more/less 可以使用不同的方式來讀取純文字檔，那個 zcat/zmore/zless 則可以
     對應於 cat/more/less 的方式來讀取純文字檔被壓縮後的壓縮檔！ 由於 gzip 這個壓
     縮指令主要想要用來取代 compress 的，所以不但 compress 的壓縮檔案可以使用 gzip
     來解開，同時 zcat 這個指令可以同時讀取 compress 與 gzip 的壓縮檔呦！

     另外，如果你還想要從文字壓縮檔當中找資料的話，可以透過 zgrep 來搜尋關鍵字喔！
     而不需要將壓縮檔解開才以 grep 進行！ 這對查詢備份中的文字檔資料相當有用！

     Tips 時至今日，應該也沒有人愛用 compress 這個老老的指令了！因此，這一章已經拿
     掉了 compress 的介紹～而如果你還有備份資料使用的是 compress 建置出來的 .Z 檔
     案，那也無須擔心，使用 znew 可以將該檔案轉成 gzip 的格示喔！



****   Top 8.2.2 bzip2, bzcat/bzmore/bzless/bzgrep

     若說 gzip 是為了取代 compress 並提供更好的壓縮比而成立的，那麼 bzip2 則是為了
     取代 gzip 並提供更佳的壓縮比而來的。bzip2 真是很不錯用的東西～這玩意的壓縮比
     竟然比 gzip 還要好～至於 bzip2 的用法幾乎與 gzip 相同！看看底下的用法吧！

     [dmtsai@study ~]$ bzip2 [-cdkzv#] 檔名
     [dmtsai@study ~]$ bzcat 檔名.bz2 選項與
     參數：
     -c：將壓縮的過程產生的資料輸出到螢幕上！
     -d：解壓縮的參數
     -k：保留原始檔案，而不會刪除原始的檔案喔！
     -z：壓縮的參數 (預設值，可以不加)
     -v：可以顯示出原檔案/壓縮檔案的壓縮比等資訊；
     -# ：與 gzip 同樣的，都是在計算壓縮比的參數， -9 最佳， -1 最快！

     範例一：將剛剛 gzip 範例留下來的 /tmp/services 以 bzip2 壓縮[dmtsai@study
     tmp]$ bzip2 -v services services: 5.409:1, 1.479 bits/byte, 81.51% saved,
     670293 in, 123932 out. [dmtsai@study tmp]$ ls -l services* -rw-r--r--. 1
     dmtsai dmtsai 123932 Jun 30 18:40 services.bz2 -rw-rw-r--. 1 dmtsai dmtsai
     135489 Jun 30 18:46 services.gz
     # 此時 services 會變成 services.bz2 之外，你也可以發現 bzip2 的壓縮比要較 gzip 好喔！！
     # 壓縮率由 gzip 的 79% 提升到 bzip2 的 81% 哩！

     範例二：將範例一的檔案內容讀出來！[dmtsai@study tmp]$ bzcat services.bz2

     範例三：將範例一的檔案解壓縮[dmtsai@study tmp]$ bzip2 -d services.bz2

     範例四：將範例三解開的 services 用最佳的壓縮比壓縮，並保留原本的檔案
     [dmtsai@study tmp]$ bzip2 -9 -c services > services.bz2
     看上面的範例，你會發現 到 bzip2 連選項與參數都跟 gzip 一模一樣！只是副檔名由 .gz 變成 .bz2 而已！其
     他的用法都大同小異，所以鳥哥就不一一介紹了！ 你也可以發現到 bzip2 的壓縮率確
     實比 gzip 要好些！不過，對於大容量檔案來說，bzip2 壓縮時間會花比較久喔！至少
     比 gzip 要久的多！ 這沒辦法～要有更多可用容量，就得要花費相對應的時間！還 OK
     啊！



****   Top 8.2.3 xz, xzcat/xzmore/xzless/xzgrep

     雖然 bzip2 已經具有很棒的壓縮比，不過顯然某些自由軟體開發者還不滿足，因此後來
     還推出了 xz 這個壓縮比更高的軟體！這個軟體的用法也跟 gzip/bzip2 幾乎一模一樣！
     那我們就來瞧一瞧！

     [dmtsai@study ~]$ xz [-dtlkc#] 檔名
     [dmtsai@study ~]$ xcat 檔名.xz 選項與參數：
     -d：就是解壓縮啊！
     -t：測試壓縮檔的完整性，看有沒有錯誤
     -l：列出壓縮檔的相關資訊
     -k：保留原本的檔案不刪除～
     -c：同樣的，就是將資料由螢幕上輸出的意思！
     -# ：同樣的，也有較佳的壓縮比的意思！

     範例一：將剛剛由 bzip2 所遺留下來的 /tmp/services 透過 xz 來壓縮！
     [dmtsai@study tmp]$ xz -v services
     services (1/1) 100 % 97.3 KiB / 654.6 KiB = 0.149

     [dmtsai@study tmp]$ ls -l services*
     -rw-rw-r--. 1 dmtsai dmtsai 123932 Jun 30 19:09 services.bz2
     -rw-rw-r--. 1 dmtsai dmtsai 135489 Jun 30 18:46 services.gz
     -rw-r--r--. 1 dmtsai dmtsai 99608 Jun 30 18:40 services.xz
     # 各位觀眾！看到沒有啊！！容量又進一步下降的更多耶！好棒的壓縮比！

     範例二：列出這個壓縮檔的資訊，然後讀出這個壓縮檔的內容[dmtsai@study tmp]$ xz -l services.xz
     Strms Blocks Compressed Uncompressed Ratio Check Filename
     1     1      97.3 KiB   654.6 KiB    0.149 CRC64 services.xz
     # 竟然可以列出這個檔案的壓縮前後的容量，真是太人性化了！這樣觀察就方便多了！

     [dmtsai@study tmp]$ xzcat services.xz

     範例三：將他解壓縮吧！
     [dmtsai@study tmp]$ xz -d services.xz

     範例四：保留原檔案的檔名，並且建立壓縮檔！
     [dmtsai@study tmp]$ xz -k services
     雖然 xz 這個壓縮比真的好太多太多了！以鳥哥選擇的這個 services 檔案為範例，他
     可以將 gzip 壓縮比 (壓縮後/壓縮前) 的 21% 更進一步優化到 15% 耶！ 差非常非常
     多！不過，xz 最大的問題是...時間花太久了！如果你曾經使用過 xz 的話，應該會有
     發現，他的運算時間真的比 gzip 久很多喔！

     鳥哥以自己的系統，透過『 time [gzip|bzip2|xz] -c services > services.[gz|bz2|xz] 』
     去執行運算結果，結果發現這三個指令的執行時間依序是：
     0.019s, 0.042s, 0.261s， 看最後一個數字！差了 10 倍的時間耶！所以，如果你並不
     覺得時間是你的成本考量，那麼使用 xz 會比較好！如果時間是你的重要成本，那麼
     gzip 恐怕是比較適合的壓縮軟體喔！


***   8.3 打包指令：tar

    前一小節談到的指令大多僅能針對單一檔案來進行壓縮，雖然 gzip, bzip2, xz 也能夠
    針對目錄來進行壓縮，不過， 這兩個指令對目錄的壓縮指的是『將目錄內的所有檔案 "
    分別" 進行壓縮』的動作！而不像在 Windows 的系統，可以使用類似 WinRAR 這一類的
    壓縮軟體來將好多資料『包成一個檔案』的樣式。

    這種將多個檔案或目錄包成一個大檔案的指令功能，我們可以稱呼他是一種『打包指令』
    啦！ 那 Linux 有沒有這種打包指令呢？是有的！那就是鼎鼎大名的 tar 這個玩意兒了！
    tar 可以將多個目錄或檔案打包成一個大檔案，同時還可以透過 gzip/bzip2/xz 的支援，
    將該檔案同時進行壓縮！ 更有趣的是，由於 tar 的使用太廣泛了，目前 Windows 的
    WinRAR 也支援 .tar.gz 檔名的解壓縮呢！ 很不錯吧！所以底下我們就來玩一玩這個咚
    咚！

****   Top 8.3.1 tar

     tar 的選項與參數非常的多！我們只講幾個常用的選項，更多選項您可以自行 man tar
     查詢囉！

     [dmtsai@study ~]$ tar [-z|-j|-J] [cv] [-f 待建立的新檔名] filename... <==打包與壓縮
     [dmtsai@study ~]$ tar [-z|-j|-J] [tv] [-f 既有的 tar 檔名] <==察看檔名
     [dmtsai@study ~]$ tar [-z|-j|-J] [xv] [-f 既有的 tar 檔名] [-C 目錄] <==解壓縮
     選項與參數：
     -c：建立打包檔案，可搭配 -v 來察看過程中被打包的檔名(filename)
     -t：察看打包檔案的內容含有哪些檔名，重點在察看『檔名』就是了；
     -x：解打包或解壓縮的功能，可以搭配 -C (大寫) 在特定目錄解開特別留意的是， -c, -t, -x 不可同時出現在一串指令列中。
     -z：透過 gzip 的支援進行壓縮/解壓縮：此時檔名最好為 *.tar.gz
     -j：透過 bzip2 的支援進行壓縮/解壓縮：此時檔名最好為 *.tar.bz2
     -J：透過 xz 的支援進行壓縮/解壓縮：此時檔名最好為 *.tar.xz 特別留意， -z, -j, -J 不可以同時出現在一串指令列中
     -v：在壓縮/解壓縮的過程中，將正在處理的檔名顯示出來！
     -f filename：-f 後面要立刻接要被處理的檔名！建議 -f 單獨寫一個選項囉！ (比較不會忘記)
     -C 目錄 ：這個選項用在解壓縮，若要在特定目錄解壓縮，可以使用這個選項。

     其他後續練習會使用到的選項介紹：
     -p(小寫) ：保留備份資料的原本權限與屬性，常用於備份(-c)重要的設定檔
     -P(大寫) ：保留絕對路徑，亦即允許備份資料中含有根目錄存在之意；
     --exclude=FILE：在壓縮的過程中，不要將 FILE 打包！ 其實最簡單的使用 tar 就只要記憶底下的方式即可：

     壓　縮：tar -jcv -f filename.tar.bz2
     要被壓縮的檔案或目錄名稱查詢：tar -jtv -f filename.tar.bz2
     解壓縮：tar -jxv -f filename.tar.bz2 -C 欲解壓縮的目錄

     那個 filename.tar.bz2 是我們自己取的檔名，tar 並不會主動的產生建立的檔名喔！我們要
     自訂啦！ 所以副檔名就顯的很重要了！如果不加 [-z|-j|-J] 的話，檔名最好取為
     *.tar 即可。如果是 -j 選項，代表有 bzip2 的支援，因此檔名最好就取為 *.tar.bz2
     ，因為 bzip2 會產生 .bz2 的副檔名之故！ 至於如果是加上了 -z 的 gzip 的支援，
     那檔名最好取為 *.tar.gz 喔！瞭解乎？

     另外，由於『 -f filename 』是緊接在一起的，過去很多文章常會寫成『-jcvf
     filename』，這樣是對的， 但由於選項的順序理論上是可以變換的，所以很多讀者會誤
     認為『-jvfc filename』也可以～事實上這樣會導致產生的檔名變成 c！ 因為 -fc 嘛！
     所以囉，建議您在學習 tar 時，將『 -f filename 』與其他選項獨立出來，會比較不
     容易發生問題。

     閒話少說，讓我們來測試幾個常用的 tar 方法吧！

     使用 tar 加入 -z, -j 或 -J 的參數備份 /etc/ 目錄有事沒事備份一下 /etc 這個目
     錄是件好事！備份 /etc 最簡單的方法就是使用 tar 囉！讓我們來玩玩先：

     [dmtsai@study ~]$ su -
     # 因為備份 /etc 需要 root 的權限，否則會出現一堆錯誤
     [root@study ~]# time tar -zpcv -f /root/etc.tar.gz /etc

     tar: Removing leading `/' from member names <==注意這個警告訊息/etc/ ....(中間省略)....
     /etc/hostname /etc/aliases.db

     real 0m0.799s
     # 多了 time 會顯示程式運作的時間！看 real 就好了！花去了 0.799s user 0m0.767s sys 0m0.046s
     # 由於加上 -v 這個選項，因此正在作用中的檔名就會顯示在螢幕上。
     # 如果你可以翻到第一頁，會發現出現上面的錯誤訊息！底下會講解。
     # 至於 -p 的選項，重點在於『保留原本檔案的權限與屬性』之意。

     [root@study ~]# time tar -jpcv -f /root/etc.tar.bz2 /etc
     ....(前面省略)....
     real 0m1.913s user 0m1.881s sys 0m0.038s

     [root@study ~]# time tar -Jpcv -f /root/etc.tar.xz /etc
     ....(前面省略)....
     real 0m9.023s user 0m8.984s sys 0m0.086s
     # 顯示的訊息會跟上面一模一樣囉！不過時間會花比較多！使用了 -J 時，會花更多時間

     [root@study ~]# ll /root/etc*
     -rw-r--r--. 1 root root 6721809 Jul 1 00:16 /root/etc.tar.bz2
     -rw-r--r--. 1 root root 7758826 Jul 1 00:14 /root/etc.tar.gz
     -rw-r--r--. 1 root root 5511500 Jul 1 00:16 /root/etc.tar.xz
     [root@study ~]# du -sm /etc 28 /etc
     # 實際目錄約佔有 28MB 的意思！壓縮比越好
     當然要花費的運算時間越多！我們從上面可以看到，雖然使用 gzip 的速度相當快，總
     時間花費不到 1 秒鐘，但是壓縮率最糟糕！ 如果使用 xz 的話，雖然壓縮比最佳！不
     過竟然花了 9 秒鐘的時間耶！這還僅是備份 28MBytes 的 /etc 而已，如果備份的資料
     是很大容量的， 那你真的要考量時間成本才行！

     至於加上『 -p 』這個選項的原因是為了保存原本檔案的權限與屬性！我們曾在第六章
     的 cp 指令介紹時談到權限與檔案類型(例如連結檔)對複製的不同影響。 同樣的，在備
     份重要的系統資料時，這些原本檔案的權限需要做完整的備份比較好。此時 -p 這個選
     項就派的上用場了。 接下來讓我們看看打包檔案內有什麼資料存在？

     查閱 tar 檔案的資料內容 (可察看檔名)，與備份檔名有否根目錄的意義要察看由 tar
     所建立的打包檔案內部的檔名非常的簡單！可以這樣做：

     [root@study ~]# tar -jtv -f /root/etc.tar.bz2
     ....(前面省略)....
     -rw-r--r-- root/root 131 2015-05-25 17:48 etc/locale.conf
     -rw-r--r-- root/root 19 2015-05-04 17:56 etc/hostname
     -rw-r--r-- root/root 12288 2015-05-04 17:59 etc/aliases.db
     如果加上 -v 這個選項時，詳細的檔案權限/屬性都會被列出來！如果只
     是想要知道檔名而已， 那麼就將 -v 拿掉即可。從上面的資料我們可以發現一件很有趣
     的事情，那就是每個檔名都沒了根目錄了！這也是上一個練習中出現的那個警告訊息
     『tar: Removing leading `/' from member names(移除了檔名開頭的 `/' )』所告知
     的情況！

     那為什麼要拿掉根目錄呢？主要是為了安全！我們使用 tar 備份的資料可能會需要解壓
     縮回來使用， 在 tar 所記錄的檔名 (就是我們剛剛使用 tar -jtvf 所察看到的檔名)
     那就是解壓縮後的實際檔名。 如果拿掉了根目錄，假設你將備份資料在 /tmp 解開，那
     麼解壓縮的檔名就會變成『/tmp/etc/xxx』。 但『如果沒有拿掉根目錄，解壓縮後的檔
     名就會是絕對路徑， 亦即解壓縮後的資料一定會被放置到 /etc/xxx 去！』如此一來，
     你的原本的 /etc/ 底下的資料， 就會被備份資料所覆蓋過去了！

     Tips 你會說：『既然是備份資料，那麼還原回來也沒有什麼問題吧？』想像一個狀況，
     你備份的資料是兩年前的舊版 CentOS 6.x， 你只是想要瞭解一下過去的備份內容究竟
     有哪些資料而已，結果一解開該檔案，卻發現你目前新版的 CentOS 7.x 底下的 /etc
     被舊版的備份資料覆蓋了！此時你該如何是好？大概除了哭哭你也不能做啥事吧？所以
     囉，當然是拿掉根目錄比較安全一些的。

     如果你確定你就是需要備份根目錄到 tar 的檔案中，那可以使用 -P (大寫) 這個選項，
     請看底下的例子分析：

     範例：將檔名中的(根)目錄也備份下來，並察看一下備份檔的內容檔名

     [root@study ~]# tar -jpPcv -f /root/etc.and.root.tar.bz2 /etc
     [root@study ~]# tar -jtf /root/etc.and.root.tar.bz2 /etc/locale.conf /etc/hostname /etc/aliases.db

     # 這次查閱檔名不含 -v 選項，所以僅有檔名而已！沒有詳細屬性/權限等參數。
     有發現不同點了吧？如果加上 -P 選項，那麼檔名內的根目錄就會存在喔！不過，鳥哥
     個人建議，還是不要加上 -P 這個選項來備份！ 畢竟很多時候，我們備份是為了要未來
     追蹤問題用的，倒不一定需要還原回原本的系統中！ 所以拿掉根目錄後，備份資料的應
     用會比較有彈性！也比較安全呢！

     將備份的資料解壓縮，並考慮特定目錄的解壓縮動作 (-C 選項的應用)那如果想要解打
     包呢？很簡單的動作就是直接進行解打包嘛！

     [root@study ~]# tar -jxv -f /root/etc.tar.bz2
     [root@study ~]# ll
     ....(前面省 略)....
     drwxr-xr-x. 131 root root 8192 Jun 26 22:14 etc
     ....(後面省略)....
     此時該打包檔案會在『本目錄下進行解壓縮』的動作！ 所以，你等一下就會在家目錄底下
     發現一個名為 etc 的目錄囉！所以囉，如果你想要將該檔案在 /tmp 底下解開， 可以
     cd /tmp 後，再下達上述的指令即可。不過，這樣好像很麻煩呢～有沒有更簡單的方法
     可以『指定欲解開的目錄』呢？ 有的，可以使用 -C 這個選項喔！舉例來說：

     [root@study ~]# tar -jxv -f /root/etc.tar.bz2 -C /tmp
     [root@study ~]# ll /tmp
     ....(前面省略)....
     drwxr-xr-x. 131 root root 8192 Jun 26 22:14 etc
     ....(後面 省略)....
     這樣一來，你就能夠將該檔案在不同的目錄解開囉！鳥哥個人是認為，這個
     -C 的選項務必要記憶一下的！ 好了，處理完畢後，請記得將這兩個目錄刪除一下呢！

     [root@study ~]# rm -rf /root/etc /tmp/etc
     再次強調，這個『 rm -rf 』是很危險的指令！下達時請務必要確認一下後面接的檔名。我們要刪除的是 /root/etc 與
     /tmp/etc， 您可不要將 /etc/ 刪除掉了！系統會死掉的～ ^_^

     僅解開單一檔案的方法剛剛上頭我們解壓縮都是將整個打包檔案的內容全部解開！想像
     一個情況，如果我只想要解開打包檔案內的其中一個檔案而已， 那該如何做呢？很簡單
     的，你只要使用 -jtv 找到你要的檔名，然後將該檔名解開即可。 我們用底下的例子來
     說明一下：

     # 1. 先找到我們要的檔名，假設解開 shadow 檔案好了：
     [root@study ~]# tar -jtv -f /root/etc.tar.bz2 | grep 'shadow' ----------
     root/root 721 2015-06-17 00:20 etc/gshadow ---------- root/root 1183
     2015-06-17 00:20 etc/shadow- ---------- root/root 1210 2015-06-17 00:20
     etc/shadow <==這是我們要的！---------- root/root 707 2015-06-17 00:20
     etc/gshadow-
     # 先搜尋重要的檔名！其中那個 grep 是『擷取』關鍵字的功能！我們會在第三篇說明！
     # 這裡您先有個概念即可！那個管線 | 配合 grep 可以擷取關鍵字的意思！

     # 2. 將該檔案解開！語法與實際作法如下：
     [root@study ~]# tar -jxv -f 打包檔.tar.bz2 待解開檔名[root@study ~]# tar -jxv
     -f /root/etc.tar.bz2 etc/shadow etc/shadow [root@study ~]# ll etc total 4
     ----------. 1 root root 1210 Jun 17 00:20 shadow
     # 很有趣！此時只會解開一個檔案而已！不過，重點是那個檔名！你要找到正確的檔名。
     # 在本例中，你不能寫成 /etc/shadow！因為記錄在 etc.tar.bz2 內的並沒有 / 之故！
     Tips 在這個練習之前，你可能要先將前面練習所產生的 /root/etc 刪除才行！不然
     /root/etc/shadow 會重複存在，而其他的前面實驗的檔案也會存在， 那就看不出什麼
     鬼～

     打包某目錄，但不含該目錄下的某些檔案之作法假設我們想要打包 /etc/ /root 這幾個
     重要的目錄，但卻不想要打包 /root/etc* 開頭的檔案，因為該檔案都是剛剛我們才建
     立的備份檔嘛！ 而且假設這個新的打包檔案要放置成為 /root/system.tar.bz2，當然
     這個檔案自己不要打包自己 (因為這個檔案放置在 /root 底下啊！)，此時我們可以透
     過 --exclude 的幫忙！ 那個 exclude 就是不包含的意思！所以你可以這樣做：

     [root@study ~]# tar -jcv -f /root/system.tar.bz2 --exclude=/root/etc* \
     > --exclude=/root/system.tar.bz2 /etc /root

     上面的指令是一整列的～其實你可以打成：

     『tar -jcv -f /root/system.tar.bz2 --exclude=/root/etc* --exclude=/root/system.tar.bz2 /etc /root』

     如果想要兩行輸入時，最後面加上反 斜線 (\) 並立刻按下 [enter] ， 就能夠到第二行繼續輸入了。這個指令下達的方式我
     們會在第三章再仔細說明。 透過這個 --exclude="file" 的動作，我們可以將幾個特殊
     的檔案或目錄移除在打包之列，讓打包的動作變的更簡便喔！^_^

     僅備份比某個時刻還要新的檔案某些情況下你會想要備份新的檔案而已，並不想要備份
     舊檔案！此時 --newer-mtime 這個選項就粉重要啦！ 其實有兩個選項啦，一個是
     『 --newer 』另一個就是『 --newer-mtime 』，這兩個選項有何不同呢？ 我們在 第
     六章的 touch 介紹中談到過三種不同的時間參數， 當使用 --newer 時，表示後續的日
     期包含『 mtime 與 ctime 』，而 --newer-mtime 則僅是 mtime 而已！ 這樣知道了吧！
     ^_^ 。那就讓我們來嘗試處理一下囉！

     # 1. 先由 find 找出比 /etc/passwd 還要新的檔案
     [root@study ~]# find /etc -newer /etc/passwd ....(過程省略)....
     # 此時會顯示出比 /etc/passwd 這個檔案的 mtime 還要新的檔名，
     # 這個結果在每部主機都不相同！您先自行查閱自己的主機即可，不會跟鳥哥一樣！

     [root@study ~]# ll /etc/passwd
     -rw-r--r--. 1 root root 2092 Jun 17 00:20 /etc/passwd

     # 2. 好了，那麼使用 tar 來進行打包吧！日期為上面看到的 2015/06/17
     [root@study ~]# tar -jcv -f /root/etc.newer.then.passwd.tar.bz2 \
     > --newer-mtime="2015/06/17" /etc/*

     tar: Option --newer-mtime: Treating date `2015/06/17' as 2015-06-17 00:00:00
     tar: Removing leading `/' from member names /etc/abrt/
     ....(中間省略)....
     /etc/alsa/ /etc/yum.repos.d/
     ....(中間省 略)....
     tar: /etc/yum.repos.d/CentOS-fasttrack.repo: file is unchanged; not dumped
     # 最後行顯示的是『沒有被備份的』，亦即 not dumped 的意思！

     # 3. 顯示出檔案即可
     [root@study ~]# tar -jtv -f /root/etc.newer.then.passwd.tar.bz2 | grep -v '/$'
     # 透過這個指令可以呼叫出 tar.bz2 內的結尾非 / 的檔名！就是我們要的啦！
     現在你知道這個指令的好用了吧！甚至可以進行差異檔案的記錄與備份呢～ 這樣子的備
     份就會顯的更容易囉！你可以這樣想像，如果我在一個月前才進行過一次完整的資料備
     份， 那麼這個月想要備份時，當然可以僅備份上個月進行備份的那個時間點之後的更新
     的檔案即可！ 為什麼呢？因為原本的檔案已經有備份了嘛！幹嘛還要進行一次？只要備
     份新資料即可。這樣可以降低備份的容量啊！

     基本名稱：tarfile, tarball？另外值得一提的是，tar 打包出來的檔案有沒有進行
     壓縮所得到檔案稱呼不同喔！ 如果僅是打包而已，就是『 tar -cv -f file.tar 』而
     已，這個檔案我們稱呼為 tarfile。 如果還有進行壓縮的支援，例如『 tar -jcv -f
     file.tar.bz2 』時，我們就稱呼為 tarball (tar 球？)！這只是一個基本的稱謂而已，
     不過很多書籍與網路都會使用到這個 tarball 的名稱！所以得要跟您介紹介紹。

     此外，tar 除了可以將資料打包成為檔案之外，還能夠將檔案打包到某些特別的裝置去，
     舉例來說， 磁帶機 (tape) 就是一個常見的例子。磁帶機由於是一次性讀取/寫入的裝
     置，因此我們不能夠使用類似 cp 等指令來複製的！ 那如果想要將 /home, /root,
     /etc 備份到磁帶機 (/dev/st0) 時，就可以使用：『tar -cv -f /dev/st0 /home
     /root /etc』，很簡單容易吧！ 磁帶機用在備份 (尤其是企業應用) 是很常見的工作喔！

     特殊應用：利用管線命令與資料流在 tar 的使用中，有一種方式最特殊，那就是透過標
     準輸入輸出的資料流重導向(standard input/standard output)， 以及管線命令
     (pipe) 的方式，將待處理的檔案一邊打包一邊解壓縮到目標目錄去。 關於資料流重導
     向與管線命令更詳細的資料我們會在第十章 bash 再跟大家介紹， 底下先來看一個例子
     吧！

     # 1. 將 /etc 整個目錄一邊打包一邊在 /tmp 解開
     [root@study ~]# cd /tmp [root@study tmp]# tar -cvf - /etc | tar -xvf -
     # 這個動作有點像是 cp -r /etc /tmp 啦～依舊是有其有用途的！
     # 要注意的地方在於輸出檔變成 - 而輸入檔也變成 - ，又有一個 | 存在～
     # 這分別代表 standard output, standard input 與管線命令啦！
     # 簡單的想法中，你可以將 - 想成是在記憶體中的一個裝置(緩衝區)。
     # 更詳細的資料流與管線命令，請翻到 bash 章節囉！
     在上面的例子中，我們想要『將 /etc 底下的資料直接 copy 到目前所在的路徑，也就
     是 /tmp 底下』，但是又覺得使用 cp -r 有點麻煩，那麼就直接以這個打包的方式來打
     包，其中，指令裡面的 - 就是表示那個被打包的檔案啦！ 由於我們不想要讓中間檔案
     存在，所以就以這一個方式來進行複製的行為啦！

     例題：系統備份範例系統上有非常多的重要目錄需要進行備份，而且其實我們也不建議
     你將備份資料放置到 /root 目錄下！ 假設目前你已經知道重要的目錄有底下這幾個：

     /etc/ (設定檔) /home/ (使用者的家目錄) /var/spool/mail/ (系統中，所有帳號的郵
     件信箱) /var/spool/cron/ (所有帳號的工作排成設定檔) /root (系統管理員的家目錄)然
     後我們也知道，由於第七章曾經做過的練習的關係， /home/loop* 不需要備份，而且
     /root 底下的壓縮檔也不需要備份，另外假設你要將備份的資料放置到 /backups，並
     且該目錄僅有 root 有權限進入！ 此外，每次備份的檔名都希望不相同，例如使用：
     backup-system-20150701.tar.bz2 之類的檔名來處理。 那你該如何處理這個備份資料
     呢？(請先動手作看看，再來察看一下底下的參考解答！)

     # 1. 先處理要放置備份資料的目錄與權限：
     [root@study ~]# mkdir /backups [root@study ~]# chmod 700 /backups [root@study
     ~]# ll -d /backups drwx------. 2 root root 6 Jul 1 17:25 /backups

     # 2. 假設今天是 2015/07/01，則建立備份的方式如下：
     [root@study ~]# tar -jcv -f /backups/backup-system-20150701.tar.bz2 \ >
     --exclude=/root/*.bz2 --exclude=/root/*.gz --exclude=/home/loop* \ > /etc
     /home /var/spool/mail /var/spool/cron /root ....(過程省略)....

     [root@study ~]# ll -h /backups/ -rw-r--r--. 1 root root 21M Jul 1 17:26
     backup-system-20150701.tar.bz2 解壓縮後的 SELinux 課題如果，鳥哥是說如果，如果
     因為某些緣故，所以你的系統必須要以備份的資料來回填到原本的系統中，那麼得要特
     別注意復原後的系統的 SELinux 問題！ 尤其是在系統檔上面！例如 /etc 底下的檔案
     群。SELinux 是比較特別的細部權限設定，相關的介紹我們會在 16 章好好的介紹一下。
     在這裡，你只要先知道，SELinux 的權限問題『可能會讓你的系統無法存取某些設定檔
     內容，導致影響到系統的正常使用權』。

     這兩天 (2015/07) 接到一個網友的 email，他說他使用鳥哥介紹的方法透過 tar 去備
     份了 /etc 的資料，然後嘗試在另一部系統上面復原回來。 復原倒是沒問題，但是復原
     完畢之後，無論如何就是無法正常的登入系統！明明使用單人維護模式去操作系統時，
     看起來一切正常～但就是無法順利登入。 其實這個問題倒是很常見！大部分原因就是因
     為 /etc/shadow 這個密碼檔案的 SELinux 類型在還原時被更改了！導致系統的登入程
     序無法順利的存取它， 才造成無法登入的窘境。

     那如何處理呢？簡單的處理方式有這幾個：

     透過各種可行的救援方式登入系統，然後修改 /etc/selinux/config 檔案，將 SELinux
     改成 permissive 模式，重新開機後系統就正常了；在第一次復原系統後，不要立即重
     新開機！先使用 restorecon -Rv /etc 自動修復一下 SELinux 的類型即可。透過各種
     可行的方式登入系統，建立 /.autorelabel 檔案，重新開機後系統會自動修復 SELinux
     的類型，並且又會再次重新開機，之後就正常了！鳥哥個人是比較偏好第 2 個方法，不
     過如果忘記了該步驟就重新開機呢？那鳥哥比較偏向使用第 3 個方案來處理，這樣就能
     夠解決復原後的 SELinux 問題囉！ 至於更詳細的 SELinux，我們得要講完程序
     (process) 之後，你才會有比較清楚的認知，因此還請慢慢學習，到第 16 章你就知道
     問題點了！ ^_^
** DONE [[http://duplicity.nongnu.org/index.html][duplicity: Main]]                                  :ubuntu:backup:tool:
   CLOSED: [2017-03-10 Fri 10:54]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-03-10 Fri 10:54]
   :END:
   Captured On: [2017-03-10 Fri 10:50]
** DONE [[http://www.nongnu.org/rdiff-backup/index.html][rdiff-backup: Main]]                               :ubuntu:backup:tool:
   CLOSED: [2017-03-10 Fri 10:54]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-03-10 Fri 10:54]
   :END:
   Captured On: [2017-03-10 Fri 10:50]
** DONE [[http://www.2cto.com/os/201406/307246.html][linux 下修改文件的用户组 chgrp 和文件所有者 chown - Linux 操作系统：Ubuntu_Centos_Debian - 红黑联盟]] :ubuntu:su:
   CLOSED: [2017-03-10 Fri 11:15]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-03-10 Fri 11:15]
   :END:
   Source: [2017-03-10 Fri], [[http://www.2cto.com/os/201406/307246.html][linux 下修改文件的用户组 chgrp 和文件所有者 chown - Linux 操作系统：Ubuntu_Centos_Debian - 红黑联盟]]
   #+BEGIN_QUOTE
   1. linux 下修改文件用户组

   chgrp：change group 的简写，修改文件所属的用户组。
   chgrp users test.log
   修改后查看 ls -l
   -rwxrwx---  1 work users 0 Jun  8 15:46 test.log
   如果要修改该目录下所有文件和目录，使用-R 参数。
   chgrp -R users test
   要被改变的 group 名，必须在 /etc/group 文件中。 /etc/group 文件记录系统中所有的组名称。
   2. linux 下修改文件所有者

   chown：change owner 的简写， 修改文件的所有者。
   chown [-R] 账号名称  文件或目录
   -R 递归，将子目录下文件全部修改。
   将文件所有者修改 bin
   chown bin test.log
   修改的用户必须在/etc/passwd 文件中 /etc/passwd 记录用户信息。
   chown 还可以修改组名称
   chown root:root test.log
   将所有者和组名称都修改为 root。
   #+END_QUOTE
** DONE [[https://zhidao.baidu.com/question/1511453925736908820.html][PDFLaTeX 和 XeLaTeX 有什么区别_百度知道]]    :ubuntu:org:export:pdf:latex:
   CLOSED: [2017-03-10 Fri 22:25]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-03-10 Fri 22:25]
   :END:
   Source: [2017-03-10 Fri], [[https://zhidao.baidu.com/question/1511453925736908820.html][PDFLaTeX 和 XeLaTeX 有什么区别_百度知道]]
   #+BEGIN_QUOTE
   pdfLaTeX 是比较原始的版本，对 Unicode 的支持不是很好，所以显示汉字需要使用 CJK 宏包。
   它不支持操作系统的 truetype 字体(*.ttf)，只能使用 type1 字体。优点是支持的宏包比较
   多，有些老一点的宏包必须用 pdfLaTeX 来编译。

   XeLaTeX 是新的 Unicode 版本，内建支持 Unicode(UTF-8)，自然也包括汉字在内，而且可以
   调用操作系统的 truetype 字体。如果你的文档有汉字，那么推荐用 XeLaTeX。缺点是不支持
   某一些宏包。

   #+END_QUOTE
** DONE [[https://tieba.baidu.com/p/3230241781][ubuntu linux 系统按键互换_我用 linux 吧_百度贴吧]]     :switch:key:ubuntu:
   CLOSED: [2017-03-11 Sat 10:06]
   :LOGBOOK:
   - State "DONE"       from "DONE"       [2017-03-11 Sat 10:08]
   - State "DONE"       from "TODO"       [2017-03-11 Sat 10:06]
   :END:
   Source: [2017-03-11 Sat], [[https://tieba.baidu.com/p/3230241781][ubuntu linux 系统按键互换_我用 linux 吧_百度贴吧]]
   #+BEGIN_QUOTE

*以下按键的互换在图形界面上才起作用*

1、首先用 xmodmap -pke 命令，得到一份各个按键代码及其作用：
keycode 9 = Escape NoSymbol Escape
keycode 10 = 1 exclam 1 exclam
keycode 11 = 2 at 2 at
keycode 12 = 3 numbersign 3 numbersign
keycode 13 = 4 dollar 4 dollar
keycode 14 = 5 percent 5 percent
keycode 15 = 6 asciicircum 6 asciicircu
……

2、然后用 xev |grep keycode 命令，查看物理按键的代码。
例如：
按下左 ctrl 键是：
state 0x0, keycode 37 (keysym 0xffe3, Control_L), same_screen YES
按下左 Alt 键是
state 0x0, keycode 64 (keysym 0xffe9, Alt_L), same_screen YES,

3、查第一步的列表，得出按键代码 37、64 的完整表述：
keycode 37 = Control_L NoSymbol Control_L
keycode 64 = Alt_L Meta_L Alt_L Meta_L

4、如果要交换左 Ctrl 和左 Alt 键，可以将 37、64 交换，变成下面的样子：
keycode 64 = Control_L NoSymbol Control_L
keycode 37 = Alt_L Meta_L Alt_L Meta_L

5、可以使用 xmodmap 使之立即生效：
/usr/bin/xmodmap -e "keycode 64 = Control_L NoSymbol Control_L"
/usr/bin/xmodmap -e "keycode 37 = Alt_L Meta_L Alt_L Meta_L"

6、也可把上面两行保存为文件如 ~/.Xmodmaprc，
然后用 xmodmap ~/.Xmodmaprc 生效
可以把 xmodmap ~/.Xmodmaprc 命令放到 ~/.profile 开机时生效
放在 ~/.bashrc 中打开终端时生效，

----------- ~/.Xmodmaprc ----------------
! 以下是一个联想笔记本的键盘替换（home/pgup、end/pgdn、delete/pause）
! xmodmap -pke && xmodmap && xev |grep keycode &&
! xmodmap ~/.Xmodmaprc
! place in ~/.profile
keycode 110 = Prior NoSymbol Prior
keycode 112 = Home NoSymbol Home
keycode 115 = Next NoSymbol Next
keycode 117 = End NoSymbol End
keycode 127 = Delete NoSymbol Delete
keycode 119 = Pause Break Pause Break

---------------- ~/.keymap --------------------
推荐写成脚本，把文件名放入~/.profile 中
sleep 7 的作用是等待图形界面加载完毕再交换按键。
echo 到/tmp 以检查脚本是否在开机时已运行。

#!/bin/bash
# xmodmap -pke && xmodmap && xev |grep keycode &&
# xmodmap ~/.Xmodmaprc
# filename ~/.keymap
# place in ~/.profile
sleep 7
/usr/bin/xmodmap -e "keycode 110 = Prior NoSymbol Prior"
echo "key start 1" > /tmp/keymap.txt
/usr/bin/xmodmap -e "keycode 112 = Home NoSymbol Home"
/usr/bin/xmodmap -e "keycode 115 = Next NoSymbol Next"
/usr/bin/xmodmap -e "keycode 117 = End NoSymbol End"
/usr/bin/xmodmap -e "keycode 127 = Delete NoSymbol Delete"
/usr/bin/xmodmap -e "keycode 119 = Pause Break Pause Break
echo "key stop" >> /tmp/keymap.txt
   #+END_QUOTE
** DONE xmodmap is obsoleted, Don't use  :ubuntu:obsolete:xmodmap:key:switch:
   CLOSED: [2017-03-11 Sat 10:24]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-03-11 Sat 10:24]
   :END:
   Source: [2017-03-11 Sat], [[http://blog.csdn.net/kl28978113/article/details/44778415][Ubuntu 下 Swap left ctrl and alt - Bingo - 博客频道 - CSDN.NET]]
   #+BEGIN_QUOTE
   摘要 传统 xmodmap 已被废弃，只好 setxkbmap，自造 option 解决
   *So, Do not use xmodmap to switch ctrl and caps*
   #+END_QUOTE
** DONE xev 命令可以用来捕捉键盘按键事件。                 :ubuntu:key:switch:
   CLOSED: [2017-03-11 Sat 10:35]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-03-11 Sat 10:35]
   :END:
   Source: [2017-03-11 Sat], [[http://blog.csdn.net/kl28978113/article/details/42325139][在 Ubuntu 下交换 Esc 和 Caps Lock 按键 - Bingo - 博客频道 - CSDN.NET]]
   #+BEGIN_QUOTE
   p.s. 另外 xev 命令可以用来捕捉键盘按键事件。
   #+END_QUOTE
** DONE how to setup env for org export to pdf :ubuntu:org:export:latex:latex:cjk:
   CLOSED: [2017-03-11 Sat 10:58]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-03-11 Sat 10:58]
   :END:
   Source: [2017-03-11 Sat], [[http://www.th7.cn/system/lin/201601/151318.shtml][ubuntu14.04 安装 xelatex 以及实现中文输入_Linux_第七城市]]
   #+BEGIN_QUOTE
   安装 texlive-xelatex
   =sudo apt-get install texlive-xetex latex-cjk-all=
   #+END_QUOTE
** DONE [[https://www.foxitsoftware.com/downloads/thanks.php?product=Foxit-Reader&platform=Linux-64-bit&version=2.3.0.2174&package_type=run&language=English][Thank You for Downloading | Foxit Software]]  :ubuntu:pdf:foxit:reader:
   CLOSED: [2017-03-11 Sat 11:04]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-03-11 Sat 11:04]
   :END:
   Source: [2017-03-11 Sat], [[https://www.foxitsoftware.com/downloads/thanks.php?product=Foxit-Reader&platform=Linux-64-bit&version=2.3.0.2174&package_type=run&language=English][Thank You for Downloading | Foxit Software]]
   #+BEGIN_QUOTE
   Please follow the steps below to install Foxit Reader for Linux:

   Change to the directory containing the downloaded file (used /tmp as the example):
   # cd /tmp
   Uncompress the executable:
   # gzip -d 'FoxitReader_version_Setup.run.tar.gz'
   Untar the .tar file:
   # tar xvf 'FoxitReader_version_Setup.run.tar'
   Run the installer:
   # ./'FoxitReader_version_Setup.run'
   Follow the steps on the screen to complete the installation
   #+END_QUOTE
** DONE [[http://cs2.swfc.edu.cn/~wx672/lecture_notes/linux/latex/latex_tutorial.html][Emacs + LaTeX 快速上手]]  :emacs:latex:pdf:tutorial***:
   CLOSED: [2017-03-11 Sat 11:09]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-03-11 Sat 11:09]
   :END:
   Captured On: [2017-03-11 Sat 11:09]
** TODO how to setting up helo-hotspot

   #+BEGIN_SRC emacs-lisp
   (defun zilongshanren//hotspots-sources ()
   "Construct the helm sources for my hotspots"
   `((name . "Mail and News")
     (candidates . (("Calendar" . (lambda ()  (browse-url "https://www.google.com/calendar/render")))
                    ("RSS" . elfeed)
                    ("Blog" . org-octopress)
                    ("Github" . (lambda() (helm-github-stars)))
                    ("Calculator" . (lambda () (helm-calcul-expression)))
                    ("Run current flie" . (lambda () (zilongshanren/run-current-file)))
                    ("Agenda" . (lambda () (org-agenda "" "a")))
                    ("sicp" . (lambda() (browse-url "http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_start")))))
     (candidate-number-limit)
     (action . (("Open" . (lambda (x) (funcall x)))))))
   #+END_SRC
**  [[https://apps.ubuntu.com/cat/applications/precise/variety/][Variety — Ubuntu Apps Directory]]              :ubuntu:app:wallpaper:quote:
   Captured On: [2017-03-12 Sun 10:18]
**  [[http://stackoverflow.com/questions/3684212/using-strftime-function-in-mawk][awk - Using strftime function in mawk - Stack Overflow]] :ical2org:org:google:calendar:
   Captured On: [2017-03-12 Sun 12:55]
* 列表
  |数据结构| -> 指针/内存


  Lisp 程序开发通常呼应着开发 Lisp 语言自身
  列表  ->  多种数据结构

** major-core 数据结构
   当你赋一个值给变量或将这个值存在数据结构中，其实被储存的是指向这个值的指针。当你要取得变量的值，或是存在数据结构中的内容时，Lisp 返回指向这个值的指针。
   东西放在任何地方。除非你声明你不愿这么做，不然你能够在任何的数据结构，存放任何类型的对象，包括结构本身
   。在 Common Lisp 里，无论何时你使用一个数字来参照一个数据结构中的元素时，都是从 0 开始编号的。
   这不是个好名字，因为非正规列表的 Cons 对象通常不是用来表示列表： (a . b) 只是一个有两部分的数据结构
   。当程序进化时，你可以在代码的关键部分使用破坏性函数以及/或别种
*** minor-core 指针
    两部分的对象，称之为 Cons 对象。概念上来说，一个 Cons 是一对指针；第一个是 car，第二个是 cdr。
    Cons 所组成，见图 3.1。这种表达 Cons 的方式叫做箱子表示法 (box notation)，因为每一个 Cons 是用一个箱子表示，内含一个 car 和 cdr 的指针。当我们调用 car 与 cdr 时
    ，当我们调用 car 与 cdr 时，我们得到指针指向的地方：

    > (car x)
    A
    > (cdr x)
    NIL
    在一个有多个元素的列表中，car 指针让你取得元素，而 cdr 让你取得列表内其余的东西。
    当这种情况发生时，它的结构如图 3.3 所示；第二个 Cons 的 car 指针也指向一个列表：

    > (car (cdr z))
    (B C)

    每一次你调用 cons 时，Lisp 会配置一块新的内存给两个指针。
    一个理解 Lisp 的秘密之一是意识到变量是有值的，就像列表有元素一样。如同 Cons 对象有指针指向他们的元素，变量有指针指向他们的值。

    你可能在别的语言中使用过显式指针 (explicitly pointer)。在 Lisp，你永远不用这么做，因为语言帮你处理好指针了。

    当我们把 x 的值赋给 y 时，究竟发生什么事呢？内存中与 x 有关的位置并没有包含这个列表，而是一个指针指向它。当我们给 y 赋一个相同的值时，Lisp 复制的是指针，而不是列表
    电脑内部里，Cons 对象倾向于用指针表示，所以走访一个列表意味着走访一系列的指针，而不是简单地像数组一样增加索引值。但这两个所花的代价与配置及回收 Cons 核 (cons cells)比起来小多了。

    一开始我们调用 list，list 调用 cons，在堆上配置了一个新的 Cons 对象。在这个情况我们创出三个 Cons 对象。之后当我们把 lst 设为 nil，我们没有任何方法可以再存取 lst，列表 (a b c) 。 [5]

    因为我们没有任何方法再存取列表，它也有可能是不存在的。我们不再有任何方式可以存取的对象叫做垃圾。系统可以安全地重新使用这三个 Cons 核。

    这种管理內存的方法，给程序员带来极大的便利性。你不用显式地配置 (allocate)或释放 (dellocate)內存。这也表示了你不需要处理因为这么做而可能产生的臭虫。內存泄漏 (Memory leaks)以及迷途指针 (dangling pointer)在 Lisp 中根本不可能发生。
*** minor-core 内存
    每一次你调用 cons 时，Lisp 会配置一块新的内存给两个指针。所以如果我们用同样的参数调用 cons 两次，我们得到两个数值看起来一样，但实际上是两个不同的对象：

    > (eql (cons 'a nil) (cons 'a nil))
    NIL

    举例来说，因为一个小整数所需的内存空间，少于一个指针所需的空间，一个 Lisp 实现可能会直接处理这个小整数，而不是用指针来处理。但基本要点是，程序员预设可以把任何东西放在任何地方

    自动内存管理(Automatic memory management)是 Lisp 最有价值的特色之一。Lisp 系统维护着一段內存称之为堆(Heap)。系统持续追踪堆当中没有使用的内存，把这些内存发放给新产生的对象

    举例来说，函数 cons，返回一个新配置的 Cons 对象。从堆中配置内存有时候通称为 consing。

    所以系统必须周期性地通过搜索堆 (heap)，寻找不需要再使用的内存。

*** minor-core cons
    1. cons 真正所做的事情是，把两个对象结合成一个有两部分的对象，称之为 Cons 对象。
    2. 概念上来说，一个 Cons 是一对指针；第一个是 car，第二个是 cdr
    3. Cons 对象提供了一个方便的表示法，来表示任何类型的对象。


** 构造
** 等式
** why no pointers
** 建立列表
** 示例:压缩
** 存取
** 映射函数
** 树
** 理解递归
** 集合
** 序列
** 栈
** 点状列表
** 关联列表
** 示例:最短路径
** 垃圾回收
** 总结
* zilongshanren-org
  config.el
  funcs.el
  packages.el
** packages.el
*** org-todo-keywords
    #+BEGIN_SRC

    #+END_SRC
*** some trick
    Projects :Complex activities are projects, and are marked with the prj tag. They
    are supposed to contain todo items, and are considered stuck unless they do. The
    prj tag should not be inheritable, because otherwise its tasks will appear as
    projects:
    #+BEGIN_SRC emacs-lisp
(setq org-tags-exclude-from-inheritance '("prj")
      org-stuck-projects '("+prj/-MAYBE-DONE"
                           ("TODO" "TASK") ()))
    #+END_SRC
*** Agenda custom commands
    _what should attract my attention is that, the guy who can oganize the project
    management by hack org-agenda-custom-commands, the same way, zilonghack org to
    fit the 4fields working method._

    With all this we are ready to define the custom
    commands. The cjr tag marks personal todo items in my case; change to whatever
    suits you.
    #+BEGIN_SRC emacs-lisp
(setq org-agenda-custom-commands
      '(("h" "Work todos" tags-todo
         "-personal-doat={.+}-dowith={.+}/!-TASK"
         ((org-agenda-todo-ignore-scheduled t)))
        ("H" "All work todos" tags-todo "-personal/!-TASK-MAYBE"
         ((org-agenda-todo-ignore-scheduled nil)))
        ("A" "Work todos with doat or dowith" tags-todo
         "-personal+doat={.+}|dowith={.+}/!-TASK"
         ((org-agenda-todo-ignore-scheduled nil)))
        ("j" "TODO dowith and TASK with"
         ((org-sec-with-view "TODO dowith")
          (org-sec-where-view "TODO doat")
          (org-sec-assigned-with-view "TASK with")
          (org-sec-stuck-with-view "STUCK with")))
        ("J" "Interactive TODO dowith and TASK with"
         ((org-sec-who-view "TODO dowith")))))
    #+END_SRC
    downside, is the settings of zilong,
    #+BEGIN_SRC emacs-lisp
      (setq org-agenda-custom-commands
            '(
              ("w" . "任务安排")
              ("wa" "重要且紧急的任务" tags-todo "+PRIORITY=\"A\"")
              ("wb" "重要且不紧急的任务" tags-todo "-Weekly-Monthly-Daily+PRIORITY=\"B\"")
              ("wc" "不重要且紧急的任务" tags-todo "+PRIORITY=\"C\"")
              ("b" "Blog" tags-todo "BLOG")
              ("p" . "项目安排")
              ("pw" tags-todo "PROJECT+WORK+CATEGORY=\"cocos2d-x\"")
              ("pl" tags-todo "PROJECT+DREAM+CATEGORY=\"zilongshanren\"")
              ("W" "Weekly Review"
               ((stuck "") ;; review stuck projects as designated by org-stuck-projects
                (tags-todo "PROJECT") ;; review all projects (assuming you use todo keywords to designate projects)
                ))))
    #+END_SRC
    BTW, all this settings can be set graphically in start page of agend view
    =, a C=
*** Task and prj ownership
    Task and project ownership Ownership is managed with tags, one for each team
    member. When somebody owns a project his or her name will tag the project
    definition line, together with prj, and it will be inherited by all the TASK
    todo items belonging to the project. When a TASK todo item does not belong to a
    project it has at least a person's name tag.
*** org-babel settings
    #+BEGIN_SRC emacs-lisp
      ;; yiddi:add
      ;; http://emacs.stackexchange.com/questions/28441/org-mode-9-unable-to-eval-code-blocks
      ;; solve org9.0 babel cannot work
      (org-babel-do-load-languages
       'org-babel-load-languages
       '((perl . t)
         (ruby . t)
         (sh . t)
         (dot . t)
         (js . t)
         (latex .t)
         (python . t)
         (emacs-lisp . t)
         (plantuml . t)
         (C . t)
         (ditaa . t)
         ;; yiddi:add
         (calc . t)))
    #+END_SRC
* Org-babel with python programming style
  :PROPERTIES:
  :ID:       2e20c923-540e-449a-afdb-670449e0cf46
  :END:
  :URL:
  http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#module-structure
  :END:

  Following the structure outlined in Code Like a Pythonista, construct the
  python source file in sections:
  1. imports
  2. constants
  3. exception classes
  4. interface functions
  5. classes
  6. internal functions & classes

  #+BEGIN_SRC python :noweb yes :tangle HelloWorld.py :exports none
"""This is a hello world example document"""
# imports
import sys
<<helloworld-main-imports>>
# constants

# exception classes

# interface functions

# classes
<<HelloWorld-defn>>
# internal functions & classes
<<helloworld-main>>

if __name__ == '__main__':
    status = main()
    sys.exit(status)
  #+END_SRC

  When M-x org-babel-tangle is run within emacs, the :tangle HelloWorld.py line
  will cause it to generate a the file HelloWorld.py from the contents of the code
  blocks.
  The bracketed lines (helloworld-classes, for example) are code fragments that
  will be defined later. org-mode will automatically substitute these blocks when
  createing the HelloWorld.py file.
  Define the HelloWorld class thus:

  #+NAME: HelloWorld-defn
  #+BEGIN_SRC python
  class HelloWorld(object):
      def __init__(self, who):
          self.who = who

      def say_hello(self):
          print "Hello %s" % self.who
  #+END_SRC

  It's usually a good idea to have an argument parser in main. Start by creating a
  code block the performs the required imports:

  #+NAME: helloworld-main-imports
  #+BEGIN_SRC python
from argparse import ArgumentParser
  #+END_SRC

  #+NAME: helloworld-main
  #+BEGIN_SRC python
  def main():
      parser = ArgumentParser(description="Say hi")
      parser.add_argument("-w", "--who",
                          type=str,
                          default="world",
                          help="Who to say hello to")
      args = parser.parse_args()

      who = args.who

      greeter = HelloWorld(who)
      greeter.say_hello()

      return 0
  #+END_SRC

** TODO [#B] 理解 org-babel : literal programming
:LOGBOOK:
http://www.howardism.org/Technical/Emacs/literate-devops.html
http://www.howardism.org/Technical/LP/introduction.html
http://orgmode.org/worg/org-contrib/babel/intro.html
:END:

*** 可以用如下的方式来调用函数

#+name: square
#+header: :var x=0
#+begin_src python
return x*x
#+end_src
Now we use the source block:

#+call: square(x=6)

* English capture
** 1
   “The struggle of literature is in fact a struggle to escape from the confines
   of language; it stretches out from the utmost limits of what can be said; what
   stirs literature is the call and attraction of what is not in the
   dictionary.” - Italo Calvino
   <2017-03-05 日>
** 2
   “There comes a point in life when you realize everything you know about yourself, it's all just conditioning. It's the rare man who truly know who he is.” - Brian Buckner

* ANSI  lisp
** grammer

*** what is symbol
    Source: [2017-02-14 二], [[http://acl.readthedocs.io/en/latest/zhCN/ch2-cn.html][第二章：欢迎来到 Lisp — ANSI Common Lisp 中文版]]
    #+BEGIN_QUOTE
    有两个通常在别的语言所找不到的 Lisp 数据类型是符号（symbol）与列表（lists），符号是英语的单词 (words)。无论你怎么输入，通常会被转换为大写：

    > 'Artichoke
    ARTICHOKE
    符号（通常）不对自身求值，所以要是想引用符号，应该像上例那样用 ' 引用它。

    #+END_QUOTE
*** list and function
    Source: [2017-02-14 二], [[http://acl.readthedocs.io/en/latest/zhCN/ch2-cn.html][第二章：欢迎来到 Lisp — ANSI Common Lisp 中文版]]
    #+BEGIN_QUOTE
    列表是由被括号包住的零个或多个元素来表示。元素可以是任何类型，包含列表本身。使用列表必须要引用，不然 Lisp 会以为这是个函数调用：

    > '(my 3 "Sons")
    (MY 3 "Sons")
    > '(the list (a b c) has 3 elements)
    (THE LIST (A B C) HAS 3 ELEMENTS)
    注意引号保护了整个表达式（包含内部的子表达式）被求值。
    #+END_QUOTE
*** side-effect of function
    Source: [2017-02-14 二], [[http://acl.readthedocs.io/en/latest/zhCN/ch2-cn.html][第二章：欢迎来到 Lisp — ANSI Common Lisp 中文版]]
    #+BEGIN_QUOTE
    如果这些表达式没有副作用，你没有任何理由告诉 Lisp，为什么要去对它们求值。
    #+END_QUOTE
    seems like print() in python. what we use is the side-effect of this function.
    注意到有两个东西被打印出来。第一行是 format 印出来的。第二行是调用 format 函数的返回值，就像平常顶层会打印出来的一样。通常像 format 这种函数不会直接在顶层调用，而是在程序内部里使用，所以返回值不会被看到。

*** naming the global variable
    Source: [2017-02-14 二], [[http://acl.readthedocs.io/en/latest/zhCN/ch2-cn.html][第二章：欢迎来到 Lisp — ANSI Common Lisp 中文版]]
    #+BEGIN_QUOTE
    我们已经看过的这些变量都叫做局部变量。

    它们只在特定的上下文里有效。

    另外还有一种变量叫做全局变量（global variable），是在任何地方都是可视的。

    你可以给 defparameter 传入符号和值，来创建一个全局变量：

    通常我们在给全局变量命名时，以星号作开始与结束。刚才我们创造的变量可以念作 “星-glob-星” (star-glob-star)。


    也就是说，通过赋值，你可以隐式地创建全局变量。 不过，一般来说，还是使用 defparameter 明确地创建全局变量比较好。
*** never modify and interactive testing
    Source: [2017-02-14 二], [[http://acl.readthedocs.io/en/latest/zhCN/ch2-cn.html][第二章：欢迎来到 Lisp — ANSI Common Lisp 中文版]]
    举例来说，函数 remove 接受一个对象和一个列表，返回不含这个对象的新列表：

    > (setf lst '(c a r a t))
    (C A R A T)
    > (remove 'a lst)
    (C R T)
    为什么不干脆说 remove 从列表里移除一个对象？因为它不是这么做的。原来的表没有被改变：

    > lst
    (C A R A T)
    若你真的想从列表里移除某些东西怎么办？在 Lisp 通常你这么做，把这个列表当作实参，传入某个函数，并使用 setf 来处理返回值
    要移除所有在列表 x 的 a，我们可以说：

    (setf x (remove 'a x))

    函数式编程本质上意味着避免使用如 setf 的函数。起初可能觉得这根本不可能，更遑论去做了。怎么可以只凭返回值来建立程序？

    完全不用到副作用是很不方便的。然而，随着你进一步阅读，会惊讶地发现需要用到副作用的地方很少。副作用用得越少，你就更上一层楼。

    函数式编程最重要的优点之一是，它允许交互式测试（interactive testing）。
    在纯函数式的程序里，你可以测试每个你写的函数。如果它返回你预期的值，你可以有信心它是对的。
    这额外的信心，集结起来，会产生巨大的差别。当你改动了程序里的任何一个地方，会得到即时的改变。
    而这种即时的改变，使我们有一种新的编程风格。类比于电话与信件，让我们有一种新的通讯方式。

    #+END_QUOTE
*** recursive and iteration
    Source: [2017-02-14 二], [[http://acl.readthedocs.io/en/latest/zhCN/ch2-cn.html][第二章：欢迎来到 Lisp — ANSI Common Lisp 中文版]]
    #+BEGIN_QUOTE
    当我们想重复做一些事情时，迭代比递归来得更自然。典型的例子是用迭代来产生某种表格。这个函数

    (defun show-squares (start end)
    (do ((i start (+ i 1)))
    ((> i end) 'done)
    (format t "~A ~A~%" i (* i i))))
    列印从 start 到 end 之间的整数的平方：


    作为对比，以下是递归版本的 show-squares：

    (defun show-squares (i end)
    (if (> i end)
    'done
    (progn
    (format t "~A ~A~%" i (* i i))
    (show-squares (+ i 1) end))))
    #+END_QUOTE
*** function is symbol
    Source: [2017-02-14 二], [[http://acl.readthedocs.io/en/latest/zhCN/ch2-cn.html][第二章：欢迎来到 Lisp — ANSI Common Lisp 中文版]]
    #+BEGIN_QUOTE
    函数在 Lisp 里，和符号、字符串或列表一样，是稀松平常的对象。如果我们把函数的名字传给 function，它会返回相关联的对象。和 quote 类似，function 是一个特殊操作符，所以我们无需引用（quote）它的实参：

    > (function +)
    #<Compiled-Function + 17BA4E>
    这看起来很奇怪的返回值，是在典型的 Common Lisp 实现里，函数可能的打印表示法。

    #+END_QUOTE
*** inner-type of lisp
    Source: [2017-02-14 二], [[http://acl.readthedocs.io/en/latest/zhCN/ch2-cn.html][第二章：欢迎来到 Lisp — ANSI Common Lisp 中文版]]
    #+BEGIN_QUOTE
    Common Lisp 的内置类型，组成了一个类别的层级。对象总是不止属于一个类型。举例来说，数字 27 的类型，依普遍性的增加排序，依序是 fixnum、integer、rational、real、number、atom 和 t 类型。（数值类型将在第 9 章讨论。）类型 t 是所有类型的基类（supertype）。 *所以每个对象都属于 t 类型。*

    函数 typep 接受一个对象和一个类型，然后判定对象是否为该类型，是的话就返回真：

    > (typep 27 'integer)
    T
    #+END_QUOTE

    你不但在语言之中编程，还把 *语言改善成适合程序的语言* (which makes me exciting) 。如果你想了解 Lisp 编程的本质，理解这个概念是个好的开始。
*** rule of compute in lisp
    Common Lisp 函数调用的求值规则： 依序对实参从左至右求值，接着把它们的值传入由操作符表示的函数。
    quote 操作符有自己的求值规则，它完封不动地返回实参。
*** list function expression are the same thing
    除了一般的数据类型，Lisp 还有符号跟列表。由于 Lisp 程序是用列表来表示的，很轻松就能写出能编程的程序。

    Lisp 程序由表达式组成。表达式可以是原子，或一个由操作符跟着零个或多个实参的列表。前序表示法代表操作符可以有任意数量的实参。

    Lisp 主要由函数所组成。可以用 defun 来定义新的函数。
    函数式编程代表避免产生副作用，也是 Lisp 的主导思维。
    函数是 Lisp 的对象。可以被当成实参传入，并且可以用 lambda 表达式来表示。
    自己调用自己的函数是递归的。一个递归函数应该要被想成是过程，而不是机器。

    #+END_QUOTE
** functions
*** lisp -typep
    Source: [2017-02-14 二], [[http://acl.readthedocs.io/en/latest/zhCN/ch2-cn.html][第二章：欢迎来到 Lisp — ANSI Common Lisp 中文版]]
    #+BEGIN_QUOTE
    函数 typep 接受一个对象和一个类型，然后判定对象是否为该类型，是的话就返回真：

    > (typep 27 'integer)
    #+END_QUOTE
*** lisp -lambda
    Source: [2017-02-14 二], [[http://acl.readthedocs.io/en/latest/zhCN/ch2-cn.html][第二章：欢迎来到 Lisp — ANSI Common Lisp 中文版]]
    #+BEGIN_QUOTE
    一个 lambda 表达式是一个列表，列表包含符号 lambda，接着是形参列表，以及由零个或多个表达式所组成的函数体
    #+END_QUOTE
*** lisp -funcall & apply
    Source: [2017-02-14 二], [[http://acl.readthedocs.io/en/latest/zhCN/ch2-cn.html][第二章：欢迎来到 Lisp — ANSI Common Lisp 中文版]]
    #+BEGIN_QUOTE
    函数 funcall 做的是一样的事情，但不需要把实参包装成列表。

    > (funcall #'+ 1 2 3)
    6


    apply 接受一个函数和实参列表，并返回把传入函数应用在实参列表的结果：

    > (apply #'+ '(1 2 3))
    6
    > (+ 1 2 3)
    6
    apply 可以接受任意数量的实参，只要最后一个实参是列表即可：

    > (apply #'+ 1 2 '(3 4 5))
    15
    #+END_QUOTE
*** lisp -quote & function
    Source: [2017-02-14 二], [[http://acl.readthedocs.io/en/latest/zhCN/ch2-cn.html][第二章：欢迎来到 Lisp — ANSI Common Lisp 中文版]]
    #+BEGIN_QUOTE
    如同我们可以用 ' 作为 quote 的缩写，也可以用 #' 作为 function 的缩写
    Lisp 提供 quote 作为一种保护表达式不被求值的方式
    quote 操作符接受一个实参，并完封不动地返回它。

    > (quote (+ 3 5))
    贴上一个 ' ，与调用 quote 是同样的效果：

    > '(+ 3 5)
    #+END_QUOTE
*** lisp -progn
    Source: [2017-02-14 二], [[http://acl.readthedocs.io/en/latest/zhCN/ch2-cn.html][第二章：欢迎来到 Lisp — ANSI Common Lisp 中文版]]
    #+BEGIN_QUOTE
    progn 接受任意数量的表达式，依序求值，并返回最后一个表达式的值。
    #+END_QUOTE
*** lisp -dolist
    Source: [2017-02-14 二], [[http://acl.readthedocs.io/en/latest/zhCN/ch2-cn.html][第二章：欢迎来到 Lisp — ANSI Common Lisp 中文版]]
    #+BEGIN_QUOTE
    (defun our-length (lst)
    (let ((len 0))
    (dolist (obj lst)
    (setf len (+ len 1)))
    len))

    这里 dolist 接受这样形式的实参(variable expression)，跟着一个具有表达式的函数主体。函数主体会被求值，而变量相继与表达式所返回的列表元素绑定

**** dolist do tail-recursion default
     #+END_QUOTE
*** lisp -do
    Source: [2017-02-14 二], [[http://acl.readthedocs.io/en/latest/zhCN/ch2-cn.html][第二章：欢迎来到 Lisp — ANSI Common Lisp 中文版]]
    #+BEGIN_QUOTE
    do 宏是 Common Lisp 里最基本的迭代操作符。和 let 类似，do 可以创建变量，而第一个实参是一组变量的规格说明列表。每个元素可以是以下的形式

    (variable initial update)
    其中 variable 是一个符号，initial 和 update 是表达式。最初每个变量会被赋予 initial 表达式的值；每一次迭代时，会被赋予 update 表达式的值。在 show-squares 函数里，do 只创建了一个变量 i。第一次迭代时，i 被赋与 start 的值，在接下来的迭代里，i 的值每次增加 1。

    第二个传给 do 的实参可包含一个或多个表达式。第一个表达式用来测试迭代是否结束。在上面的例子中，测试表达式是 (> i end) 。接下来在列表中的表达式会依序被求值，直到迭代结束。而最后一个值会被当作 do 的返回值来返回。所以 show-squares 总是返回 done。

    do 的剩余参数组成了循环的函数体。在每次迭代时，函数体会依序被求值。在每次迭代过程里，变量被更新，检查终止测试条件，接着（若测试失败）求值函数体。
    #+END_QUOTE
*** lisp -remove
    Source: [2017-02-14 二], [[http://acl.readthedocs.io/en/latest/zhCN/ch2-cn.html][第二章：欢迎来到 Lisp — ANSI Common Lisp 中文版]]
    #+BEGIN_QUOTE
    要移除所有在列表 x 的 a，我们可以说：

    (setf x (remove 'a x))
    #+END_QUOTE
*** lisp -setf
    Source: [2017-02-14 二], [[http://acl.readthedocs.io/en/latest/zhCN/ch2-cn.html][第二章：欢迎来到 Lisp — ANSI Common Lisp 中文版]]
    #+BEGIN_QUOTE
    setf 的第一个实参几乎可以是任何引用到特定位置的表达式。所有这样的操作符在附录 D 中被标注为 “可设置的”（“settable”）。你可以给 setf 传入（偶数）个实参。一个这样的表达式

    (setf a 'b
    c 'd
    e 'f)

    传入 setf 的第一个实参，还可以是表达式或变量名。在这种情况下，第二个实参的值被插入至第一个实参所引用的位置：

    如果 setf 的第一个实参是符号（symbol），且符号不是某个局部变量的名字，则 setf 把这个符号设为全局变量
    #+END_QUOTE
*** lisp -boundp
    Source: [2017-02-14 二], [[http://acl.readthedocs.io/en/latest/zhCN/ch2-cn.html][第二章：欢迎来到 Lisp — ANSI Common Lisp 中文版]]
    #+BEGIN_QUOTE
    如果你想要检查某些符号，是否为一个全局变量或常量，使用 boundp 函数：

    > (boundp '*glob*)
    T
    #+END_QUOTE
*** lisp -let
    Source: [2017-02-14 二], [[http://acl.readthedocs.io/en/latest/zhCN/ch2-cn.html][第二章：欢迎来到 Lisp — ANSI Common Lisp 中文版]]
    #+BEGIN_QUOTE
    一个 let 表达式有两个部分。第一个部分是一组创建新变量的指令，指令的形式为 (variable expression) 。

    一组变量与数值之后，是一个有表达式的函数体，表达式依序被求值
    #+END_QUOTE
*** lisp -defconstant
    Source: [2017-02-14 二], [[http://acl.readthedocs.io/en/latest/zhCN/ch2-cn.html][第二章：欢迎来到 Lisp — ANSI Common Lisp 中文版]]
    #+BEGIN_QUOTE
    用 defconstant 来定义一个全局的常量：

    (defconstant limit (+ *glob* 1))
    #+END_QUOTE
*** lisp -defparameter
    Source: [2017-02-14 二], [[http://acl.readthedocs.io/en/latest/zhCN/ch2-cn.html][第二章：欢迎来到 Lisp — ANSI Common Lisp 中文版]]
    #+BEGIN_QUOTE
    给 defparameter 传入符号和值，来创建一个全局变量：

    > (defparameter *glob* 99)
    *GLOB*
    #+END_QUOTE
*** lisp -numberp
    Source: [2017-02-14 二], [[http://acl.readthedocs.io/en/latest/zhCN/ch2-cn.html][第二章：欢迎来到 Lisp — ANSI Common Lisp 中文版]]
    #+BEGIN_QUOTE
    numberp 是一个谓词，测试它的实参是否为数字
    #+END_QUOTE
*** lisp -format
    Source: [2017-02-14 二], [[http://acl.readthedocs.io/en/latest/zhCN/ch2-cn.html][第二章：欢迎来到 Lisp — ANSI Common Lisp 中文版]]
    #+BEGIN_QUOTE
    format 的第一个实参 t，表示输出被送到缺省的地方去。通常是顶层。第二个实参是一个用作输出模版的字符串。在这字符串里，每一个 ~A 表示了被填入的位置，而 ~% 表示一个换行。这些被填入的位置依序由后面的实参填入。

    (defun show-squares (start end)
    (do ((i start (+ i 1)))
    ((> i end) 'done)
    (format t "~A ~A~%" i (* i i))))
    列印从 start 到 end 之间的整数的平方：

    > (show-squares 2 5)
    2 4
    3 9
    4 16
    5 25
    DONE
    > (format t "~A plus ~A equals ~A. ~%" 2 3 (+ 2 3))
    2 plus 3 equals 5.
    NIL
    #+END_QUOTE
*** lisp -if
    Source: [2017-02-14 二], [[http://acl.readthedocs.io/en/latest/zhCN/ch2-cn.html][第二章：欢迎来到 Lisp — ANSI Common Lisp 中文版]]
    #+BEGIN_QUOTE
    与 quote 相同，if 是特殊的操作符。不能用函数来实现，因为实参在函数调用时永远会被求值，而 if 的特点是，只有最后两个实参的其中一个会被求值。if 的最后一个实参是选择性的。如果忽略它的话，缺省值是 nil
    #+END_QUOTE

    (defun ask-number ()
    (format t "Please enter a number. ")
    (let ((val (read)))
    (if (numberp val)
    val
    (ask-number))))
    注意这里, if 的 express 可以是函数.

    在 lisp 中, 函数 函数返回值 表达式 值(value), 异名同体.

    这里把 if 作为一个函数看待,后面三个都是 if 的实参. 实际上发现这非常的混乱,lisp 的表达似乎总是词不达意. 也似乎总是能出乎意料.

    这就是函数式编程,尤其是 lisp 这种用列表作为表达单元,带来的阵痛,混乱,因为在这里,原本其它函数发展处的分支概念,在这里需要回家了.

*** lisp -list
    Source: [2017-02-14 二], [[http://acl.readthedocs.io/en/latest/zhCN/ch2-cn.html][第二章：欢迎来到 Lisp — ANSI Common Lisp 中文版]]
    #+BEGIN_QUOTE
    你可以调用 list 来创建列表。由于 list 是函数，所以它的实参会被求值。这里我们看一个在函数 list 调用里面，调用 + 函数的例子：

    > (list 'my (+ 2 1) "Sons")
    (MY 3 "Sons")
    #+END_QUOTE
*** lisp -listp
    Source: [2017-02-14 二], [[http://acl.readthedocs.io/en/latest/zhCN/ch2-cn.html][第二章：欢迎来到 Lisp — ANSI Common Lisp 中文版]]
    #+BEGIN_QUOTE
    (listp '(a b c))
    T
    #+END_QUOTE
* ubuntu settings
** [[http://www.davidpai.tw/ubuntu/2011/ubuntu-set-locale/][{Ubuntu} 如何設定語系 locale | David's Blog]] :ubuntu settings:
   Source: [2017-02-14 二], [[http://www.davidpai.tw/ubuntu/2011/ubuntu-set-locale/][{Ubuntu} 如何設定語系 locale | David's Blog]]
   #+BEGIN_QUOTE
*** 關於語系

    所謂的語系(locale)，其實包含語言及地區的設定，因為除了語言之外，國家與國家的日期表示方式、數字格式、貨幣符號、度量單位可能都不一樣，所以才會有了這個 locale 的發明，依照國家和語言給予分類編號，再加上語言編碼，就構成了 locale。

    zh_TW 表示 繁體中文 台灣
    zh_CN 表示 簡體中文 中國
    en_US 表示 英文 美國
    然後再加上語言編碼
    zh_TW.UTF-8 表示 繁體中文 台灣 UTF-8 編碼
    zh_TW.Big5 表示 繁體中文 台灣 Big5 編碼
    zh_CN.UTF-8 表示 簡體中文 中國 UTF-8 編碼
    zh_CN.GB2312 表示 簡體中文 中國 GB2312 編碼
    en_US.UTF-8 代表 英文 美國 UTF-8 編碼
    …
    等等還有好多好多，Ubuntu 所有支援的語系和編碼，可以看這個檔案:
    /usr/share/i18n/SUPPORTED
    設定語系

*** 列出已安裝的語系

    首先要先看看我們自己的系統上安裝了哪些語系:
    $ locale -a
    C
    POSIX
    C 和 POSIX 是系統預設的，看來這台機器三比八，什麼都沒有裝…(囧)
    列出目前的語系設定

*** 再來看看我們現在的語系設定是怎樣:
    $ locale
    LANG=
    LC_CTYPE="POSIX"
    LC_NUMERIC="POSIX"
    LC_TIME="POSIX"
    LC_COLLATE="POSIX"
    LC_MONETARY="POSIX"
    LC_MESSAGES="POSIX"
    LC_PAPER="POSIX"
    LC_NAME="POSIX"
    LC_ADDRESS="POSIX"
    LC_TELEPHONE="POSIX"
    LC_MEASUREMENT="POSIX"
    LC_IDENTIFICATION="POSIX"
    LC_ALL=
    果然，全部也是預設的 POSIX…(囧)

    *那這裡面一堆 LC_xxx 的就是我們上面所說的，關於日期、度量單位、貨幣符號等等各種的設定，其實它就是我們系統的環境變數，可以用 export 指令來看*

    挑幾個重點來講:
    LC_CTYPE 這會影響字元的分類和轉換，若要能輸入中文，就是設定這裡
    LC_TIME 這就是日期和時間的顯示格式囉
    LC_MONETARY 這會影響貨幣單位的符號和表示
    LC_MESSAGES 這會影響系統訊息的顯示，若想要顯示中文，就是設定這裡
    LANG 這是預設，如果上面有沒設定的，就會用這裡的設定
    LC_ALL 這是強制全部使用這裡的設定，如果這裡設定了，那麼上面的都沒用，全部以這裡的為準
    基本上我們會全部都用同一個國家語系，但不表示全部就要設相同的，你可以日期設成中國、度量設成台灣、貨幣設成美國都 OK，隨你高興，只是…沒有人會這樣做吧= =”

*** 產生語系檔案

    要設定語系，必須先有語系檔案，我們可以用 locale-gen 這個指令來產生
    $ sudo locale-gen zh_TW zh_TW.UTF-8 zh_CN.UTF-8 en_US.UTF-8
    Generating locales...
    en_US.UTF-8... done
    zh_CN.UTF-8... done
    zh_TW.BIG5... done
    zh_TW.UTF-8... done
    Generation complete.
    這樣就產生了 4 種語系檔案，由於 Big5 是 zh_TW 的預設編碼，所以下指令時不需要寫成 zh_TW.Big5
    檔案就放在 /usr/lib/locale 目錄下，會產生與語系同名的目錄:
    $ ls -l /usr/lib/locale
    drwxr-xr-x 3 root root 4096 2011-10-15 17:27 en_US.utf8
    drwxr-xr-x 3 root root 4096 2011-10-15 17:27 zh_CN.utf8
    drwxr-xr-x 3 root root 4096 2011-10-15 17:18 zh_TW
    drwxr-xr-x 3 root root 4096 2011-10-15 17:18 zh_TW.utf8
    另外我們也可以在 /var/lib/locales/supported.d/ 底下建一個 local 檔，裡面寫上妳要產生的語系，格式與我們上面提到的 /usr/share/i18n/SUPPORTED 這個檔案裡面列出的相同，例如:
    $ sudo vim /var/lib/locales/supported.d/local
    zh_TW.UTF-8 UTF-8
    zh_CN.UTF-8 UTF-8
    en_US.UTF-8 UTF-8
    zh_TW BIG5
    一行一個語系，有了這個檔案，以後只要下 locale-gen 指令，不指定語系，它會自己去找這裡面寫的語系去產生檔案
    $ sudo locale-gen
    Generating locales...
    en_US.UTF-8... up-to-date
    zh_CN.UTF-8... up-to-date
    zh_TW.BIG5... up-to-date
    zh_TW.UTF-8... up-to-date
    Generation complete.

*** 更改語系設定

    若只是要暫時更改語系設定，直接下 export 指令更改環境變數即可
    先看一下日期格式:
    $ date
    Sat Oct 15 17:44:37 CST 2011
    然後設定，再看一下日期:
    $ export LC_TIME=zh_TW.UTF-8
    $ date
    六 10 月 15 17:50:58 CST 2011
    唷~ 變中文了耶，喔耶~~ 不過這種格式其實我不是很喜歡，所以下面我要把它改回英文…
    若只要變更自己帳號登入的語系設定，那麼編輯家目錄下的.bashrc 檔，在最後面加上，例如:
    *$ vim ~/.bashrc*
    ...(略)...
    export LC_CTYPE=zh_TW.UTF-8 # 可以輸入 UTF-8 中文
    export LC_MESSAGES=zh_TW.UTF-8 # 可以顯示 UTF-8 中文
    export LC_TIME=en_US.UTF-8 # 日期格式還是用美式的
    然後重新登入，噹噹~~就生效了
    若要變更的是系統全域設定，那麼就把設定寫在 /etc/default/locale 這個檔案裡
    *$ sudo vim /etc/default/locale*
    LC_CTYPE=zh_TW.UTF-8
    LC_MESSAGES=zh_TW.UTF-8
    LC_TIME=zh_TW.UTF-8
    或者加到環境變數的設定檔 /etc/environment 最後面
    *$ sudo vim /etc/environment*
    ....(略)...
    LC_CTYPE=zh_TW.UTF-8
    LC_MESSAGES=zh_TW.UTF-8
    LC_TIME=en_US.UTF-8
    相關檔案目錄
    /usr/share/i18n/SUPPORTED
    /usr/lib/locale/
    /var/lib/locales/supported.d/local
    ~/.bashrc
    /etc/default/locale
    /etc/environment
    相關指令
    local
    local-gen
    #+END_QUOTE
** wget 使用小結
   直接下載： =wget <http://xxxxx>=
   下載到指定文件： =wget -O - <http://xxxxx> > yyy.txt= ,注意在 =-O= 後面有個 =-=
* Funiture Installation
** cost of Installation in Nanjing and Xuzhou
   | Furniture                | Xu-cost | Nan-cost |
   |--------------------------+---------+----------|
   | Bed-1.8/1.5-HydraulicRoc |  50-100 |       80 |
   | Bed-1.8/1.5              |      50 |       50 |
   | Bureau *4doors           |     100 |      100 |
   | Bureau *3doors           |      90 |       90 |
   | Dressing table           |      50 |       50 |
   | Night table              |      15 |       15 |
   |--------------------------+---------+----------|
** TODO fangwu wenti [7/12]
   :LOGBOOK:
   it is so annoying to make this list of checkboxes, I refer =cua-mode= , =multiple-cursor-mode= , but both are not execute very well in
   evil edit-mode ,so i frequently swich emacs-mode and evil-mode by =C-z= .
   1. I copy all the text from onenote from the chrome;
   2. I get how to toggle the check-box between SOLVED and UNSOLVED, by =C-z= ;
   3. I add '[]' to the head of all lines by cua-mode in evil-mode, FAILED!
   4. I googled a mode which pre-installed in zilong'configurations--- =multiple-cursor-mode= ;
   5. it also sucks in evil-mode.
   6. I find the configuration and hotkey re-defined by zilong ,in =/.spacemacs.d/layers/zilongshanren-misc/packages.el=
      1. switch to *emacs-mode*
      2. =C-spc= to select several chars , then =C-s-f= to mark all the identical highlight
      3. =C-spc= again to cancel the highlight state, then you get MULTIPLE CURSOR
      4. now, its your fasion time!
   :END:
   1) [X] 进户门：[3/3]
      - [X] 门正面有划痕，左下角变形；
      - [X] 门锁侧立面变形、掉漆；
      - [X] 内门框有划痕；
   2) [X] 进户走廊：[2/2]
      - [X] 空调开关标识错，标到倒数第二个挂机标识上；
      - [X] 门口可视化对讲机底座松弛；
   3) [-] 厨房：[6/7]
      - [X] 所有插座未进漏电保护；
      - [ ] 厨房窗户明显歪斜；
      - [X] 厨房门关不上；窗把手太松；
      - [X] 门套下墙起皮，外右门套边缝隙较大，有划痕；
      - [X] 消毒柜两侧柜门摩擦柜体木板；消毒柜右边柜门右下铰链送了；
      - [X] 窗顶扣板不平，对缝不齐；
      - [X] 西墙砖勾缝不齐整；
   4) [X] 客厅：[1/1]
      - [X] 客厅空调柜机插座现为 10A 插座，应改为 16A 大插座；
   5) [ ] 阳台：[0/4]
      - [ ] 空调外机位地漏堵塞严重，下水很慢；
      - [ ] 阳台水池边地漏堵塞，下水很慢；
      - [ ] 墙面色差，顶面不平;   :2:
      - [ ] 外机位门有色差；
   6) [X] 卫生间：[6/6]
      - [X] 马桶插座火线零线接错；
      - [X] 毛巾架太松驰；
      - [X] 地漏内操有砂浆块，下水很慢；
      - [X] 马桶地漏较粗糙，上扣板不平；
      - [X] 干区洗漱台盆下墙砖未勾缝；镜柜下墙体粗糙未整平，未上漆；开关松动翘起；
      - [X] 卫生间推拉门门锁正反面有漏缝；门正面污渍明显；
   7) [ ] 浴室：[0/1]
      - [ ] 浴室玻璃门下部两侧漏水严重 :2:
   8) [X] 南次卧：[2/2]
      - [X] 门破损且关不上；保险关不上（槽片挡住导致）；
      - [X] 南地板破损，划痕；
   9) [X] 主卧：[2/2]
      - [X] 门关不上，门锁保险关不上（门框槽片挡住导致）；
      - [X] 过门石打胶粗糙；
   10) [X] 书房：[1/1]
       - [X] 门右下角破损；地板划痕严重；
   11) [ ] 所有墙体：[0/1]
       - [ ] 房屋内所有乳胶漆墙面出现多出裂痕（已经在墙上标明）；
   12) [ ] xiegui, dengguan wei guding

* Chome Clip Inbox
** 9.1.3 Capture templates
   Source: [2017-03-11 Sat], [[http://orgmode.org/manual/Capture-templates.html][Capture templates - The Org Manual]]
   #+BEGIN_QUOTE
   9.1.3 Capture templates

   You can use templates for different types of capture items, and for different
   target locations. The easiest way to create such templates is through the
   customize interface.

   C-c c C Customize the variable org-capture-templates. Before we give the formal
   description of template definitions, let's look at an example. Say you would
   like to use one template to create general TODO entries, and you want to put
   these entries under the heading ‘Tasks’ in your file ~/org/gtd.org. Also, a
   date tree in the file journal.org should capture journal entries. A possible
   configuration would look like:

   #+BEGIN_SRC emacs-lisp

      (setq org-capture-templates
       '(("t" "Todo" entry (file+headline "~/org/gtd.org" "Tasks")
              "* TODO %?\n  %i\n  %a")
         ("j" "Journal" entry (file+datetree "~/org/journal.org")
              "* %?\nEntered on %U\n  %i\n  %a")))
   #+END_SRC

   If you then press C-c c t, Org will prepare the template for you like this:

   * TODO
     [[file:link to where you initiated capture]]
   During expansion of the template, %a has been replaced by a link to the
   location from where you called the capture command. This can be extremely
   useful for deriving tasks from emails, for example. You fill in the task
   definition, press C-c C-c and Org returns you to the same place where you
   started the capture process.

   To define special keys to capture to a particular template without going
   through the interactive template selection, you can create your key binding
   like this:

   (define-key global-map "\C-cx"
   (lambda () (interactive) (org-capture nil "x")))
   #+END_QUOTE
*** Template elements
    Source: [2017-03-11 Sat], [[http://orgmode.org/manual/Template-elements.html#Template-elements][Template elements - The Org Manual]]
    #+BEGIN_QUOTE

Now lets look at the elements of a template definition. Each entry in org-capture-templates is a list with the following items:

keys
The keys that will select the template, as a string, characters only, for example "a" for a template to be selected with a single key, or "bt" for selection with two keys. When using several keys, keys using the same prefix key must be sequential in the list and preceded by a 2-element entry explaining the prefix key, for example
("b" "Templates for marking stuff to buy")
If you do not define a template for the C key, this key will be used to open the customize buffer for this complex variable.

description
A short string describing the template, which will be shown during selection.
| type       | The type of entry, a symbol. Valid values are:                                                                                                                    |
| entry      | An Org mode node, with a headline. Will be filed as the child of the target entry or as a top-level entry. The target file should be an Org mode file.            |
| item       | A plain list item, placed in the first plain list at the target location. Again the target file should be an Org file.                                            |
| checkitem  | A checkbox item. This only differs from the plain list item by the default template.                                                                              |
| table-line | a new line in the first table at the target location. Where exactly the line will be inserted depends on the properties :prepend and :table-line-pos (see below). |
| plain Text | to be inserted as it is.                                                                                                                                          |

target

Specification of where the captured item should be placed. In Org mode files,
targets usually define a node. Entries will become children of this node. Other
types will be added to the table or list in the body of this node. Most target
specifications contain a file name. If that file name is the empty string, it
defaults to org-default-notes-file. A file can also be given as a variable or as
a function called with no argument. When an absolute path is not specified for a
target, it is taken as relative to org-directory. Valid values are:

| (file "path/to/file")                                     | Text will be placed at the beginning or end of that file.                                                               |
| (id "id of existing org entry")                           | Filing as child of this entry, or in the body of the entry.                                                             |
| (file+headline "path/to/file" "node headline")            | Fast configuration if the target heading is unique in the file.                                                         |
| (file+olp "path/to/file" "Level 1 heading" "Level 2" ...) | For non-unique headings, the full path is safer.                                                                        |
| (file+regexp "path/to/file" "regexp to find location")    | Use a regular expression to position the cursor.                                                                        |
| (file+datetree "path/to/file")                            | Will create a heading in a date tree for today's date1.                                                                 |
| (file+datetree+prompt "path/to/file")                     | Will create a heading in a date tree, but will prompt for the date.                                                     |
| (file+weektree "path/to/file")                            | Will create a heading in a week tree for today's date. Week trees are sorted by week and not by month unlike datetrees. |
| (file+weektree+prompt "path/to/file")                     | Will create a heading in a week tree, but will prompt for the date.                                                     |
| (file+function "path/to/file" function-finding-location)  | A function to find the right location in the file.                                                                      |
| (clock)                                                   | File to the entry that is currently being clocked.                                                                      |
| (function function-finding-location)                      | Most general way: write your own function which both visits the file and moves point to the right location.             |

template
The template for creating the capture item. If you leave this empty,
an appropriate default template will be used. Otherwise this is a string with
escape codes, which will be replaced depending on time and context of the
capture call. The string with escapes may be loaded from a template file, using
the special syntax (file "path/to/template"). See below for more details.

properties The rest of the entry is a property list of additional options.
Recognized properties are:
| :prepend          | Normally new captured information will be appended at the target location (last child, last table line, last list item...). Setting this property will change that.                                                                                                                                        |
| :immediate-finish | When set, do not offer to edit the information, just file it away immediately. This makes sense if the template only needs information that can be added automatically.                                                                                                                                    |
| :empty-lines      | Set this to the number of lines to insert before and after the new item. Default 0, only common other value is 1.                                                                                                                                                                                          |
| :clock-in         | Start the clock in this item.                                                                                                                                                                                                                                                                              |
| :clock-keep       | Keep the clock running when filing the captured entry.                                                                                                                                                                                                                                                     |
| :clock-resume     | If starting the capture interrupted a clock, restart that clock when finished with the capture. Note that :clock-keep has precedence over :clock-resume. When setting both to t, the current clock will run and the previous one will not be resumed.                                                      |
| :unnarrowed       | Do not narrow the target buffer, simply show the full buffer. Default is to narrow it so that you only see the new material.                                                                                                                                                                               |
| :table-line-pos   | Specification of the location in the table where the new line should be inserted. It can be a string, a variable holding a string or a function returning a string. The string should look like "II-3" meaning that the new line should become the third line before the second horizontal separator line. |
| :kill-buffer      | If the target file was not yet visited when capture was invoked, kill the buffer again after capture is completed.                                                                                                                                                                                         |
    #+END_QUOTE

*** Template expansion                                 :org:capture:tempalte:

    In the template itself, special %-escapes1 allow dynamic insertion of content. The templates are expanded in the order given here:

    | %[file]     | Insert the contents of the file given by file.                                                           |         |             |                  |
    | %(sexp)     | Evaluate Elisp sexp and replace with the result.                                                         |         |             |                  |
    |             | For convenience, %:keyword (see below) placeholders                                                      |         |             |                  |
    |             | within the expression will be expanded prior to this.                                                    |         |             |                  |
    |             | The sexp must return a string.                                                                           |         |             |                  |
    | %<...>      | The result of format-time-string on the ... format specification.                                        |         |             |                  |
    | %t          | Timestamp, date only.會在 agenda 中記錄出來                                                                |         |             |                  |
    | %T          | Timestamp, with date and time.會在 agenda 中記錄出來                                                       |         |             |                  |
    | %u, %U      | Like the above, but inactive timestamps.不會在 agenda 中記錄出來                                           |         |             |                  |
    | %i          | Initial content, the region when capture is called while the                                             |         |             |                  |
    |             | region is active.                                                                                        |         |             |                  |
    |             | The entire text will be indented like %i itself.                                                         |         |             |                  |
    | %a          | Annotation, normally the link created with org-store-link.                                               |         |             |                  |
    | %A          | Like %a, but prompt for the description part.                                                            |         |             |                  |
    | %l          | Like %a, but only insert the literal link.                                                               |         |             |                  |
    | %c          | Current kill ring head.                                                                                  |         |             |                  |
    | %x          | Content of the X clipboard.                                                                              |         |             |                  |
    | %k          | Title of the currently clocked task.                                                                     |         |             |                  |
    | %K          | Link to the currently clocked task.                                                                      |         |             |                  |
    | %n          | User name (taken from user-full-name).                                                                   |         |             |                  |
    | %f          | File visited by current buffer when org-capture was called.                                              |         |             |                  |
    | %F          | Full path of the file or directory visited by current buffer.                                            |         |             |                  |
    | %:keyword   | Specific information for certain link types, see below.                                                  |         |             |                  |
    | %^g         | Prompt for tags, with completion on tags in target file.                                                 |         |             |                  |
    | %^G         | Prompt for tags, with completion all tags in all agenda files.                                           |         |             |                  |
    | %^t         | Like %t, but prompt for date.  Similarly %^T, %^u, %^U.                                                  |         |             |                  |
    |             | You may define a prompt like *%^{Birthday}t*.會在 agenda 中記錄出來，而且帶提示符                          |         |             |                  |
    | %^C         | Interactive selection of which kill or clip to use.                                                      |         |             |                  |
    | %^L         | Like %^C, but insert as link.                                                                            |         |             |                  |
    | %^{prop}p   | Prompt the user for a value for property prop.                                                           |         |             |                  |
    | %^{prompt}  | prompt the user for a string and replace this sequence with it.                                          |         |             |                  |
    |             | You may specify a default value and a completion table with                                              |         |             |                  |
    |             | %^{prompt                                                                                                | default | completion2 | completion3...}. |
    |             | The arrow keys access a prompt-specific history. minibuffer 中要求你輸入,輸入的內容會出現在這些符號的位置 |         |             |                  |
    | %\1 ... %\N | Insert the text entered at the Nth %^{prompt}, where N is                                                |         |             |                  |
    |             | a number, starting from 1.                                                                               |         |             |                  |
    | %?          | After completing the template, position cursor here.光標最後會回到的地方                                 |         |             |                  |

** come up with sth, get to do sth, manually                        :ENGLISH:
   Source: [2017-03-12 Sun], [[https://github.com/rejeep/prodigy.el][rejeep/prodigy.el: Manage external services from within Emacs]]
   #+BEGIN_QUOTE
   I *came up with* the idea when I *got to* work one Monday morning and before I
   could start working I had to *manually* start ten or so services.
   #+END_QUOTE

** get rid of sth, tedious                                          :ENGLISH:
   Source: [2017-03-12 Sun], [[https://github.com/rejeep/prodigy.el][rejeep/prodigy.el: Manage external services from within Emacs]]


   #+BEGIN_QUOTE
   *To get rid of* this *tedious* work, I started working on this Emacs plugin, which provides a nice and simple GUI to manage services.
   #+END_QUOTE

** how to get the place some lib installed      :ubuntu:lib:ldconfig:command:
   Source: [2017-03-12 Sun], [[http://www.linuxquestions.org/questions/linux-software-2/installing-emacs-24-4-1-with-libxml2-4175535781/][{SOLVED} Installing Emacs 24.4.1 with libxml2]]

   #+BEGIN_QUOTE
   Code:
   ldconfig -p | grep libxml2
   outputs:
   Code:
   libxml2.so.2 (libc6,x86-64) => /usr/lib/x86_64-linux-gnu/libxml2.so.2
   libxml2.so.2 (libc6) => /usr/lib/i386-linux-gnu/libxml2.so.2
   #+END_QUOTE

** 大神改進 elfeed 的顏色顯示,並增加打分功能        :emacs:elfeed:hack:kitchin:
   Source: [2017-03-12 Sun], [[http://kitchingroup.cheme.cmu.edu/blog/category/emacs/][The Kitchin Research Group: emacs]]

   I get a lot of articles this way. The current size of the database is:

   (elfeed-db-size)
   79721
   Elfeed tells me I have over 300 unread entries to review at the moment.

   (elfeed-search--count-unread)
   341/363:24

   To deal with this deluge, I have done a couple of things. I set up some new
   key-bindings so I can alternate marking entries as read if the titles do not
   look interesting. These keybindings let me alternate fingers, so they do not
   get too tired (that really happens some days!).

   ;; help me alternate fingers in marking entries as read
   (define-key elfeed-search-mode-map (kbd "f") 'elfeed-search-untag-all-unread)
   (define-key elfeed-search-mode-map (kbd "j") 'elfeed-search-untag-all-unread)

   I also set up some auto-tagging of the emacs and python feeds, and setup some
   custom faces so these tags are highlighted so they are easy to see. Anything
   highlighted in blue is related to emacs, green is related to python, and pink
   is related to my department, and I can type s, then the tag to see only those
   entries. Here is what my feed looks like:



   Today I want to explore adding tags to entries to further prioritize them.
   There is a way to tag entries that is described here: [fn:1]
   https://github.com/skeeto/elfeed#tag-hooks where you can create patterns to
   match an entry feed title, url, title or link. Basically, you create a function
   that takes an entry, amd have it add or remove a tag conditionally.

   I want to tag entries that meet certain criteria, for example keywords, and set
   a tag based on the number of matches. Ideally, one day this would be integrated
   with machine learning so it could rank entries by other entries I have liked,
   but today we setup code that will create a score for an entry based on the
   number of matches, and then tag it so that it will get highlighted for me.
   First, we define two custom faces and setup elfeed to use them. I will use two
   tags: important and relevant. relevant will be for entries that get a score of
   at least 1, and important for entries that get a score greater than 1.

   #+BEGIN_SRC emacs-lisp

  (defface relevant-elfeed-entry
    `((t :background ,(color-lighten-name "orange1" 40)))
    "Marks a relevant Elfeed entry.")

  (defface important-elfeed-entry
    `((t :background ,(color-lighten-name "OrangeRed2" 40)))
    "Marks an important Elfeed entry.")

  (push '(relevant relevant-elfeed-entry)
        elfeed-search-face-alist)

  (push '(important important-elfeed-entry)
        elfeed-search-face-alist)
        ;; In elfeed, each entry is a structure, and we can access the title and
        ;; content for matching. Here is an example of a simple scoring function.
        ;; The idea is just to match patterns, and then add to the score if it
        ;; matches. This is not as advanced as gnus scoring, but it is a good
        ;; starting point.

  (defun score-elfeed-entry (entry)
    (let ((title (elfeed-entry-title entry))
          (content (elfeed-deref (elfeed-entry-content entry)))
          (score 0))
      (loop for (pattern n) in '(("alloy" 1)
                                 ("machine learning\\|neural" 1)
                                 ("database" 1)
                                 ("reproducible" 1)
                                 ("carbon dioxide\\|CO2" 1)
                                 ("oxygen evolution\\|OER\\|electrolysis" 1)
                                 ("perovskite\\|polymorph\\|epitax" 1)
                                 ("kitchin" 2))
            if (string-match pattern title)
            do (incf score n)
            if (string-match pattern content)
            do (incf score n))
      (message "%s - %s" title score)

      ;; store score for later in case I ever integrate machine learning
      (setf (elfeed-meta entry :my/score) score)

      (cond
       ((= score 1)
        (elfeed-tag entry 'relevant))
       ((> score 1)
        (elfeed-tag entry 'important)))
      entry))

  (add-hook 'elfeed-new-entry-hook 'score-elfeed-entry)

   #+END_SRC
   score-elfeed-entry

   Now, new entries automatically get tagged with relevant or important, depending
   on the score that function gives them, and they get color-coded. Now, the feed
   looks like this:



   I saved some bookmarks to see just the important or relevant ones
   (http://nullprogram.com/blog/2015/12/03/) so I can see new relevant entries
   with C-x r b and selecting the relevant bookmark. These work from anywhere in
   Emacs.

   @6-months-ago +unread +relev  @6-months-ago +unread +relevant
   elfeed @6-months-ago +unread  @6-months-ago +unread +important

   I usually access elfeed from a command that shows me everything. Here, I
   define key-bindings to show me just the important or relevant ones. I could
   not see a way to get an or in there to show me both of them. These keys make
   it a one key press to show only these entries, and then get back to the full
   list.

   #+BEGIN_SRC emacs-lisp
 (define-key elfeed-search-mode-map (kbd "i")
   (lambda () (interactive)
     (elfeed-search-set-filter "@6-months-ago +unread +important")))

 (define-key elfeed-search-mode-map (kbd "v")
   (lambda () (interactive)
     (elfeed-search-set-filter "@6-months-ago +unread +relevant")))

 (define-key elfeed-search-mode-map (kbd "c")
   (lambda () (interactive)
     (elfeed-search-set-filter "@6-months-ago +unread")))
   #+END_SRC

   That summarizes the experiment of the day. There is clearly some room for
   improvement on the scoring function, e.g. moving the patterns out of the
   function and into a customizable variable, making the patterns be specific to
   either the title or content, etc. I am going to try this for a few days and see
   if it is actually helpful first though.

** stuck-project, 在做 project review 時 快速找到卡住的 project :emacs:org:func:
   Source: [2017-03-13 Mon], [[http://orgmode.org/manual/Stuck-projects.html][Stuck projects - The Org Manual]]


   #+BEGIN_QUOTE
   You almost certainly will have to configure this view before it will work for
   you. The built-in default assumes that all your projects are level-2 headlines,
   and that a project is not stuck if it has at least one entry marked with a TODO
   keyword TODO or NEXT or NEXTACTION.

   Let's assume that you, in your own way of using Org mode, identify projects
   with a tag PROJECT, and that you use a TODO keyword MAYBE to indicate a project
   that should not be considered yet. Let's further assume that the TODO keyword
   DONE marks finished projects, and that NEXT and TODO indicate next actions. The
   tag @SHOP indicates shopping and is a next action even without the NEXT tag.
   Finally, if the project contains the special word IGNORE anywhere, it should
   not be listed either. In this case you would start by identifying eligible
   projects with a tags/todo match1 ~+PROJECT/-MAYBE-DONE~, and then check for
   TODO, NEXT, @SHOP, and IGNORE in the subtree to identify projects that are not
   stuck. The correct customization for this is

   總之,這個函數就是用來判別那些 project 處在"非終結態".

   (setq org-stuck-projects
   '("+PROJECT/-MAYBE-DONE" ("NEXT" "TODO") ("@SHOP")
   "\\<IGNORE\\>"))

   Documentation:
   This is a list of four items:

   | "+PROJECT/-MAYBE-DONE" | A tags/todo/property matcher string that is used to identify a project.     |
   |                        | See the manual for a description of tag and property searches.              |
   |                        | The entire tree below a headline matched by this is considered one project. |
   |------------------------+-----------------------------------------------------------------------------|
   | ("NEXT" "TODO")        | A list of TODO keywords identifying non-stuck projects.                     |
   |                        | If the project subtree contains any headline with one of these todo         |
   |                        | keywords, the project is considered to be not stuck.  If you specify        |
   |                        | "*" as a keyword, any TODO keyword will mark the project unstuck.           |
   |------------------------+-----------------------------------------------------------------------------|
   | ("@SHOP")              | A list of tags identifying non-stuck projects.                              |
   |                        | If the project subtree contains any headline with one of these tags,        |
   |                        | the project is considered to be not stuck.  If you specify "*" as           |
   |                        | a tag, any tag will mark the project unstuck.  Note that this is about      |
   |                        | the explicit presence of a tag somewhere in the subtree, inherited          |
   |                        | tags do not count here.  If inherited tags make a project not stuck,        |
   |                        | use "-TAG" in the tags part of the matcher under (1.) above.                |
   |------------------------+-----------------------------------------------------------------------------|
   | "\\<IGNORE\\>"         | An arbitrary regular expression matching non-stuck projects.                |

   Note that if a project is identified as non-stuck, the subtree of this entry
   will still be searched for stuck projects.


   #+END_QUOTE

** 如何定義 org todo keyword 顏色                             :org:todo:face:
   Source: [2017-03-13 Mon], [[http://orgmode.org/manual/Faces-for-TODO-keywords.html][Faces for TODO keywords - The Org Manual]]


   5.2.6 Faces for TODO keywords

   Org mode highlights TODO keywords with special faces: org-todo for keywords
   indicating that an item still has to be acted upon, and org-done for keywords
   indicating that an item is finished. If you are using more than 2 different
   states, you might want to use special faces for some of them. This can be done
   using the option *org-todo-keyword-faces*. For example:

   #+BEGIN_SRC emacs-lisp
      (setq org-todo-keyword-faces
            '(("TODO" . org-warning) ("STARTED" . "yellow")
              ("CANCELED" . (:foreground "blue" :weight bold))))
   #+END_SRC

   While using a list with face properties as shown for CANCELED should work, this
   does not always seem to be the case. If necessary, define a special face and use
   that. A string is interpreted as a color. The option org-faces-easy-properties
   determines if that color is interpreted as a foreground or a background color.

** make a mental note of sth                                        :ENGLISH:
   Source: [2017-03-13 Mon], [[http://doc.norang.ca/org-mode.html#ReminderSetup][Org Mode - Organize Your Life In Plain Text!]]


   #+BEGIN_QUOTE
   *make a mental note of* anything important to deal with today
   #+END_QUOTE

** MESSY counsel-locate
   Source: [2017-03-14 Tue], [[https://oremacs.com/2015/07/02/counsel-locate/][Power up your locate command · (or emacs]]

*** counsel-locate and hydra

    I'm sure many people know that Emacs comes with a locate command. This command,
    if you're on a Linux system, will find all files on your system that match a
    particular pattern.

    The advantage of locate over find when searching the *whole system*, is that it
    is much faster, since it uses a *pre-computed database*.

    This database is updated periodically, you can force an update with:

    ~sudo updatedb~

    Of course find is faster if you need to search only a specific directory
    instead of the whole system, but sometimes you just don't know that directory.

*** counsel-locate
****  Dynamic
     The way locate works it that it asks you for a query, which is glob-based
     instead of regex-based, and then prints the results to a static buffer.

     On the other hand, counsel-locate is dynamic: each time you input a new
     character a new locate query is ran, and the old one is terminated. On my
     system, it takes around 2 seconds for a query to complete, so it requires a bit
     of patience.

**** Regex-based
     I like regex way more than globs for some reason. Here's the command called for
     the input mp3$:

     ~locate -i --regex mp3$~

     Of course, the standard ivy-mode method is used to build the regex from a list
     of space separated words. So the input fleet mp3$ will result in:

     ~locate -i --regex \\(fleet\\).*?\\(mp3$\\)~

     You could go your own way and update the regex matcher to be ivy--regex-fuzzy, which results in:

     ~locate -i --regex f.*l.*e.*e.*t.* .*m.*p.*3$~

     But I think less matches is usually better than more matches.

**** Multi-exit with hydra
     This is just the _coolest feature_. Basically, for each file you locate, you can easily:

     Open it in Emacs (default).
     Open it with xdg-open, so that PDF files are forwarded to evince and MP3 files are forwarded to rhythmbox etc.

     Open it in dired.
     Here's an example of how to do it. _First I call counsel-locate_, which I like to
     bind to C-x l. Then I enter emacs ~pdf$~ and wait around 2 seconds for the 248
     results to come up. Then I scroll to the 18th result and press ~C-o~ to open up
     the hydra-based option panel.

** MESSY 看別人使用 yasnippet 的思想和思路         :emacs:completion:yasnippet:
   Source: [2017-03-14 Tue], [[http://sachachua.com/blog/2015/01/thinking-make-better-use-yasnippet-emacs-workflow/?shareadraft=baba27681_54adb5a67d3ed][Thinking about how to make better use of Yasnippet in my Emacs workflow –]]


   #+BEGIN_QUOTE
   I’d like to use YASnippet more. Where can I integrate it into my workflow?
   Probably wherever checklists and templates make sense. I’ve been thinking
   about checklists and templates as a way to improve how I do things.

   *Checklists* are good for making sure that you complete tasks more consistently,
   not missing any important steps. You can work faster when there’s a guide,
   since you don’t have to keep thinking of the next step each time. The simple
   act of checking things off can encourage you to put in more effort, since the
   list shows you your progress. It also makes it easier to remember to follow up.

   *Templates* help you improve the structure of your work. You can make sure you
   cover all the important parts. If you use similar structures for many things,
   then people get used to finding information in the same logical places. This
   doesn’t mean that you’re stuck with cookie-cutter formats. You can still
   adapt the format to your needs.

   I’m particularly interested in using checklists and templates to improve in
   three areas:

   Programming: I’d like to write with less friction and use best practices like
   testing Helping the Emacs community: Checklists can help me make sure I do all
   the steps to prepare for and make the most of Emacs Hangouts and Emacs Chats.
   They might also lower the intimidation factor so that I end up scheduling these
   more often. Writing: I think checklists and templates will help me invest more
   time into developing thoughts, relationships, and structure.
   #+END_QUOTE

** MESSY                                                            :ENGLISH:
   Source: [2017-03-14 Tue], [[http://ergoemacs.org/emacs/emacs_tip_yasnippet_expand_whole_hyphenated_word.html][Emacs YASnippet Tip: Expand Whole hyphenated-word as Input]]


   #+BEGIN_QUOTE
   hyphen 連字符
   #+END_QUOTE

** MESSY self-expannatory                                           :ENGLISH:
   Source: [2017-03-14 Tue], [[http://joostkremers.github.io/pandoc-mode/][Pandoc-mode by joostkremers]]


   After that, everything should be self-explanatory

* MESSY QuickNotes

** spacemacs 如何定義快捷鍵                                            :elisp:
   我理解,應該是把某個按鍵掛在某個 major-mode 下,啓用方式爲:
   =<major-mode-key> <你定義的按鍵>=
   eg. 這裏的, =, p=
   #+BEGIN_SRC emacs-lisp
      (spacemacs/set-leader-keys-for-major-mode 'org-mode
        "p" 'org-pomodoro)
      (spacemacs/set-leader-keys-for-major-mode 'org-agenda-mode
        "p" 'org-pomodoro))))

   #+END_SRC
   Link:   [[file:~/.emacs.d/layers/+emacs/org/packages.el::"p"%20'org-pomodoro))))]]
   File:   /home/yiddi/.emacs.d/layers/+emacs/org/packages.el
** Embedding Youtube videos with org-mode links
   The Power of Org-links post series

   Use Org-Mode Links for Anything
   Embedding Youtube videos with org-mode links
   Markdown style link IDs in org-mode

   If you’re a frequent reader, no doubt you noticed an embedded Youtube video on
   a post a couple of weeks ago. Youtube makes it pretty simple to embed videos,
   they give you the entire iframe HTML code to use, but this wouldn’t really be
   Emacs if we couldn’t make things just a little bit easier. Just add the snippet
   below to your init file, and you’re good to go.

   #+BEGIN_SRC emacs-lisp

 (defvar yt-iframe-format
   ;; You may want to change your width and height.
   (concat "<iframe width=\"440\""
           " height=\"335\""
           " src=\"https://www.youtube.com/embed/%s\""
           " frameborder=\"0\""
           " allowfullscreen>%s</iframe>"))

 (org-add-link-type
  "yt"
  (lambda (handle)
    (browse-url
     (concat "https://www.youtube.com/embed/"
             handle)))
  (lambda (path desc backend)
    (cl-case backend
      (html (format yt-iframe-format
                    path (or desc "")))
      (latex (format "\href{%s}{%s}"
                     path (or desc "video"))))))

   #+END_SRC

   To use this, just write your org links in the following way (optionally adding a
   description).

   [[yt:A3JAlWM8qRM]]

   When you export to HTML, this will produce that same inlined snippet that
   Youtube specifies. The advantage (over simply writing out the iframe) is that
   this link can be clicked in org-mode, and can be exported to other formats as
   well.
** Use org-mode links for anything
   強大到可怕的 org-mode link 功能。
   我的個天！

   One little-know feature of org-mode is that you can define new types of links
   with the aptly named ~org-add-link-type~. The applications of this virtue are
   many. One might, for instance, write links which search an entire code base for
   an expression.

   *先運行下面的代碼，再點擊 headling 的鏈接*
   運行過上面的代碼之後，點擊下面的鏈接，會彈出所有被找到的文件列表，通過他們可以直接跳轉。
*** refactor [[grep:.pdf][pdf file]] into another place
    CLOSED: [2017-03-13 Mon 08:33]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2017-03-13 Mon 08:33]
    :END:
    #+BEGIN_SRC emacs-lisp

    (org-add-link-type
  "grep" 'endless/follow-grep-link)

 (defun endless/follow-grep-link (regexp)
   "Run `rgrep' with REGEXP as argument."
   (grep-compute-defaults)
   (rgrep regexp "*" (expand-file-name "./")))

    #+END_SRC


*** find all org headline with [[tag:ubuntu][ubuntu]] tag

    #+BEGIN_SRC emacs-lisp
 (org-add-link-type
  "tag" 'endless/follow-tag-link)
 (defun endless/follow-tag-link (tag)
   "Display a list of TODO headlines with tag TAG.
 With prefix argument, also display headlines without a TODO keyword."
   (org-tags-view (null current-prefix-arg) tag))
    #+END_SRC


    Then, merely write your links as

    The syntax allowed, described here, is the same used for the org-tags-view command.
** org-store-link can store the precise location of a file in it :PRIVAT:ARBEIT:
   and in another place you can insert this link by =org-insert-link=
   which have precise loaction info, where you called =org-store-link=
   [2017-03-11 Sat 20:16]

** 激活態和非激活態的時間戳                              :org:timestamp:todo:
   | active   | time wrapped by =<>= | will display in agenda-view |
   |----------+----------------------+-----------------------------|
   | inactive | time wrapped by =[]= | DONT display in agenda-view |


   [2017-03-11 Sat 22:09]

** representing my system                                           :org:gtd:
   work ------------------ home ----------------  finacial
   work.org                private.org            ths.org
   schedule.org
   |                          |                       |
   |                          |                       |
   w                          p                       v
   |                                      f
   |                                      |
   plan-work.org                       plan-free.org


   private.org -> plan-free.org -> review -> archives
   logbook     -> journal       -> review -> archives

   作者在這裏，用了一個 plan-free.org 去記錄了每一天做的事情。用 checkbox
   #+BEGIN_SRC org
 * 2016
 ** 2016-01 January
 *** 2016-01-01 Mon [/]
     - [ ] xxx(is a link to the org branch node)
     - [ ] yyy(is a link to the org branch node)
     - [ ] zzz(is a link to the org branch node)

   #+END_SRC

   最好對每一個 org 文件使用定制化的 PROPERTY：#+,來根據自己的需要定制。

   About TAGS
   比如 自己的知識收集，就要定制一些 tags： #+TAGS: LEARN(l) QUESTION(q)
   用 ARCHIVE(a)標記可以存檔的知識

   About ARCHIVE file
   定義 #+ARCHIVE： 指定存檔文件
   [2017-03-12 Sun 11:05]

** 有兩種方法你可以對 spacemacs 內置 layer 的某個包進行定制化設定 :spacemacs:zilong:
   方法 1: [[file:~/.spacemacs.d/init.el::(elfeed%20:variables][configuration-layers 中進行變量配置]]
   方法 2: [[file:~/.spacemacs.d/init.el::prodigy][在 configuration-layers 中僅生命 layer 名字]] , [[file:~/.spacemacs.d/layers/zilongshanren-misc/packages.el::prodigy][重新在自定義的 layer 的 packages 中聲明]] ,[[file:~/.spacemacs.d/layers/zilongshanren-misc/packages.el::(defun%20zilongshanren-misc/post-init-prodigy%20()][並且在這裏進行具體配置]]
   [2017-03-12 Sun 15:25]

** 學習了 prodigy 是個什麼東西,以及最基本的配置       :emacs:package:prodigy:
   簡單說,prodigy 就是 一個從 emacs 來開啓外部機器 service 的東西.
   作者是每天都要 mannually 開啓十幾個服務,所以寫了這麼個東西,
   記錄的原因是,希望以後可以參考其源代碼,做一些自己的<依靠 emacs 控制 linux>的想法
*** 基本用法
    在 [[file:~/.spacemacs.d/layers/zilongshanren-misc/packages.el::;;%20yiddi:add%20to%20test%20how%20prodigy%20works-----][zilongshanren misc]] 配置
    #+BEGIN_SRC emacs-lisp
    (prodigy-define-service
      :name "yiddi test"
      :command "pip"
      :args '("list" "--format=columns")
      :cwd "~/"
      :tags '(yiddi)
      :kill-signal 'sigkill
      :kill-process-buffer-on-stop t)
    #+END_SRC
    他大概的樣子:
    Debug Fireball                                      work
    Hexo Deploy                                         hexo, deploy
    Hexo Server                                         hexo, server
    Org wiki preview                                    org-mode
    Preview cocos2d-x web                               work
    Preview creator engine                              work
    yiddi test                          Failed          yiddi
    在每一條目前面, 按 ~$~ 可以查看其執行的信息

    [2017-03-12 Sun 16:07]

** 要學會考慮編程的核心問題:                          :programming:viewpoint:
   1. 信息傳遞
   2. 信息格式轉化

      信息 ->編碼-> -------------------------------傳遞--------------------------> ->解碼-> 信息

   [2017-03-13 Mon 08:35]

* MESSY Footnotes

[fn:1] 從這裏可以看出,作者也是通過讀 git 來獲取最進本的函數信息.之前迷惑,他怎麼知道用哪些函數呢? 如何可查?
* 2017
** 2017-03 March
*** 2017-03-14 Tuesday


**** MESSY org-capture.el 閱讀筆記 (學習如何把對應的代碼類型都放在一個 node 下)
     0. 首先 org-capture 維護着一個 capture properties 的列表,包括
        :exact-position
        :initial-target-region
        :initial-target-position
        他們都可以通過 (org-capture-put :exact-position <value>) 來設置
        or 通過 (org-capture-get :exact-position) 來獲取

     1. 所有的從 capture-template 獲得的 target(存儲筆記位置) 一開始都是一個 list:'target' (eg. 'file+headline' "~/documents/org-notes/journal.org" "ChromeInbox")
     2. (car target) 就是前面的聲明: 'file+headline' or 'file+datetree' 用來表明類型,也表明了後面元素的處理方式(值得學習)
     3. (nth 1 target) 就是存儲的目的文件全路徑
     4. (nth 2 target) 就是文件某個 headline 的名稱
     5. 下面的代碼是處理 headline 名字匹配的: 找到則 goto-char point-at-bol,否則到最後新建
     #+BEGIN_SRC emacs-lisp
	(let ((hd (nth 2 target)))
	  (goto-char (point-min))
	  (if (re-search-forward
	       (format org-complex-heading-regexp-format (regexp-quote hd))
	       nil t)
	      (goto-char (point-at-bol))
	    (goto-char (point-max))
	    (or (bolp) (insert "\n"))
	    (insert "* " hd "\n")
	    (beginning-of-line 0))))
     #+END_SRC

     解釋下 funcall 的用法
     #+BEGIN_QUOTE
     (funcall FUNCTION &rest ARGUMENTS)

     *Call first argument as a function*,
     *passing remaining as arguments to it*.
     *Return the value that function returns.*

     Thus, (funcall 'cons 'x 'y) returns (x . y).
     #+END_QUOTE
     函數: [[file:~/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el::(defun%20org-capture-set-target-location%20(&optional%20target)][(defun org-capture-set-target-location (target))]]
     有用的位置: [[file:~/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el::((eq%20(car%20target)%20'file+headline)]]

     [2017-03-14 Tue 13:00]

**** MESSY 找到存出 buffer 的 property 了

     org-capture 首先填充一些列的 property.
     然後才會去根據 property 的內容,做一些處理工作,比如找目標文件和插入位置(point).
     我的想法是先了解這麼多 property 中是否有一些存儲了 插入的內容.
     而後我從插入內容中匹配一個 language: xxx 內容,獲取 xxx, 如果存在這個 node,就填到其下.
     如果不存在則新建之.

     一開始我以爲應該是這個 template, 但似乎錯了
     [[file:~/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el::(defun%20org-capture-get-template%20()]]

     後來根據這個函數:
     [[file:~/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el::(defun%20org-capture-goto-target%20(&optional%20template-key)]]
     發現了蛛絲馬跡, 通過(org-capture-set-target-location) 找到插入位置之後,就應該通過
     (pop-to-buffer-same-window <內容>)來插入具體內容了: (org-capture-get :buffer) 終於找到
     [2017-03-14 Tue 14:11]

**** MESSY 這些是 org-capture 在 finalize 之前會填好的 PROPERTIES
     org-capture-plist is a variable defined in ‘org-capture.el’.
     Its value is
     (
     :empty-lines 1
     :key "e"
     :description "知識收集: Journal by emacs"
     :target       (file+datetree org-agenda-file-journal)
     :template "* MESSY %?\n  \n [2017-03-14 Tue 14:11]\n"
     :type entry
     :original-buffer #<buffer org-capture.el>
     :original-file "/home/yiddi/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el"
     :original-file-nondirectory "org-capture.el"
     :annotation "[[file:~/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el::(defun%20org-capture-get-template%20()]]"
     :initial nil
     :return-to-wconf #<window-configuration>
     :default-time (22727 35241 541803 447000)
     :initial-target-region nil
     :initial-target-position 113771
     :buffer #<buffer journal.org>
     :pos 143831
     :target-entry-p t
     :decrypted nil
     :position-for-last-stored #<marker in no buffer>
     :begin-marker #<marker in no buffer>
     :end-marker #<marker in no buffer>
     :captured-entry-size 657
     :insertion-point 145771
     )


     Documentation:
     Plist for the current capture process, global, to avoid having to pass it.


     [2017-03-14 Tue 14:23]

**** MESSY 簡單記錄 hack orgcapture 的過程
     1. 我需要一個能把我輸入的某種語言的代碼放置到對應 headline 位置的 capture-tempalte
     2. 通過閱讀 org doc 發現有一個 file+function 的 template 可用
     3. 但具體 function 返回什麼東西?我不知道
     4. 於是我通過 spc h R 找到遠嗎位置, spc s p 搜索 orgcapture tempalte 等關鍵字, 找到了源代碼函數位置
     5. 然後變閱讀,邊通過 shift-k 搜索函數或變量的 doc.找出內部通信原理和執行順序.
     6. 最後找到自己的方法.

        [2017-03-14 Tue 14:32]

**** MESSY 或許我最後就是躲在寺廟裏讀書的和尚吧
     紅塵繁復無處躲,古剎小徑怎無葉.

     [2017-03-14 Tue 14:52]

**** MESSY 這個函數很重要,對於執行 capture
     當我們在 capture buffer 中按下 c-c c-c 時:
     1. 調用 這個函數(org-capture-finalize)
     2. 這函數 執行
        1) prepare finalize hook
        2) some procedure
        3) before finalize hook
        4) some procedure
        5) after finalize hook

     (defun org-capture-finalize (&optional stay-with-capture)

     Link:  [[file:~/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el::(defun%20org-capture-finalize%20(&optional%20stay-with-capture)]]
     File:   /home/yiddi/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el

**** MESSY 這裏就是爲什麼可以在 capture buffer 中獲得 base buffer 鏈接的原因
     就像這個 capture 所展示的這樣
     (defun org-capture-finalize (&optional stay-with-capture)

     Link:  [[file:~/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el::(org-capture-store-last-position)%0A]]
     File:   /home/yiddi/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el

**** MESSY  這裏是進入 before finalize 之後
     要明白 這幾個 buffer 分別是什麼?

     1. base-buffer 就是 我在誰那 調用的 capture.
     2. indrect-buffer 就是 除了 base-buffer 之外的 buffer.
     3. capture-buffer 就是選擇了模板(template)之後,新建的一個將要寫點什麼的 buffer.

     org capture 的表現就是:畫面上 indirect-buffer 會暫時消失,呈現在眼前的是 base-buffer 和光標所在的 capture-buffer

     ;; Kill the indirect buffer
     (save-buffer)
     (let ((return-wconf (org-capture-get :return-to-wconf 'local))
     (new-buffer (org-capture-get :new-buffer 'local))
     (kill-buffer (org-capture-get :kill-buffer 'local))
     (base-buffer (buffer-base-buffer (current-buffer))))

     Link:  [[file:~/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el::(base-buffer%20(buffer-base-buffer%20(current-buffer))))]]
     File:   /home/yiddi/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el

**** MESSY [好像是的]這裏可以看出 target-buffer 在選擇模板之後就已經確定了

     這裏的注釋沒看懂, 是把目標文件重新 narrow 回去?
     ;; Narrow back the target buffer to its previous state
     (with-current-buffer (org-capture-get :buffer)
     (let ((reg (org-capture-get :initial-target-region))
     (pos (org-capture-get :initial-target-position))
     (ipt (org-capture-get :insertion-point))
     (size (org-capture-get :captured-entry-size)))
     (if (not reg)
     (widen)

     Link:  [[file:~/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el::(widen)]]
     File:   /home/yiddi/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el
*** 2017-03-15 Wednesday
**** MESSY 設置"某些 capture 模板只在特定 major-mode 下可見"
     9.1.3.3 Templates in contexts
     .............................

     To control whether a capture template should be accessible from a
     specific context, you can customize `org-capture-templates-contexts'.
     Let's say for example that you have a capture template `"p"' for
     storing Gnus emails containing patches.  Then you would configure this
     option like this:

     (setq org-capture-templates-contexts
     '(("p" (in-mode . "message-mode"))))

     You can also tell that the command key `"p"' should refer to another
     template.  In that case, add this command key like this:

     (setq org-capture-templates-contexts
     '(("p" "q" (in-mode . "message-mode"))))

     See the docstring of the variable for more information.

     Link:  [[info:org#Templates%20in%20contexts][info:org#Templates in contexts]]
     File:

**** MESSY 兩個屬性列表 PROPERTY LIST,一個全局的一個 local 的.
     在這裏注明,就說名是從 local 取屬性值.
     這是爲了同時打開多個 capture 時使用,每一個 capture 維護自己的屬性列表
     (or (org-capture-get :empty-lines-after 'local)
     (org-capture-get :empty-lines 'local) 0))))

     Link:  [[file:~/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el::(org-capture-get%20:empty-lines%20'local)%200))))]]
     File:   /home/yiddi/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el

**** MESSY 這句是 spc f s 就是保存當前 buffer 的內容
     (save-buffer)

     Link:  [[file:~/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el::(save-buffer)]]
     File:   /home/yiddi/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el

**** MESSY 似乎之前對三個 buffer 的理解有問題
     下面的 a 代碼截取自 org-capture-finalize 意思就是按下 c-c c-c 時候調用的.
     按下的那一刻,就執行了這麼多步驟, 包括三個 hook: prepare,before,after.
     這個 indirect-buffer 好像應該是 capture-buffer.就是我們在理面做筆記的,按下 cccc 就消失的那個 buffer

     ;; Kill the indirect buffer
     (save-buffer) ; 很明顯在這裏, 殺掉這個 buffer 之前是先保存了這個 buffer
     (let ((return-wconf (org-capture-get :return-to-wconf 'local))
	 (new-buffer (org-capture-get :new-buffer 'local))
	 (kill-buffer (org-capture-get :kill-buffer 'local))
	 (base-buffer (buffer-base-buffer (current-buffer))))
     ;; Run the hook
     (run-hooks 'org-capture-before-finalize-hook))

     (when (org-capture-get :decrypted)
     (save-excursion
     (goto-char (org-capture-get :decrypted))
     (org-encrypt-entry)))

     ;; Kill the indirect buffer
     (save-buffer)
     (let ((return-wconf (org-capture-get :return-to-wconf 'local))
     (new-buffer (org-capture-get :new-buffer 'local))
     (kill-buffer (org-capture-get :kill-buffer 'local))
     (base-buffer (buffer-base-buffer (current-buffer))))

     ;; Kill the indirect buffer
     (kill-buffer (current-buffer))

     Link:  [[file:~/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el::(kill-buffer%20(current-buffer))]]
     File:   /home/yiddi/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el

**** MESSY 注意這裏的 org-capture-get :buffer.
     maybe, there is a list ,uesd to cache and follow the current state of emacs,
     it is global ,and varied with the state of emacs.
     ;; Narrow back the target buffer to its previous state
     (with-current-buffer (org-capture-get :buffer)
     (let ((reg (org-capture-get :initial-target-region))
     (pos (org-capture-get :initial-target-position))
     (ipt (org-capture-get :insertion-point))
     (size (org-capture-get :captured-entry-size)))

     Link:  [[file:~/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el::(size%20(org-capture-get%20:captured-entry-size)))]]
     File:   /home/yiddi/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el

**** MESSY  在這裏找到了關於 這三個名詞的一些蛛絲馬跡: 什麼是 indirect-buffer 和他的 base-buffer
     To do this, you must create an indirect buffer using
     ‘M-x make-indirect-buffer’.
     The first argument of this command is the existing outline buffer name
     its second argument is the name to use
     for the new indirect buffer.

     An “indirect buffer” shares the text of some other buffer, which is called the
     “base buffer” of the indirect buffer. In some ways it is a buffer analogue of
     a symbolic link between files.

     Link:  [[info:emacs#Outline%20Views][info:emacs#Outline Views]]

     File:

**** MESSY orgcapture 中經常出現的 plist ,看來是 emacs 中一種常用的數據結構

     plist-get is a built-in function in *‘C source code’*.

     (plist-get PLIST PROP)

     Extract a value from a property list.
     PLIST is a property list, which is a list of the form
     (PROP1 VALUE1 PROP2 VALUE2...).

     而且 emacs 似乎存了很多個 plist 分別有不同用途

     This function returns the value
     corresponding to the given PROP, or nil if PROP is not one of the
     properties on the list.  This function never signals an error.

     Link:  [[file:~/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el::(plist-get%20org-store-link-plist%20:annotation)]]
     File:   /home/yiddi/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el

**** MESSY 學習這種編程技巧,似乎像一種倒敘的手法
     你看他給一個變量賦值, 是這麼用的:
     (let* ((orig-buf (current-buffer))
     (annotation (if (and (boundp 'org-capture-link-is-already-stored)
     org-capture-link-is-already-stored)
     (plist-get org-store-link-plist :annotation)
     (ignore-errors (org-store-link nil))))

     Link:  [[file:~/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el::(ignore-errors%20(org-store-link%20nil))))]]
     File:   /home/yiddi/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el

**** MESSY 解析 org-capture 函數源代碼
     #+BEGIN_SRC emacs-lisp
   (defun org-capture (&optional goto keys) ;; goto 就是通過 c-u 傳遞的屬性,表示是否不 capture 任何東西,直接定位到目的地
                                            ;; keys 就是按下 f9 之後看到的各種不同 template 的字母
     (interactive "P")
     (when (and org-capture-use-agenda-date
            (eq major-mode 'org-agenda-mode))
       (setq org-overriding-default-time
         (org-get-cursor-date (equal goto 1))))
     (cond
      ((equal goto '(4)) (org-capture-goto-target))   ; 前綴 C-u 默認就是 4; 這裏 equal 的用法很好, 比較是否兩者具有相似的數據結構
      ((equal goto '(16)) (org-capture-goto-last-stored)) ; 前綴 C-u C-u 默認就是 16
      (t
       ;; FIXME: Are these needed?
       (let* ((orig-buf (current-buffer))   ; 按下 f9 的瞬間就執行這整個函數,執行到這裏時還沒有新建那個選擇模板窗口
                                            ; 換言之,還在你按 f9 時的那個窗口裏.
                                            ; 這裏緩存了當前的 buffer 的名字
                                            ; DONE current-buffer = 按 f9 之前的狀態
          (annotation (if (and (boundp 'org-capture-link-is-already-stored)
                   org-capture-link-is-already-stored)
                  (plist-get org-store-link-plist :annotation)
                (ignore-errors (org-store-link nil))))
          (entry (or org-capture-entry (org-capture-select-template keys)))  ------>至此才新建這個選擇窗口(*Org select*)
                                                                    | The template code
                                                                    |(defun org-capture-select-template (&optional keys)
                                                                    |  "Select a capture template.
                                                                    |Lisp programs can force the template by setting KEYS to a string."
                                                                    |  (let ((org-capture-templates
                                                                    |     (or (org-contextualize-keys
                                                                    |          org-capture-templates org-capture-templates-contexts)
                                                                    |         '(("t" "Task" entry (file+headline "" "Tasks")
                                                                    |    	"* TODO %?\n  %u\n  %a")))))
                                                                    |    (if keys
                                   assoc mathc key with 1st column  |    (or (assoc keys org-capture-templates)
                                                of table template   |       (error "No capture template referred to by \"%s\" keys" keys))
                                           org-kms 就是彈出一個選擇窗口|       (org-mks org-capture-templates
                                                                    |           "Select a capture template\n========================="
                                                                    |           "Template key: "
                                                                    |           '(("C" "Customize org-capture-templates")
                                                                    |    	 ("q" "Abort"))))))
                                                                    |到這一步新的 buffer 出現,你按下一個 template 的 hotkey.就把 tempalte 的具體
                                                                    |內容存儲到了 entry 裏面.不按,就一直這麼放着,要麼 quit.
                                                                    |;DONE current-buffer = 按 f9 彈出的選擇框 buffer
          initial)
         (setq initial (or org-capture-initial                      ; 在這個新的 buffer 裏,你按下某個按鍵之後,不會立即關掉 buffer,而是
               (and (org-region-active-p)                           ; 先把這個按鍵字母後面的對應內容截取到 initial 變量中,用來做進一步匹配
                    (buffer-substring (point) (mark)))))
         (when (stringp initial)
       (remove-text-properties 0 (length initial) '(read-only t) initial))
         (when (stringp annotation)
       (remove-text-properties 0 (length annotation)
                   '(read-only t) annotation))
         (cond
          ((equal entry "C")
       (customize-variable 'org-capture-templates))
          ((equal entry "q")
       (user-error "Abort"))
          (t
       (org-capture-set-plist entry)                                ; 下面的步驟都是按順序填表,從上面暫存的變量中獲得
                                                                    ; 主要是存儲和更改一些 property-list,爲下一步做準備工作
       (org-capture-get-template)
       (org-capture-put :original-buffer orig-buf
                :original-file (or (buffer-file-name orig-buf)
                           (and (featurep 'dired)
                            (car (rassq orig-buf
                                    dired-buffers))))
                :original-file-nondirectory
                (and (buffer-file-name orig-buf)
                     (file-name-nondirectory
                      (buffer-file-name orig-buf)))
                :annotation annotation
                :initial initial
                :return-to-wconf (current-window-configuration)
                :default-time
                (or org-overriding-default-time
                    (org-current-time)))
       (org-capture-set-target-location)                           ; *[標記位置]對於有些變量需要做進一步處理的,比如這裏要找到目的地和目的 headline
                                                                   ; 找到或者利用函數的 side-effection 去新建 headline
                                                                   ; *[重要]這個函數最大的作用就是打開目的地 buffer,並且將其 point 值指定好了,就等編輯了*
                                                                   ; *[重要]這個函數通過 save-excursion 和 set-buffer 切進了目的地 buffer,然後又切回來了
       (condition-case error
           (org-capture-put :template (org-capture-fill-template))
         ((error quit)
          (if (get-buffer "*Capture*") (kill-buffer "*Capture*"))  ; 如果當前能找到這個 buffer:*Capture*,就把他關掉
          (error "Capture abort: %s" error)))

       (setq org-capture-clock-keep (org-capture-get :clock-keep)) ; 從這裏開始是對一些 tempalte 中用戶指定的值進行存取和必要的操作
       (if (equal goto 0)
           ;;insert at point
           (org-capture-insert-template-here)                      ; 這裏已經預先開始編輯目的文件和目的 headline,並且把 template 寫入了
         (condition-case error
             (org-capture-place-template                           ; *[放置模板]這個函數從 target 屬性中獲取了目的地 buffer 的名字,並且新建了其對應的 indirect-buffer
                                                                   ; 在 indirect-buffer 中指定位置拷貝進模板
                                                                   ; DONE current-buffer = 目的地 buffer 的 indirect-buffer
              (eq (car (org-capture-get :target)) 'function))
           ((error quit)
            (if (and (buffer-base-buffer (current-buffer))         ; 這裏爲 finalize 做進一步準備,利用 indirect-buffer 和 base-buffer
                 (string-prefix-p "CAPTURE-" (buffer-name)))
            (kill-buffer (current-buffer)))                        ; 到這裏爲止
            (set-window-configuration (org-capture-get :return-to-wconf))
            (error "Capture template `%s': %s"
               (org-capture-get :key)
               (nth 1 error))))
         (if (and (derived-mode-p 'org-mode)
              (org-capture-get :clock-in))
             (condition-case nil
             (progn
               (if (org-clock-is-active)
               (org-capture-put :interrupted-clock
                        (copy-marker org-clock-marker)))
               (org-clock-in)
               (setq-local org-capture-clock-was-started t))
           (error
            "Could not start the clock in this capture buffer")))
         (if (org-capture-get :immediate-finish)
             (org-capture-finalize)))))))))                         ;org-capture 執行完畢,他主要是新建了一個 indirect-buffer,並且把模板插入其中了.
     #+END_SRC

     Link:  [[file:~/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el::(defun%20org-capture%20(&optional%20goto%20keys)]]
     File:   /home/yiddi/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el

     這個函數的執行階段,就想一根主線上掛了很多個鉤子,每個鉤子又是一個主線,也能掛其他鉤子一樣:

     org-capture ----------------------------------------------------------------------------------------------------------------------------------------->
     \
     \
     select-tempate
     ---------------------->
     \          \
     \          \
     assoc      mks
     ---->      --->


**** MESSY 這個 ork-mks 經常搭配 assoc 使用,用來從這個 table 數據結構中做選則

     ---assoc-------------------
     assoc is a built-in function in ‘src/fns.c’.

     (assoc KEY LIST)

     Return non-nil if KEY is ‘equal’ to the car of an element of LIST.
     The value is actually the first element of LIST whose car equals KEY.


     ---org-mks-------------------
     org-mks is a compiled Lisp function in ‘org-capture.el’.

     (org-mks TABLE TITLE &optional PROMPT SPECIALS)

     Select a member of an alist with multiple keys.

     TABLE is the alist which should contain entries where the car is a string.
     There should be two types of entries.

     1. prefix descriptions like ("a" "Description")
        This indicates that ‘a’ is a prefix key for multi-letter selection, and
        that there are entries following with keys like "ab", "ax"...

     2. Select-able members must have more than two elements, with the first
        being the string of keys that lead to selecting it, and the second a
        short description string of the item.

     The command will then make a temporary buffer listing all entries
     that can be selected with a single key, and all the single key
     prefixes.  When you press the key for a single-letter entry, it is selected.
     When you press a prefix key, the commands (and maybe further prefixes)
     under this key will be shown and offered for selection.

     TITLE will be placed over the selection in the temporary buffer,
     PROMPT will be used when prompting for a key.  SPECIAL is an
     alist with ("key" "description") entries.  When one of these
     is selected, only the bare key is returned.

     Link:  [[file:~/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el::(org-mks%20org-capture-templates]]
     File:   /home/yiddi/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el

**** MESSY 一般的 elisp 形式
     ---------------------------------------------------------------
     變量名賦值:
     (let ((變量 1  (expre1)))
     這個 expre 甚至可以是 if 語句,或者另一個函數
     #+BEGIN_SRC emacs-lisp

    (let* ((orig-buf (current-buffer))
	   (annotation (if (and (boundp 'org-capture-link-is-already-stored)
				org-capture-link-is-already-stored)
			   (plist-get org-store-link-plist :annotation)
			 (ignore-errors (org-store-link nil))))
     #+END_SRC

     ---------------------------------------------------------------
     函數調用:
     (函數名 (expre1))
     這個 expre1 甚至可以是另一個函數調用
     #+BEGIN_SRC emacs-lisp
	      (org-capture-place-template
	       (eq (car (org-capture-get :target)) 'function))
     #+END_SRC
     ---------------------------------------------------------------
     Link:  [[file:~/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el::(org-capture-place-template]]
     File:   /home/yiddi/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el

**** MESSY elisp 編程技巧

     *這麼像就對了,所有可以用變量的地方也都可以用任何一個表達式.*

     得益於, elisp 表達式返回 nil 和其他值,而 nil 爲空,其他值一律被認爲真.
     所以 if 更靈活:
     ---------------------------------------------
     如果有兩個函數,在他們都成功時,才執行另一個表達式:

     #+BEGIN_SRC emacs-lisp
     (if (and(func-1) (func-2))
          (exp1))
     #+END_SRC

     ---------------------------------------------
     如果想在判定一個變量賦是否被成功賦值,該怎麼做:
     #+BEGIN_SRC emacs-lisp

      (if (exist-p (setq <這個變量> (exp))))

         (if (file-exists-p
          (setq file (expand-file-name (nth 1 txt) org-directory)))
     #+END_SRC

     Link:  [[file:~/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el::(setq%20file%20(expand-file-name%20(nth%201%20txt)%20org-directory)))]]
     File:   /home/yiddi/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el

**** MESSY 盤點一個值是否存在,不存在就給他賦值,這句話怎麼翻譯
     (setq buffer (or buffer (current-buffer)))

     Link:  [[file:~/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el::(setq%20buffer%20(or%20buffer%20(current-buffer)))]]
     File:   /home/yiddi/.emacs.d/elpa/org-plus-contrib-20170210/org-capture.el

**** MESSY hotkey: 如何尋找 emacs lib 源代碼
     | spc o h | hydr-apropos/body |
     在裏面可以找到各種你想要的文檔和東西,都分好類的
*** 2017-03-16 Thursday

**** MESSY  elisp 中的名字 空間: define-namespace
     define-namespace is an autoloaded Lisp macro in ‘names.el’.

     (define-namespace NAME [KEYWORD ...] BODY)

     Inside the namespace NAME, execute BODY.
     NAME can be any symbol (not quoted), but it’s highly recommended
     to use some form of separator (such as :, /, or -). For a
     complete description of this macro, please visit the frontpage
     with M-x names-view-manual.

     In summary, this macro has two main effects:

     1. Any definitions inside BODY will have NAME prepended to the
     symbol given. Ex:

     (define-namespace foo-
     (defvar bar 1 "docs")
     )

     expands to

     (defvar foo-bar 1 "docs")


     2. Any function calls and variable names get NAME prepended to
     them if such a variable or function exists. Ex:

     (define-namespace foo:
     (defun message (x y) nil)
     (message "%s" my-var)
     )

     expands to

     (defun foo:message (x y) nil)
     (foo:message "%s" my-var)

     Link:   [[help:define-namespace]]
     File:

**** MESSY 如何從格式化字符串獲得整個字符串
     format is a built-in function in ‘C source code’.

     (format STRING &rest OBJECTS)

     Format a string out of a format-string and arguments.
     The first argument is a format control string.
     The other arguments are substituted into it to make the result, a string.

     The format control string may contain %-sequences meaning to substitute
     the next available argument:

     %s means print a string argument.  Actually, prints any object, with ‘princ’.
     %d means print as number in decimal (%o octal, %x hex).
     %X is like %x, but uses upper case.
     %e means print a number in exponential notation.
     %f means print a number in decimal-point notation.
     %g means print a number in exponential notation
     or decimal-point notation, whichever uses fewer characters.
     %c means print a number as a single character.
     %S means print any object as an s-expression (using ‘prin1’).

     Link:   [[help:format]]
     File:

**** MESSY 如何設置一個常量
     #+BEGIN_SRC emacs-lisp
     ;;注意這裏最後帶有一個 %s 佔位符,是方便之後嵌入 query-word 的
     (defconst api-url
        "http://fanyi.youdao.com/openapi.do?keyfrom=YouDaoCV&key=659600698&type=data&doctype=json&version=1.1&q=%s"
        "Youdao dictionary API template, URL `http://dict.youdao.com/'.")

     (defun -format-request-url (query-word)
     "Format QUERY-WORD as a HTTP request URL."
        (format api-url (url-hexify-string query-word)))
     #+END_SRC

     Link:   [[file:~/.emacs.d/elpa/youdao-dictionary-20170226.49/youdao-dictionary.el::"Youdao%20dictionary%20API%20template,%20URL%20`http://dict.youdao.com/'.")]]
     File:   /home/yiddi/.emacs.d/elpa/youdao-dictionary-20170226.49/youdao-dictionary.el

**** MESSY add word to a file
     (append-to-file (concat word "\n") nil search-history-file))

     Link:   [[file:~/.emacs.d/elpa/youdao-dictionary-20170226.49/youdao-dictionary.el::(append-to-file%20(concat%20word%20"\n")%20nil%20search-history-file))]]
     File:   /home/yiddi/.emacs.d/elpa/youdao-dictionary-20170226.49/youdao-dictionary.el

**** MESSY 如何獲取 光標選擇的 區域的字符
     (if (use-region-p)
     (buffer-substring-no-properties (region-beginning)
     (region-end))

     Link:   [[file:~/.emacs.d/elpa/youdao-dictionary-20170226.49/youdao-dictionary.el::(region-end))]]
     File:   /home/yiddi/.emacs.d/elpa/youdao-dictionary-20170226.49/youdao-dictionary.el

**** MESSY hotkey: , g g goto defintion of function
     '
     Link:   [[file:/usr/local/share/emacs/25.1/lisp/thingatpt.el.gz::(defun%20thing-at-point%20(thing%20&optional%20no-properties)]]
     File:   /usr/local/share/emacs/25.1/lisp/thingatpt.el.gz

**** MESSY , 開頭的大部分和 elisp 編譯代碼有關
     '
     Link:   [[file:~/.emacs.d/elpa/youdao-dictionary-20170226.49/youdao-dictionary.el::(thing-at-point%20(if%20use-chinese-word-segmentation]]
     File:   /home/yiddi/.emacs.d/elpa/youdao-dictionary-20170226.49/youdao-dictionary.el

**** MESSY  看看如何使用 mapconcat 對每一個字符使用同一個函數.
     -------------------------------------
     mapconcat is a built-in function in ‘src/fns.c’.

     (mapconcat FUNCTION SEQUENCE SEPARATOR)

     Apply FUNCTION to each element of SEQUENCE, and concat the results as strings.
     In between each pair of results, stick in SEPARATOR.  Thus, " " as
     SEPARATOR results in spaces between the values returned by FUNCTION.
     SEQUENCE may be a list, a vector, a bool-vector, or a string.


     ;; construct data for display
     (phonetic (assoc-default 'phonetic basic))
     (translation-str (mapconcat
     (lambda (trans) (concat "- " trans))
     translation "\n"))

     Link:   [[file:~/.emacs.d/elpa/youdao-dictionary-20170226.49/youdao-dictionary.el::translation%20"\n"))]]
     File:   /home/yiddi/.emacs.d/elpa/youdao-dictionary-20170226.49/youdao-dictionary.el

**** MESSY 家具價格
     | 家具        | 價格 | 備注 |
     |-------------+------+------|
     | 轉角沙發    | 6700 |      |
     | 茶幾        | 1640 |      |
     | 餐桌+4*餐椅 | 3000 |      |
     | 電視櫃      | 1890 |      |
     | 窗簾        | 2889 |      |
     ---------------------------------------
     Total: 16119 rmb
**** MESSY 高清 footnote 的 definition 和 reference.
     你在文檔裏嵌入的叫做  reference
     在你腳注裏注明的叫做  definition
     A footnote is started by a footnote marker in square brackets in
     column 0, no indentation allowed.  It ends at the next footnote
     definition, headline, or after two consecutive empty lines.  The
     footnote reference is simply the marker in square brackets, inside
     text.  Markers always start with `fn:'.  For example:

     The Org homepage[fn:1] now looks a lot better than it used to.
     ...
     [fn:1] The link is: http://orgmode.org

     Link:   [[info:org#Footnotes][info:org#Footnotes]]
     File:

**** MESSY 這個函數相當好用,thing-at-point, 能很好的識別當前光標所在位置是個什麼 d 東西

     ;;;###autoload
     (defun forward-thing (thing &optional n)
     "Move forward to the end of the Nth next THING.
     THING should be a symbol specifying a type of syntactic entity.
     Possibilities include `symbol', `list', `sexp', `defun',
     `filename', `url', `email', `word', `sentence', `whitespace',
     `line', and `page'."
     (let ((forward-op (or (get thing 'forward-op)
     (intern-soft (format "forward-%s" thing)))))
     (if (functionp forward-op)
     (funcall forward-op (or n 1))
     (error "Can't determine how to move over a %s" thing))))

     Link:   [[file:/usr/local/share/emacs/25.1/lisp/thingatpt.el.gz::(error%20"Can't%20determine%20how%20to%20move%20over%20a%20%25s"%20thing))))]]
     File:   /usr/local/share/emacs/25.1/lisp/thingatpt.el.gz
*** 2017-03-17 Friday

**** MESSY 如何給 spacemacs 添加額外的包
     Source: [2017-03-17 Fri], [[http://emacs.stackexchange.com/questions/20453/how-to-use-a-local-version-of-a-package-in-spacemacs][How to use a local version of a package in spacemacs? - Emacs Stack Exchange]]


     dotspacemacs-additional-packages
     '((helm-spotify :location (recipe :fetcher github :repo "syl20bnr/helm-spotify")))

**** MESSY 如何讓 spacemacs 使用 emacs 內建的 org 版本
     Source: [2017-03-17 Fri], [[https://github.com/syl20bnr/spacemacs/issues/7994][How do I make spacemacs use the emacs built-in version of org? · Issue #7994 · syl20bnr/spacemacs]]

     參考鏈接:[[file:~/.spacemacs.d/layers/zilongshanren-org/packages.el::)]]
     #+BEGIN_SRC emacs-lisp
(defconst zilongshanren-org-packages
  '(
    (org :location built-in)
    ;; org-mac-link ;; yiddi:never use
    org-octopress
    org-pomodoro
    deft
    ;; org-tree-slide
    ;; ox-reveal
    ;; worf
    ;; org-download
    ;; plain-org-wiki
    )
  )
     #+END_SRC

     Is there a way to force spacemacs to load the ORG version that comes preloaded with emacs? I'm on emacs25.1

     One of the functions missing is: org-table-clean-before-export

     Collaborator d12frosted commented on 19 Dec 2016 what I find strange is that
     this happens even when I don't have the ORG layer enabled Distribution named
     spacemacs enables layer named spamceacs-org which adds org as dependency. I
     guess you are using spacemacs distribution

     Is there a way to force spacemacs to load the ORG version that comes preloaded with emacs?
     I can't test the solution I am going to propose right now but theoretically following might work.

     Open up your .spacemacs file.
     Locate dotspacemacs-additional-packages.
     Add (org :location (recipe :fetcher file :path /usr/local/share/emacs/26.0.50/lisp/org/org.el))

     (just don't forget to add real path to org-mode).
     Reload.

**** MESSY 如何讓某個 mode 利用 hydra 選擇框架

     (defun spacemacs/run-pandoc ()
     "Start pandoc for the buffer and open the menu"
     (interactive)
     (pandoc-mode)
     (pandoc-main-hydra/body))

     Link:  [[file:~/.emacs.d/layers/+tools/pandoc/funcs.el::(pandoc-main-hydra/body))]]
     File:   /home/yiddi/.emacs.d/layers/+tools/pandoc/funcs.el

**** MESSY 如何定義 org file 中 block 的具體顏色,讓他們更明顯一些
     Source: [2017-03-17 Fri], [[http://orgmode.org/worg/org-contrib/babel/examples/fontify-src-code-blocks.html][Pretty fontification of source code blocks]]


     (defface org-block-begin-line
     '((t (:underline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF")))
     "Face used for the line delimiting the begin of source blocks.")

     (defface org-block-background
     '((t (:background "#FFFFEA")))
     "Face used for the source block background.")

     (defface org-block-end-line
     '((t (:overline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF")))
     "Face used for the line delimiting the end of source blocks.")

**** MESSY  [[https://www.openfoundry.org/tw/foss-programs/8814-pandoc-][Pandoc 用命令行轉換標記語言！ - OpenFoundry]]
     Captured On: [2017-03-17 Fri 17:23]

**** MESSY  [[http://irreal.org/blog/?p=4098][A Tip for Artist Mode | Irreal]]

     When you specify a `ditaa' source block, artist mode is *automatically started.*
     Might not be enough of a motivator to install and configure ditaa, but if you
     are using artist-mode, you have already done 50% of the work to run ditaa!

     Captured On: [2017-03-17 Fri 17:44]

**** MESSY 如何加載自己寫的 snippet 文件
     Managing your snippets

     ~M-x yas-load-directory~
     ~M-x yas-load-snippet-buffer~

     If you use the ~/.spacemacs.d/snippets/modename-mode/ directory structure for
     your snippets then you can version them with Git or similar versioning tools.

     Load snippets in directory hierarchy TOP-LEVEL-DIR.
     *Below TOP-LEVEL-DIR each directory should be a mode name.*
     *With prefix argument USE-JIT do jit-loading of snippets.*

     #+BEGIN_SRC filename:yid -r
     # -*- mode: python -*-
     # name: yiddi
     # key: yid
     # --
     \fracsdfsdfsdf{${1:numerator}}{${2:denominator}}$0
     #+END_SRC

     比如這裏的一個 snippet:
     1. 第一行, 表明會在哪些 major-mode 啓用
     2. 第二行, 表明補全提示符 yid -> yiddi 箭頭後的字符串
     3. 第三行, 輸入的什麼字符 按<tab>才會補全
     4. 這個文件的名字必須與 key 一致,沒有後綴.
     5. 這個文件的文件夾必須是 xxx-mode

     Adding yas-snippets to autocompletion in Spacemacs

     By adding the autocompletion layer in Spacemacs the YASnippets can be shown in
     the autocompletion menu as you type.

     By default, snippets are not shown in the auto-completion popup, so set the
     variable auto-completion-enable-snippets-in-popup to t.

     #+BEGIN_SRC emacs-lisp
     (setq-default dotspacemacs-configuration-layers
              '((auto-completion :variables
                                 auto-completion-enable-snippets-in-popup t)))
     #+END_SRC

***** examples
      #+BEGIN_SRC
# -*- mode: snippet -*-
# name: frac
# key: frac
# --
\frac{${1:numerator}}{${2:denominator}}$0
      #+END_SRC

      #+BEGIN_SRC
# -*- mode: snippet -*-
# name: begin
# key: begin
# --
\begin{${1:environment}}
$0
\end{$1}
      #+END_SRC

      Link:   [[file:~/.spacemacs.d/plantuml.jar][file:~/.spacemacs.d/plantuml.jar]]
      File:   /home/yiddi/.spacemacs.d/

**** MESSY 如何配置 mu4e 的 maildir
     Source: [2017-03-17 Fri], [[http://www.djcbsoftware.nl/code/mu/mu4e/Folders.html#Folders][Mu4e 0.9.18 user manual: Folders]]


     The next step is to tell mu4e where it can find your Maildir, and some special folders.

     So, for example18:

     ;; these are actually the defaults
     (setq
     mu4e-maildir       "~/Maildir"   ;; top-level Maildir
     mu4e-sent-folder   "/sent"       ;; folder for sent messages
     mu4e-drafts-folder "/drafts"     ;; unfinished messages
     mu4e-trash-folder  "/trash"      ;; trashed messages
     mu4e-refile-folder "/archive")   ;; saved messages

     Note, mu4e-maildir takes an actual filesystem-path, the other folder names
     are all *relative to mu4e-maildir*. Also note that this must not be a symbolic
     link.

     If you use mu4e-context, see Contexts and special folders for what that means
     for these special folder
*** 2017-03-18 Saturday

**** MESSY  [[http://coldnew.github.io/blog/2016/01-02_mu4e/][在 emacs 下使用 mu4e 收發郵件 | coldnew's blog]]             :mu4e:
     Captured On: [2017-03-18 Sat 10:19]

**** MESSY 2nd verification password of google for emacs           :personal:
     avuyyikdtkqaydfp
     Link:  [[file:~/.spacemacs.d/init.el::(mu4e-sent-folder%20"/uni/sent")]]
     File:   /home/yiddi/.spacemacs.d/init.el

**** MESSY hotkey
     spc s p search project
     spc s f search for files and ceratin suffix files
     spc s b search all the open buffer

     http://coldnew.github.io/blog/2016/01-02_mu4e/
     Link:  [[file:~/.spacemacs.d/init.el::(mu4e-sent-folder%20"/gmail/sent")]]
     File:   /home/yiddi/.spacemacs.d/init.el

**** MESSY  [[http://blog.csdn.net/xingzouagain/article/details/52511129][GnuPG 使用介绍 - xingzouagain 的博客 - 博客频道 - CSDN.NET]]
     Captured On: [2017-03-18 Sat 15:14]

**** MESSY  [[https://www.apache.org/dev/openpgp.html][How To OpenPGP]]
     Captured On: [2017-03-18 Sat 15:28]

**** MESSY 2-step 登錄方式
     1. 生成 16 位密碼
     2. 在任意你希望以此 16 位密碼代替原密碼的 app(eg:gmail)中設置他
     Source: [2017-03-18 Sat], [[https://myaccount.google.com/apppasswords?rapt=AEjHL4OXBuBVmTbPt5qcthqOC0Q4QIcavOeYt899uZ_HCaAj8D5kcuhdRFswUlcYM_YlkxI8Bn6Iv-DqqQ1m59K0K6TPxX2yug][应用专用密码]]


     在您要设置的应用或设备中，前往您的 Google 帐号的设置部分。将您的密码更换成由 16 个字符组成的密码（如上所示）。
     该应用专用密码的效用跟普通密码一样。有了它，就可以获得您 Google 帐号的完全访问权限。您无需记住该密码，所以请勿将它写下来或告诉他人。
     完成

**** MESSY  [[http://orgmode.org/worg/org-tutorials/encrypting-files.html][Encrypting org Files.]]                                       :gpg:
     Captured On: [2017-03-18 Sat 20:40]

**** MESSY  [[https://www.gnu.org/software/emacs/manual/html_node/epa/index.html#Top][EasyPG Assistant User’s Manual: Top]]                        :gpg:
     Captured On: [2017-03-18 Sat 20:41]

**** MESSY  [[http://blog.csdn.net/xingzouagain/article/details/52511129][GnuPG 使用介绍 - xingzouagain 的博客 - 博客频道 - CSDN.NET]]    :gpg:
     Captured On: [2017-03-18 Sat 20:41]

**** MESSY  [[http://coldnew.github.io/blog/2016/01-02_mu4e/][在 emacs 下使用 mu4e 收發郵件 | coldnew's blog]]             :mu4e:
     Captured On: [2017-03-18 Sat 20:43]

**** MESSY  [[https://github.com/OfflineIMAP/offlineimap/blob/master/offlineimap.conf][offlineimap/offlineimap.conf at master · OfflineIMAP/offlineimap]] :offlineimap:mu4e:
     這個文件是 配置詳情
     幫我解決了,如何獲取 refresh_token 問題
     Captured On: [2017-03-18 Sat 22:25]

**** MESSY 這是臺灣一個大神給的配置, 但是那兩個注釋着實害慘我了

     搞了兩天整, 最後發現 把那兩個注釋去掉就完成運行了.
     這兩天看過的一些信息有:
     - oauth http://www.jianshu.com/p/103e2dc6593b
     - mu https://xapian.org/docs/
     - gpg https://www.gnupg.org/documentation/manpage.html
       - http://blog.csdn.net/xingzouagain/article/details/52511129


     http://coldnew.github.io/blog/2016/01-02_mu4e/

     [general]
     accounts = yiddi
     maxsyncaccounts = 3
     pythonfile = ~/.offlineimap.py
     [Account yiddi]
     localrepository = yiddi-Local
     remoterepository = yiddi-Remote
     [Repository yiddi-Local]
     type = Maildir
     localfolders = ~/.mail/gmail
     [Repository yiddi-Remote]
     type = Gmail
     remotehost = imap.gmail.com

     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     remoteuser = yiddishkop@gmail.com # <-----------chenge your account here
     remotepasseval = get_password_emacs("imap.gmail.com", "993") # <-------------- get pswd here
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

     # remotepass = y.l.7130201
     ssl = yes
     sslcacertfile = /etc/ssl/certs/ca-certificates.crt
     nametrans = lambda foldername: foldername.decode('imap4-utf-7').encode('utf-8')
     maxconnections = 4
     realdelete = yes
     oauth2_client_id = 428779981436-9kbic426kllhu178naf0drkgfk4qmn4n.apps.googleusercontent.com
     oauth2_client_secret = y5cQRwI78U-vNvl4ZKnYZNlx
     oauth2_refresh_token = 1/t4L2PBSuxatB7OqT-YEHQB1Vh_eGOU_hOwOx8UAon_8
     oauth2_request_url = https://accounts.google.com/o/oauth2/token

     Link:  [[file:~/.offlineimaprc::type%20=%20Gmail]]
     File:   /home/yiddi/.offlineimaprc
*** 2017-03-19 Sunday

**** MESSY can not close emacs, tips: host name must not match with 'adb'
     process to reduce errors:
     1. 遇到這樣的坑,不知道怎麼回事,於是通過 spc f L 查這個 adb
        1. 一開始查到 oh-my-zsh 裏有個 adb 插件.所以考慮是最近使用了 eshell 的原因.
        2. 但是 spc f L 的查詢記錄還有關於 tramp 這個包的: tramp-adb.el
     2. 然後在這個包裏用 spc s p. 查詢 "host name must not ..." 這句話, 確實存在與
        [[file:~/Downloads/emacs-25.1/lisp/net/tramp.el::(tramp-user-error%20vec%20"Host%20name%20must%20not%20match%20method%20\"%25s\""%20host))))]]
     3. 然後考慮也許是最近使用的 eshell 用到了 tramp 的某些功能.
     4. 進一步 spc s p 查詢 函數名 tramp-check-proper-method-and-host, 找到其在 tramp-sh.el 中被調用
     5. 又在 spc f e d : ~/.spacemacs.d/init.el 中 tramp 功能被禁用.
        1. [[file:~/.spacemacs.d/init.el::(setq%20tramp-mode%20nil)]]
     6. 打開了這個功能, 問題解決, 能成功關閉 emacs 了.

     ;; https://github.com/syl20bnr/spacemacs/issues/2705
     (setq tramp-mode nil)

     Link:  [[file:~/.spacemacs.d/init.el::(setq%20tramp-mode%20nil)]]
     File:   /home/yiddi/.spacemacs.d/init.el

**** MESSY 關於 company-mode 的 emacs 版配置(與 spacemacs 不同)
     Source: [2017-03-19 Sun], [[http://dockone.io/article/709][阅读 Docker 源代码的神兵利器 - DockOne.io]]


     4. Emacs

     Emacs 作为与 Vim 齐名的文本编辑器，号称“神之编辑器”，用来浏览和编写 Go 代码也是非常方便的。本节也只作为 Emacs 老用户的抛砖引玉，在此之前，用户需要做好适合自己的配置。下面我们就以 Emacs24 为例，简单介绍几个实用的插件，用户需要先使用 go get 命令安装好 gofmt、godef、godoc、gocode 等工具。
     go-mode

     go-mode 在提供了自动缩进和语法高亮功能的基础上，还整合了 Go 语言自带的工具，如 gofmt、godoc、godef 等。在 Emacs24 以后的版本中，可以使用自带的 Package 工具进行安装，命令如下：M-x package-install go-mode 下面我们主要介绍格式整理以及定义跳转两项功能的配置。
     格式整理

     格式整理功能直接调用了 gofmt 工具，该工具能使用户的代码风格与其他开发人员保持一致。在 Emacs 中，用户可以直接调用 gofmt 命令，对当前窗口的代码进行格式整理。另一种方式是为 before-save-hook 添加函数，示例如下：
     (add-hook 'before-save-hook 'gofmt-before-save)

     这样在用户每次存档时就会自动进行格式整理。
     定义跳转

     定义跳转使用了 godef 工具，该工具能分析用户的代码、其他包内的代码以及 Go 标准库，实现在这三者间的定义跳转。Emacs 提供了 godef-jump 命令实现跳转，默认绑定键为 C-c C-j，用户也可以自己定义按键绑定，如绑定到 F3 键：
     (add-hook 'go-mode-hook
     '(lambda () (local-set-key (kbd "<f3>") 'godef-jump)))

     为了在跳转之后能跳转回来，用户可以添加如下配置，这样可以使用 F2 键回到原先的位置。
     (add-hook 'go-mode-hook
     '(lambda () (local-set-key (kbd "<f2>") 'pop-tag-mark)))

     此外，go-mode 还提供了管理 imports、使用 godoc 等工具，这里不再一一赘述。
     company-go

     company-go 调用 gocode 工具提供自动完成功能，用户可以直接使用 Package 工具安装 company-mode 和 company-go，并进行如下配置：
     (add-hook 'go-mode-hook 'company-mode)
     (add-hook 'go-mode-hook
     (lambda ()
     (set (make-local-variable 'company-backends) '(company-go))
     (company-mode)))

     Emacs 还为用户提供了极大的自由度，建议用户使用最新版本的 Emacs 和插件，善用 Package 功能和网上贡献的工具，这样能获得最新的功能和更好的体验。
*** 2017-03-20 Monday

**** MESSY  關於如何給某一個 mode 設置 evil-<xxx>-state

     你想讓某一個 major-mode 默認使用哪一種 evil 的 state?
     就這麼做:
     #+BEGIN_SRC emacs-lisp
     (dolist (mode '(ag-mode
                     flycheck-error-list-mode
                     git-rebase-mode))
     (add-to-list 'evil-emacs-state-modes mode))
     #+END_SRC

     工作流程:
     1. 查詢你需要設置爲 evil state 的 major-mode 的名字: M-x major-mode

     2. 填到上述 dolist 的列表中

        Link:
        File:

**** MESSY  C-c C-v Tab inspect the content of an object   :commonlisp:debug:
     #+BEGIN_SRC commonlisp
CL-USER> (make-instance 'point :x 10 :y 20)
         #<POINT {1003FB6433}> ; 鼠標就放在{}之內,按下 ~C-c C-v tab~
CL-USER> (point-x #<POINT {1003FB6433}>)
     #+END_SRC

**** MESSY 查看某個函數的具體調用棧: Slime Trace Dialog    :debug:commonlisp:
     1) 跟蹤某個函數: ~C-c M-t~ 而後輸入函數名.
     2) runnning the code: CL-USER:(call func)
     3) 打開跟蹤結果: ~C-c T~
     4) 刷新獲得最近跟蹤: ~G~


     #+BEGIN_SRC common-lisp

(defun sum (xs &optional (acc 0))
  (if (null xs)
      acc
      (sum (cdr xs) (+ (car xs) acc)))
;; 編譯上述函數,而後按下 c-c m-t 輸入函數名
;; repl 界面 調用該函數
;; repl 界面 打開跟蹤結果: c-c T
;; 跟蹤結果界面如下,該界面按下: G 獲得更新結果

Trace collection status (4/8)                     [refresh]
                                                  [fetch next batch]
                                                  [fetch all]
                                                  [clear]


   0 - common-lisp-user::sum
     | > (1 2 3)
     | < 6
   1 `--- common-lisp-user::sum
        | > (2 3)
        | > 1
        | < 6
   2    `--- common-lisp-user::sum
           | > (3)
           | > 3
           | < 6
   3       `--- common-lisp-user::sum
                > NIL
                > 6
                < 6

     #+END_SRC

**** MESSY commonlisp 如何調出 debug 界面                     :commonlisp:debug:
     1. 首先打開 debug ~(declaim (optimize (debug 3)))~
     2. 編譯函數,並在 repl(CL-USER)運行之
     3. 運行會自動打開 debug 界面
     4. 此時說明有錯,回去在函數中加入 ~(break)~, break-point
     5. 再次於 repl 中執行,會再次顯示 debug 界面
     6. ~evil-emacs-state~ 下,在調用棧按下 ~r~,從某個調用開始,按 ~s~ , 單步執行.


     #+BEGIN_SRC common-lisp
CL-USER> (declaim (optimize (debug 3)))
         NIL
CL-USER> (your-program)
     #+END_SRC

**** MESSY dynamic variable                                      :commonlisp:
     Source: [2017-03-20 Mon], [[http://malisper.me/category/debugging-common-lisp/][Debugging Lisp Archives - Macrology]]


     A dynamic variable is basically a global variable that can be shadowed. When
     a dynamic variable is shadowed, any reference to it refers to the new
     binding. Once execution leaves the form that shadowed the dynamic variable,
     the dynamic variable reverts back to its previous binding.

**** MESSY try/catch/throw in commonlisp                   :commonlisp:debug:
     when encounter an exception, languages(*exculde commonlisp*) let you have several choice:
     1. just *skip* the entry that caused the error, just use *handler-case* (catch)
        #+BEGIN_SRC common-lisp
        (defun read-file (file)
       (with-open-file (in file :direction :input)
         (loop for line = (read-line in nil in)
               until (eq in line)
               when (handler-case (parse-integer line) ;; 當 catch 到問題
                      (error (c)                       ;; 直接忽略他
                        (declare (ignore c))
                        nil))
               collect it)))
        #+END_SRC

     2. provide a *dynamic variable* in place for the user of this funcion
        #+BEGIN_SRC common-lisp
     (defvar *malformed-value* nil) ;; 這是一個動態的變量

     (defun read-file (file)
       (with-open-file (in file :direction :input)
         (loop for line = (read-line in nil in)
               until (eq in line)
               when (handler-case (parse-integer line)
                      (error (c)
                        (declare (ignore c))
                        *malformed-value*));; 這個動態變量可以被返回或者指定其他值
               collect it)))

     (let ((*malformed-value* :malformed))
       (read-files *files*))

     => ((5 10 15 20 25) (5 10 15 20 :MALFORMED 30 40))
        #+END_SRC

     3. make read-files catch the error and *skip the entire* file
     #+BEGIN_SRC common-lisp
(defun read-files (files)  ;; 不是在 read-file 中 catch,而是更不負責一些
  (loop for file in files  ;; 而是交給這裏的 read-files
        when (handler-case (read-file file)
               (error (c)
                 (declare (ignore c))
                 nil))
        collect it))

(read-files *files*)
=> ((5 10 15 20 25))
     #+END_SRC

     4. let user of the function handle this exception
     #+BEGIN_SRC common-lisp
(handler-case (read-files *files*) ;; 最不負責人的行爲,讓用戶處理,更自由一些
  (error (c) (do-something)))
     #+END_SRC

***** catch is provided as 2 separate pieces: handler and restarts
      commonlisp can give user all choices by *restart*

**** MESSY awesome restart in commonlisp
     when we use restart we can choose what to do in debug-view.
     箭頭所指的那三個部分,就是我們自己在函數中定義的三種處理方式

     #+BEGIN_SRC common-lisp
   junk in string "a"
      [Condition of type SB-INT:SIMPLE-PARSE-ERROR]

   Restarts:
-->    0: [USE-VALUE] Use a new value.
-->    1: [SKIP-ENTRY] Skip the entry.
-->    2: [SKIP-FILE] SKIP-FILE
     3: [RETRY] Retry SLIME REPL evaluation request.
     4: [*ABORT] Return to SLIME's top level.
     5: [ABORT] abort thread (#<THREAD "repl-thread" RUNNING {1002A8FFA3}>)

   Backtrace:
     0: (PARSE-INTEGER "a" :START 0 :END NIL :RADIX 10 :JUNK-ALLOWED NIL)
     1: (READ-FILE "~/Documents/Test/file2")
     2: (READ-FILES ("~/Documents/Test/file1" "~/Documents/Test/file2"))
     3: (SB-INT:SIMPLE-EVAL-IN-LEXENV (READ-FILES FPL) #<NULL-LEXENV>)
     4: (EVAL (READ-FILES FPL))

     ;; 代碼如下
(defun ask (string)
  (princ string *query-io*)
  (read *query-io*))

(defun read-file (file)
  (with-open-file (in file :direction :input)
    (loop for line = (read-line in nil in)
          until (eq in line)
          when (restart-case (parse-integer line)
                 (use-value (value) ;; 提供選擇一
                   :report "Use a new value."
                   :interactive (lambda ()
                                  (list (ask "Value: ")));;提示符,需輸入 value
                   value)
                 (skip-entry ()     ;; 提供選擇二
                   :report "Skip the entry."
                   nil))
            collect it)))

(defun read-files (files)
  (loop for file in files
        when (restart-case (read-file file)
               (skip-file ()        ;; 提供選擇三
                 :reprot "Skip the entire file."
                 nil))
          collect it))

;;; the three function below are predefined
;;; handler for the most common ways the user
;;; will interact with the restarts.
(defun skip-entry (c)
  (declare (igonre c))
  (invoke-restart 'skip-entry))

(defun skip-file (c)
  (declare (igonre c))
  (invoke-restart 'skip-file))

(defun use-value-handler (c)
  (lambda (c)
    (declare (ignore c))
    (invoke-restart 'use-value value)))
     #+END_SRC

***** 用 restarts 來實現 break point 功能
      #+BEGIN_SRC common-lisp
(defun break (&optional (format-control "Break")
              &rest format-arguments)
   (with-simple-restart (continue "Return from BREAK.")
     (let ((*debugger-hook* nil))
       (invoke-debugger
         (make-condition 'simple-condition
           :format-control   format-control
           :format-arguments format-arguments))))
   nil)
      #+END_SRC
*** 2017-03-21 Tuesday

**** MESSY trace 函數的指定斷點詳細位置                     :commonlisp:debug:

     #+BEGIN_SRC common-lisp
(trace fib :break (= 8 (sb-debug:arg 0))) ;; 這句意思是 在 fib 函數第 0 個參數爲 8 時 break.
(fib 10)

CL-USER> (fib 10)
0: (FIB 10)
1: (FIB 9)
2: (FIB 8)
; Evaluation aborted on NIL.

     #+END_SRC

     #+BEGIN_SRC common-lisp
(trace fib :print-after (get-universal-time));; 每次 fib 函數返回就打印當前 unix 系統時間
     #+END_SRC

**** MESSY  [[http://weitz.de/cl-ppcre/#install][CL-PPCRE - Portable Perl-compatible regular expressions for Common Lisp]]
     commonlisp 下的一個 regex 工具包
     Captured On: [2017-03-21 Tue 09:25]

**** MESSY  [[https://www.quicklisp.org/beta/][Quicklisp beta]]                    :commonlisp:package:management:
     相當於一個 common-lisp 下的包管理工具.可以直接通過 repl 或者系統 terminal 工具安裝.
     #+BEGIN_SRC
     $ sbcl
     ----> 進入 sbcl 的 repl 界面
     * (ql:quickload :<包名>)  ;; 通過這條命令安裝包
     #+END_SRC
     Captured On: [2017-03-21 Tue 09:26]

**** MESSY backquote in lisp                           :commonlisp:backquote:
     Source: [2017-03-21 Tue], [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Backquote.html][GNU Emacs Lisp Reference Manual: Backquote]]

     1. 因爲 lisp 中全是 list, ~'~ 在 lisp 中是表示後面的緊跟的 list,就單純作爲 list 看待,而不是作爲函數

     2. ~`~ 也表示後面緊跟的 list,就單純作爲 list 看待,但允許其中一部分作爲函數來計算.

        1) ~,~ 用來標識 ~`~ 後面的這個 list 中,哪些部分被當做函數來看待. eg. `(a list of ,(+ 2 3) elements)

        2) ~,@~ 標識 ~`~ 後面的這個 list 中,哪些部分被當做函數來看待, 並且把計算結果拼接到整個 list 中.


     Backquote constructs allow you to quote a list, but selectively evaluate
     elements of that list. In the simplest case, it is identical to the special
     form quote (described in the previous section; see Quoting). For example,
     these two forms yield identical results:

     `(a list of (+ 2 3) elements)
     ⇒ (a list of (+ 2 3) elements)
     '(a list of (+ 2 3) elements)
     ⇒ (a list of (+ 2 3) elements)
     The special marker ‘,’ inside of the argument to backquote indicates a value that isn’t constant. The Emacs Lisp evaluator evaluates the argument of ‘,’, and puts the value in the list structure:

     `(a list of ,(+ 2 3) elements)
     ⇒ (a list of 5 elements)
     Substitution with ‘,’ is allowed at deeper levels of the list structure also. For example:

     `(1 2 (3 ,(+ 4 5)))
     ⇒ (1 2 (3 9))
     You can also splice an evaluated value into the resulting list, using the special marker ‘,@’. The elements of the spliced list become elements at the same level as the other elements of the resulting list. The equivalent code without using ‘`’ is often unreadable. Here are some examples:

     (setq some-list '(2 3))
     ⇒ (2 3)
     (cons 1 (append some-list '(4) some-list))
     ⇒ (1 2 3 4 2 3)
     `(1 ,@some-list 4 ,@some-list)
     ⇒ (1 2 3 4 2 3)

     (setq list '(hack foo bar))
     ⇒ (hack foo bar)
     (cons 'use
     (cons 'the
     (cons 'words (append (cdr list) '(as elements)))))
     ⇒ (use the words foo bar as elements)
     `(use the words ,@(cdr list) as elements)
     ⇒ (use the words foo bar as elements)

**** MESSY 理解學習的兩頭
     學習的兩頭就像,理解和頓悟

     理解 -------->         學習        <-------- 不理解,直接做

     理解, 是對自己解釋清楚爲什麼這麼做.道理是什麼,以求獲得自己的認可和許諾.
     直接做, 是直接做不問爲什麼.以求獲得像讀佛經一般的領悟,重在領悟,把相信暫時放在一邊.

     我尤其重理解, 這個方向是漸悟的方向.
     把不信任暫時放在一邊,就直接做.直接練,不多疑.是頓悟的方向.

     我在學機器學習時,堅持 *從底到上*,先學習概率/線代/微積分,就是[理解式學習].
     而 youtube 上,有很多直接介紹機器學習的視頻,就是直接做.以求在做中領悟
     這是 *從上到底* 的學習,是[頓悟式學習]

**** MESSY 問題是你準備讓 list 的哪些部分原樣不動,哪些部分求職,哪些部分拼接
     #+BEGIN_SRC lisp

;; 普通的 while loop
   (while (peek-char file nil nil)
          (write-char (read-char file)))

;; 用 goto 實現的 loop
   (tagbody
    start
      (if (not (peek-char file nil nil))
          (go end))
      (write-char (read-char file))
      (go start)
      end)

;; 定義爲宏的樣子
   (defmacro while-y (test &body body)
     (let ((gtop (gensym))
           (gend (gensym)))
       `(tagbody
           ,gtop
           (if (not ,test)
               (go ,gend))
           ,@body
           (go ,gtop)
           ,gend)))

     #+END_SRC

**** MESSY Fractran language, 初識
     Source: [2017-03-21 Tue], [[https://www.wikiwand.com/en/FRACTRAN][FRACTRAN - Wikiwand]]


     FRACTRAN
     Connected to: Sequence Esoteric programming language Formula for primes
     From Wikipedia, the free encyclopedia
     FRACTRAN is a Turing-complete esoteric programming language invented by the mathematician John Conway. A FRACTRAN program is an ordered list of positive fractions together with an initial positive integer input n. The program is run by updating the integer n as follows:

     for the first fraction f in the list for which nf is an integer, replace n by nf
     repeat this rule until no fraction in the list produces an integer when multiplied by n, then halt.
     In The Book of Numbers, John Conway and Richard Guy gave a formula for primes in FRACTRAN:[1][note 1]


     Starting with n=2, this FRACTRAN program generates the following sequence of integers:

     2, 15, 825, 725, 1925, 2275, 425, 390, 330, 290, 770, ... (sequence A007542 in the OEIS)
     After 2, this sequence contains the following powers of 2:

     (sequence A034785 in the OEIS)
     which are the prime powers of 2.

     Understanding a FRACTRAN program
     A FRACTRAN program can be seen as a type of register machine where the registers are stored in prime exponents in the argument n.

     Using Gödel numbering, a positive integer n can encode an arbitrary number of arbitrarily large positive integer variables.[note 2] The value of each variable is encoded as the exponent of a prime number in the prime factorization of the integer. For example, the integer


     represents a register state in which one variable (which we will call v2) holds the value 2 and two other variables (v3 and v5) hold the value 1. All other variables hold the value 0.

     A FRACTRAN program is an ordered list of positive fractions. Each fraction represents an instruction that tests one or more variables, represented by the prime factors of its denominator. For example:


     tests v2 and v5. If  and , then it subtracts 2 from v2 and 1 from v5 and adds 1 to v3 and 1 to v7. For example:


     Since the FRACTRAN program is just a list of fractions, these test-decrement-increment instructions are the only allowed instructions in the FRACTRAN language. In addition the following restrictions apply:

     Each time an instruction is executed, the variables that are tested are also decremented.
     The same variable cannot be both decremented and incremented in a single instruction (otherwise the fraction representing that instruction would not be in its lowest terms). Therefore each FRACTRAN instruction consumes variables as it tests them.
     It is not possible for a FRACTRAN instruction to directly test if a variable is 0 (However, an indirect test can be implemented by creating a default instruction that is placed after other instructions that test a particular variable.).
*** 2017-03-23 Thursday
**** MESSY how to set org-capture env for ubuntu         :ubuntu:org:capture:
     Source: [2017-03-23 四], [[https://github.com/sprig/org-capture-extension][sprig/org-capture-extension: A Chrome extension facilitating org-capture in emacs]]


     Register emacsclient as the org-protocol handler

     Under Linux
     #+BEGIN_SRC shell
   cat > "${HOME}/.local/share/applications/org-protocol.desktop" << EOF
   [Desktop Entry]
   Name=org-protocol
   Exec=emacsclient %u
   Type=Application
   Terminal=false
   Categories=System;
   MimeType=x-scheme-handler/org-protocol;
   EOF
     #+END_SRC

     And then (for non-KDE)

     #+BEGIN_SRC shell
   update-desktop-database ~/.local/share/applications/
     #+END_SRC

**** MESSY  [[https://linuxtoy.org/archives/gnu-info-intro.html][GNU info 简介 · LinuxTOY]]
     Captured On: [2017-03-23 四 21:44]
     顺便再列些 info 的快捷键：

     h info 教程
     q 退出 info，返回之前的缓冲区
     鼠标中键 follow 你点的那个节点
     回车	Follow 光标附近的节点，和鼠标中键差不多
     ^ 和 u 一样
     d 目录节点
     文件的最后一个节点
     TAB	把光标移动到下一个 cross-reference 或者菜单
     M-TAB 把光标移动到前一个 cross-reference 或者菜单
     L 历史记录
     T 当前 info 文件的目录
     b 节点头
     ,（逗号） 之前用 i 的下一条项目
     g 移动到 xxx 节点.
     1 .. 9 第 1...9 个 item（每三个 item 有一个高亮）
     c 把当前节点名放到 kill ring 里
     M-n 克隆一个 Info 缓冲区

**** MESSY Gun info introduction                                       :info:
     Source: [2017-03-23 四], [[https://linuxtoy.org/archives/gnu-info-intro.html][GNU info 简介 · LinuxTOY]]


     GNU info 简介
     2009-06-27 · By toy · Posted in Apps · 18 Comments
     {撰文/lvscar}

     前阵子开始学习 Lisp，找了一圈书籍文档后发现最适合的就藏在 Emacs 神器里 (Help-More Manuals-Introduction to Emacs Lisp)。;-)

     这份文档以 Textinfo 格式编排，info 程序或 Emacs 下的 info 模式是阅读 Textinfo 文档的标配。与之前熟悉的 man，html，pdf，chm 阅读体验相比，info 阅读有些门槛，得花点时间熟悉。

     相对于 man page;Textinfo 支持目录，层次化节点关系，节点间的交叉链接，(info 比 html 早两年被创造出来) 等结构化文档概念。这使得它更适合复杂文档或电子书。

     info 程序有自己的一套快捷键机制。熟悉了这套快捷键机制并在脑中有文档结构概念后，浏览文档会比在浏览器方便得多。以下是常用的几个:

     spc (空格)：向下滚屏，至末尾后进入下一个文档节点
     backspace (退格): 和空格相反，向上滚屏，至顶端后进入上一个文档节点
     l : 回朔浏览历史，等同于浏览器中的回退。
     n : 进入文档节点数中同级别的下一个节点 (*如果该节点包含子节点，n 会略过他们)
     p : 和 n 相反，进入文档节点数中同级别的上一个节点
     t：进入顶层结点
     u : 进入上一层节点
     b : 移动到本节点的顶端
     m : 如果节点包含目录 (往往是下一层节点的索引)。给出提示让你选择进入
     f : 如果节点包含交叉链接给出提示让你选择进入。(用 l 可以返回原节点)
     i : 列出正在看的文档的所有索引标题让你选择进入
     s : 对文档以你键入的词进行搜索。
     Linux 下的很多软件都包含有漂亮的 info 文档。下次 man 之前，不防 info 试试。

     依靠 Firefox 的 Mouseless 插件，浏览网页时基本上可以离开鼠标。可由于 html 中没有上下级结构，浏览只能是视觉驱动。而在 info 里，浏览过程能转换成结构驱动。我很喜欢这种体验。

     就像以 CLI 替代 GUI 进行 OS 操作，付出学习成本，你能收获更多。
*** 2017-03-25 Saturday
**** some hotkeys of ubuntu                                   :ubuntu:hotkey:
     # 清理旧版本的软件缓存
     sudo apt-get autoclean
     #
     # 清理所有软件缓存
     sudo apt-get clean
     #
     # 删除系统不再使用的孤立软件
     sudo apt-get autoremove
**** some bugs about sogou pin                                 :ubuntu:sogou:
     问题说明参见
     http://pinyin.sogou.com/bbs/forum.php?mod=viewthread&tid=2676147&extra=&page=1
     参考其回复后可知
     删除~/.config 目录下的 SogouPY、SogouPY.users、sogou-qimpanel 三个文件夹即可恢复正常
     参考链接如下
**** concept about source in ubuntu

     sure that for every deb
     entry in /etc/apt/sources.list and /etc/apt/sources.list.d/*, you have a
     matching deb-src … entry. The rest of the line must be identical. The deb entry
     is for binary packages (i.e. ready to install), the deb-src is for source
     packages (i.e. ready to compile). The reason why the two kinds of sources are
     separated is that they are managed very differently: binary packages have a
     dependency tracking mechanism and a currently-installed list, whereas source
     packages are only tracked so that they can be downloaded conveniently. Note that
     when discussing package repositories, the word source means two unrelated
     things: a source as in a location to download packages from, and a source
     package as opposed to a binary package.

     libgtk2.0-0 is the name of a binary package. It is built from a source package
     called gtk+2.0. The reason source and binary package names don't always match is
     that building a source package can produce multiple binary packages; for
     example, gtk+2.0 is the source for 14 packages as it is split into two libraries
     (libgtk2.0, libgail), corresponding packages to build programs using these
     libraries (…-dev), documentation for developers (…-doc), companion programs
     (libgtk2.0-bin`), etc.

     You can see the name of the source package corresponding to a binary package by
     checking the Source: … line in the output of dpkg -s BINARY_PACKAGE_NAME (if the
     package is installed) or apt-cache show BINARY_PACKAGE_NAME. You can list the
     binary packages produced by a source package with aptitude search
     '?source-package(^SOURCE_PACKAGE_NAME$).

     The command apt-get source downloads a source package. If you give it an
     argument which isn't a known source package, it looks it up in the database of
     installable binary packages and tries to download the corresponding source
     package. The command apt-get build-dep follows the same approach to deduce the
     name of a source package, then queries the source package database to obtain a
     list of binary packages (the list in the Build-Dep: field), and installs those
     binary packages.

     The Software Sources GUI has a checkbox “enable repositories with source code”
     for official repositories, make sure that it's ticked. If you add third-party
     repositories manually, make sure that you add both deb-src and deb lines.
**** an exapmle to use ditaa and artist mode                   :ditaa:artist:

     http://ditaa.sourceforge.net

     #+BEGIN_SRC ditaa :file test.png :cmdline -r -s 0.8
+-----------+        +------------+
|   PLC     |        |    PLC     |
|  network  +<------>+    c707    +<----=--------+
|   cRED    |        |            |              |
+-----------+        +-----+------+              |
                           ^                     |
                           |                     |
                           |                     |
                           |                     |
                           |  +------------------|---------------------+
                           |  |                  |                     |
                           v  v                  V                     |
+-----------+        +-----+--+---+          +---+------+       +------+-----+      +-------------+          Windows clients
|  Database |        |  Shared    |          |          |       |            |      |    Operator |       +---------+     +---------+
|  c707     +<------>+ Memory     +<-------->+ Executive+<----->+  Executive +<---->+    Server   +<----->+  cYEL   +-----+  cYEL   |
|           |        |  {d} cGRE  |          | c707     |       |    c707    |      |     c707    |       |         |     |         |
|           |        |            |          |          |       |            |      |             |       +---------+     +---------+
+--+----+---+        +------------+          +----+-----+       +------------+      +-------------+
   ^    |                                         |
   |    |                                         |
   |    +-----------------------------------------+
   v
+--+--------------------+
|                       |
|  millwide system      |
|   cBLU                |
+-----------------------+

     #+END_SRC

     #+RESULTS:
     [[file:test.png]]

**** another example to use ditaa and artist mode              :ditaa:artist:
     Artist mode is a great mode that lets you draw ASCII art with your mouse, this
     is super handy for generating all those ASCII art diagrams you wanted to make in
     your code.

     It's even more handy when you combine it with Ditaa, which stands for "DIagrams
     Through Ascii Art". Let's play around with org-mode and ditaa, so we need to
     ensure it's loaded as a valid language:

     (Also make sure you install it with homebrew, or apt, or dnf, or whatever)

     (org-babel-do-load-languages
     'org-babel-load-languages
     '((ditaa . t)))

     ;; This happened to be the directory it gets installed with Fedora
     (setq org-ditaa-jar-path "/usr/share/java/ditaa.jar")

     Now, let's play!

***** Boxes
      #+BEGIN_SRC ditaa :file box.png :cmdline -r -s
+-------+
|       |
| A box |
+-------+
      #+END_SRC

      #+RESULTS:
      [[file:box.png]]

      - You can color boxes by "cNNN" where NNN are RGB codes:
      #+BEGIN_SRC ditaa :file RGB_box.png
/---------\   +----------+   +---------\
| c243    |   | cRED     |   |         |
|         |   |          |   |         |
|         |   |          |   |         |
\---------/   +----------+   +---------/
      #+END_SRC

      #+RESULTS:
      [[file:RGB_box.png]]

      - There's also different types of boxes depending on the type

      #+BEGIN_SRC ditaa :file kinds_of_boxes.png
+----------+  +---------+  +--------------+
|{d}       |  |{s}      |  |{io}          |
|          |  |         |  |              |
| Document |  | Storage |  | Input/Output |
|          |  |         |  |              |
+----------+  +---------+  +--------------+
      #+END_SRC

      #+RESULTS:
      [[file:kinds_of_boxes.png]]

***** Lines

      - In addition to boxes, you can of course draw arrows or lines
      #+BEGIN_SRC ditaa :file line
+--------+          +---------+
|        |          |         |
|   A    +----------+    B    |
|        |          |         |
+--------+          +----+----+
                         ^
                         |
                         +------+
                                |
          +--------+     /------+
          |        |     |
          |   C    +<----/
          |        |
          |        |
          +--------+
      #+END_SRC

      #+RESULTS:
      [[file:line]]

      - You can also add points to lines and boxes:
      #+BEGIN_SRC ditaa :file line-with-point.png
+--------+          +---------+
|        |          |         |
|        *          |         *
|        |          |         |
+--------+          +---+-----+
     ^                  |
     |                  |
     |                  *
     \------*-----------+

      #+END_SRC

      #+RESULTS:
      [[file:line-with-point.png]]

      - And finally, you can make anything dotted by putting either : or = in it, like so:
      #+BEGIN_SRC ditaa :file dash-line.png
+----------+            +------------+
| cGRE     |            |            |
|   Box A  +----+-------+            |
|          |    |       |            :
|          |    |       | Thing      |
+----------+    |       +------------+
                |
                |
                |          +----------+
                |          | {s}      |
                |          |          |
                +------=-->| Storage  |
                           |          |
                           |          |
                           +----------+

      #+END_SRC

      #+RESULTS:
      [[file:dash-line.png]]

**** intro to plantuml
     http://plantuml.com/
*** 2017-03-26 Sunday

**** MESSY a git to automatically handle git
     Source: [2017-03-26 Sun], [[http://doc.norang.ca/org-mode.html#OrgIndentMode][Org Mode - Organize Your Life In Plain Text!]]


     #!/bin/sh
     # Add org file changes to the repository
     REPOS="org doc.norang.ca www.norang.ca"

     for REPO in $REPOS
     do
     echo "Repository: $REPO"
     cd ~/git/$REPO
     # Remove deleted files
     git ls-files --deleted -z | xargs -0 git rm >/dev/null 2>&1
     # Add new files
     git add . >/dev/null 2>&1
     git commit -m "$(date)"
     done

**** intro to shell
     You can redirect the output of processes directly to buffers by using a special syntax:

     ~cat log.txt | grep "foo" >> #<buffer *scratch*>~
     Additionally, if you set eshell-buffer-shorthand to t you can use a shorthand for the buffers:

     ~cat log.txt | grep "bar" >> #'*scratch*~
**** how to setup a alias in oh-my-zsh                            :zsh:alias:
     There must not be any whitespaces around between = and either alias name or alias definition:

     alias zshconfig="mate ~/.zshrc"
     alias ohmyzsh="mate ~/.oh-my-zsh"
     alias n="nano"
     alias m="mkdir"
     alias w="cd ~/Documents/UoMWorkspace/Semester2"
     alias j="cd ~/Documents/UoMWorkspace/Semester2/COMP17412"

**** MESSY  What does > /dev/null 2>&1 mean?              :redirection:shell:
     Source: [2017-03-26 Sun], [[https://www.xaprb.com/blog/2006/06/06/what-does-devnull-21-mean/][What does > /dev/null 2>&1 mean? · Baron Schwartz's Blog]]


     What does > /dev/null 2>&1 mean?
     Tue, Jun 6, 2006 in Programming
     I remember being confused for a very long time about the trailing garbage in commands I saw in Unix systems, especially while watching compilers do their work. Nobody I asked could tell me what the funny greater-thans, ampersands and numbers after the commands meant, and search engines never turned up anything but examples of it being used without explanation. In this article I’ll explain those weird commands.

     Here’s an example command:

     wibble > /dev/null 2>&1
     Output redirection
     The greater-thans (>) in commands like these redirect the program’s output somewhere. In this case, something is being redirected into /dev/null, and something is being redirected into &1.

     Standard in, out, and error
     There are three standard sources of input and output for a program. Standard input usually comes from the keyboard if it’s an interactive program, or from another program if it’s processing the other program’s output. The program usually prints to standard output, and sometimes prints to standard error. These three file descriptors (you can think of them as “data pipes”) are often called STDIN, STDOUT, and STDERR.

     Sometimes they’re not named, they’re numbered! The built-in numberings for them are 0, 1, and 2, in that order. By default, if you don’t name or number one explicitly, you’re talking about STDOUT.

     Given that context, you can see the command above is redirecting standard output into /dev/null, which is a place you can dump anything you don’t want (often called the bit-bucket), then redirecting standard error into standard output (you have to put an & in front of the destination when you do this).

     The short explanation, therefore, is “all output from this command should be shoved into a black hole.” That’s one good way to make a program be really quiet!

     2>&1: it means 2(stderr) is redirected to &1. & tells the address (fd) of 1(stdout). so the stderr is redirected to stdout.
     2&>1: it means 2 that is nothing will get executed in bg because of &. And the output will be redirected to a file named 1 not the stdout.

     to answer you Aman Jain I think that:
     1) "wibble > /dev/null 2>1" stdout is redirected to /dev/null and stderr is redirected to a file named "1" (in the current directory)
     2) "wibble > /dev/null 2>&1" stdout is redirected to /dev/null and stderr is redirected to where stdout is redirected (bit bucket)
     3) "wibble > /dev/null &2>1" stdout is redirected to /dev/null , then character "&" comes, which means that this process will run in background(parallel with the shell u are using). Then comes 2>1 which will create an empt file with the name 1.
     And FINALLY!!!
     4) "wibble > /dev/null &2>&1" stdout is redirected to /dev/null. "&" means that, that process(wibble) will run in background(with stdout redirected only).Then another process is started with 2>&1 which creates no file.
     U can try it. Maybe im wrong somewhSo logically that means you could catch STDERR from the command line by appending "2>>/var/log/logfile" to a shell command.

     So, where "2" is STDERR, ">>" is to append and "/var/log/logfile" is the where errors will be logged.ere, Hey im not Steve Bourne(author of sh) ;)

**** MESSY timer program in emacs
     Source: [2017-03-26 Sun], [[http://doc.norang.ca/org-mode.html#OrgIndentMode][Org Mode - Organize Your Life In Plain Text!]]


     My Emacs setup saves all org buffers at 1 minute before the hour using the following code in my .emacs

     (run-at-time "00:59" 3600 'org-save-all-org-buffers)

**** MESSY tractable : easy to handle with                          :ENGLISH:
     Source: [2017-03-26 Sun], [[http://malisper.me/][Macrology - Case Studies in Lisp Macros]]


     _Although_ programming Fractran is _still_ difficult,
     this technique _suddenly_ makes writing Fizzbuzz in Fractran *tractable*.
*** 2017-03-27 Monday

**** MESSY how to convert latex code to corresponding png directly in org file
     i get a glance this pow in
     https://www.youtube.com/watch?v=cRUCiF2MwP4
     In that video of youtube, it convet a latex code directly in org file, to
     a png. so, i find some information below:

     1. org has a extension package called: ~org-plus-contrib~, which preload in spacemacs.
     2. this pkg has an ~org-compat.el~ file
     3. this file has a function: ~org-toggle-latex-fregment~ combind to ~C-c C-x C-l~
     4. this function can convert a line of latex code to png.
     5. need install *dvipng* in linux
     6. this will enhance the *org note* largely instead of *OneNote*

     $P_{net}=r_1^2 - r_2^2$
     $P_{net}=r_1^2 - r_2^2$

**** MESSY how to convert or extract mp3 from mp4 or mpeg or other video format :ubuntu:
     Source: [2017-03-27 Mon], [[http://blog.csdn.net/u012377333/article/details/38581477][关于 ffmpeg 的总结（一个 linux 下 集 屏幕录像录音，音频视频转换，合并音频视频文件，格式转换于一身的命令） - chisj 专栏 - 博客频道 - CSDN.NET]]


***** emerge ffmpeg

     格式转换 (将 file.avi 转换成 output.flv)

     ffmpeg -i file.avi output.flv

      -i 表示输入文件

      :现在有个视频 video.avi，有个音频 audio.mp3，将其合并成 output.avi

     两个命令                     （video2.avi 是中间文件 ，用完可删）

     ffmpeg -i video.avi -vcodec copy -an video2.avi   
     ffmpeg -i video2.avi -i audio.mp3 -vcodec copy -acodec copy output.avi

      -i 表示输入文件

       -vcodec copy 表示 force video codec ('copy' to copy stream) 这个不知怎么译 ，估计是直接 copy 
       -acodec copy   这个说的应该是音频了   跟上面一样
     -an : 表示  disable audio  估计是 audio no 之类的缩写   表示去掉 video.avi 原有的音频

     方法 2 好像可以直接指定两个输入文件 ，

     ffmpeg -i /tmp/a.wav -i /tmp/a.avi /tmp/a.avi 两个文件 的顺序很重
     从视频里提取声音（声音与视频的分离）

: ffmpeg -i 人生若只如初见.flv -vn r.mp3  从 flv 文件 中提取声音并保存为 mp3 格式  

      -vn : 表示忽略视频 估计是 video no 之类的缩写

: ffmpeg -i 人生若只如初见.flv -an r.flv 只留视频不留声音

      -an : 表示忽略声音 估计是 audio no 之类的缩写



     从视频里提取图片（ ）

     ffmpeg -i test.avi -y -f image2 -ss 8 -t 0.001 -s 350x240 test.jpg 
     -ss 第 8 秒处 截一图
     压缩 mp3 文件

     如果你觉得 mp3 文件 有点大，想变小一点那么可以通过-ab 选项改变音频的比特率（bitrate）

     ffmpeg -i input.mp3 -ab 128 output.mp3    //这里将比特率设为 128

     你可以用 file 命令查看一下源文件 的信息

     z.mp3: Audio file with ID3 version 2.3.0, contains: MPEG ADTS, layer III, v1, 192 kbps, 44.1 kHz, Stereo

     其中的 192 kbps 就是这个东西

     mp3 中比特率的含义是：在压缩音频文件至 mp3 时，由压缩软件所确定数码文件在播放时每秒传 送给播放器大小，其单位是：千位/秒；英文的含义是：kbps - = kilobits per second。现在 mp3 文件的最高数位率是 320 kbps。这样的文件体积很大，每分钟的音乐超过两兆字节。如果采用可变比特率（VBR）编码来生成 mp3 文件，获得与 320 kbps 相当音质，文件的体积会缩小 25~50%。请注意：播放时间相同，而歌曲不同，所获的压缩 mp3 文件的一般不相同，这是因为 VBR 编码所生成的 mp3 文件的大小不仅仅取决于播放时间的长度，还取决于源音频文件的其它因素。



     录音（要有可用的麦克风，并且如果用 alsa 的话，好像得安 alsa-oss，重启） 

      ffmpeg  -f oss -i /dev/dsp   out.avi  (should  hava oss or alsa-oss)

      ffmpeg   -f  alsa -ac 2 -i hw:0, 0  out.avi   (should )

      ffmpeg   -f alsa -ac 2 -i pulse  (should hava PulseAudio)

        oss 是 Linux 下的声音相关的东西，与 alsa 一样，不过 oss 是商业的， 而/dev/dsp 是 oss 用到的麦克的设备吧，可以这样理解

     屏幕录像

     ffmpeg -f x11grab -s xga -r 10 -i :0.0+0+0 wheer.avi 

     ffmpeg -f x11grab  -s 320x240  -r 10 -i :0.0+100+200 wheer.avi

     :0:0 表示屏幕（个人理解，因为系统变量$DISPLAY 值就是:0.0）  而 100,表示距左端 100 象素，200 表示距上端 200

     -s 设置窗口大小

       -r 10 好像是设置频率，不懂

     ffmpeg -f x11grab -s xga    -qscale 5    -r 10 -i :0.0+0+0 wheer.avi 

     -qscale 8 设定画面质量，值 越小越好

     屏幕录像，同时录音

     ffmpeg -f oss -i /dev/dsp        -f x11grab -r 30 -s 1024x768 -i :0.0  output.mkv

     ffmpeg   -ac 2 -f oss  -i  /dev/dsp   -f x11grab -r 30 -s 1024x768 -i :0.0 -acodec pcm_s16le -vcodec libx264 -vpre lossless_ultrafast -threads 0 output.mkv

     看到这，你会发现这个命令有多强大，

     如果我屏幕上打开了一个窗口，我只想录这个窗口的内容，如何确定这个窗口的坐标位置呢

     可以用另外一个命令

     xwininfo 输入这个命令后，用鼠标点选目标窗口，

     就会出现目标窗口的坐标，宽高等一系列信息

     Absolute upper-left X:  276
       Absolute upper-left Y:  57
       Relative upper-left X:  2
       Relative upper-left Y:  23
       Width: 742
       Height: 499
       Depth: 24
       Visual: 0x21
       Visual Class: TrueColor
       Border width: 0
       Class: InputOutput
       Colormap: 0x20 (installed)
       Bit Gravity State: NorthWestGravity
       Window Gravity State: NorthWestGravity
       Backing Store State: NotUseful
       Save Under State: no
       Map State: IsViewable
       Override Redirect State: no
       Corners:  +276+57  -262+57  -262-244  +276-244
       -geometry 80x24+274+34 看到这一行了没 (）

     比如根据上面的信息

     ffmpeg -f oss  -i  /dev/dsp      -f  x11grab -r 30  -s 1280x752 -i :0.0+0+23  output.avi 
     Another thing you can change is the video frame rate (FPS). In the example above we used -r 30 which means capture at 30 FPS. You can change this value to whatever frame rate you want.

     这个 -r 30 应该是每秒钟取样几次，估计是一秒截三十次屏，

***** 切头去尾

     ffmpeg -ss 00:00:10 -t 00:01:22 -i 五月天-突然好想你.mp3  output.mp3 

     只要 从第 10 秒开始截取，共截取 1：22 时长的内容

     视频文件的连接，如两个 flv 文件 连接成一

     好像必须先将文件 转成 mpg，dv 等格式的文件后才能进行连接

     连接复数的 AVI 影片档之范例（在此范例中须一度暂时将 AVI 档转换成 MPEG-1 档(MPEG-1, MPEG-2 PS, DV 格式亦可连接)）
     ffmpeg -i input1.avi -sameq inputfile_01.mpg -r 20
     ffmpeg -i input2.avi -sameq inputfile_02.mpg -r 20
     cat inputfile_01.mpg inputfile_02.mpg > inputfile_all.mpg
     ffmpeg -i inputfile_all.mpg -sameq outputfile.avi 上面将 input1.avi input2.avi 合并成 outputfile.avi -sameq 表示 相同的质量（可能指的是画面，不太清楚）
     -r 指频率 

     =====================================================================下面是 wiki 上给的几个例子
     参数
     FFmpeg 可使用众多参数，参数内容会根据 ffmpeg 版本而有差异，使用前建议先参考参数及编解码器的叙述。此外，参数明细可用 ffmpeg -h 显示；编解码器名称等明细可用 ffmpeg -formats 显示。

     下列为较常使用的参数。

     [编辑 ] 主要参数
     -i 设定输入档名。
     -f 设定输出格式。
     -y 若输出档案已存在时则覆盖档案。
     -fs 超过指定的档案大小时则结束转换。
     -ss 从指定时间开始转换。
     -title 设定标题。
     -timestamp 设定时间戳。
     -vsync 增减 Frame 使影音同步。
     [编辑 ] 影像参数
     -b 设定影像流量，默认为 200Kbit/秒。（ 单位请参照下方注意事项 ）
     -r 设定 FrameRate 值，默认为 25。
     -s 设定画面的宽与高。
     -aspect 设定画面的比例。
     -vn 不处理影像，于仅针对声音做处理时使用。
     -vcodec 设定影像影像编解码器，未设定时则使用与输入档案相同之编解码器。
     [编辑 ] 声音参数
     -ab 设定每 Channel （最近的 SVN 版为所有 Channel 的总合）的流量。（ 单位 请参照下方注意事项 ）
     -ar 设定采样率。
     -ac 设定声音的 Channel 数。
     -acodec 设定声音编解码器，未设定时与影像相同，使用与输入档案相同之编解码器。
     -an 不处理声音，于仅针对影像做处理时使用。
     -vol 设定音量大小，256 为标准音量。(要设定成两倍音量时则输入 512，依此类推。)
     [编辑 ] 注意事项
     以-b 及 ab 参数设定流量时，根据使用的 ffmpeg 版本，须注意单位会有 kbits/sec 与 bits/sec 的不同。（可用 ffmpeg -h 显示说明来确认单位。）
     例如，单位为 bits/sec 的情况时，欲指定流量 64kbps 时需输入‘ -ab 64k ’；单位为 kbits/sec 的情况时则需输入‘ -ab 64 ’。
     以-acodec 及-vcodec 所指定的编解码器名称，会根据使用的 ffmpeg 版本而有所不同。例如使用 AAC 编解码器时，会有输入 aac 与 libfaac 的情况。此外，编解码器有分为仅供解码时使用与仅供编码时使用，因此一定要利用 ffmpeg -formats 确 认输入的编解码器是否能运作。
     [编辑 ] 范例
     将 MPEG-1 影片转换成 MPEG-4 格式之范例
     ffmpeg -i inputfile.mpg -f mp4 -acodec libfaac -vcodec mpeg4 -b 256k -ab 64k outputfile.mp4
     将 MP3 声音转换成 MPEG-4 格式之范例
     ffmpeg -i inputfile.mp3 -f mp4 -acodec libaac -vn -ab 64k outputfile.mp4
     将 DVD 的 VOB 档转换成 VideoCD 格式的 MPEG-1 档之范例
     ffmpeg -i inputfile.vob -f mpeg -acodec mp2 -vcodec mpeg1video -s 352x240 -b 1152k -ab 128k outputfile.mpg
     将 AVI 影片转换成 H.264 格式的 M4V 档之范例
     ffmpeg -i inputfile.avi -f mp4　-acodec libfaac -vcodec libx264 -b 512k -ab 320k outputfile.m4v
     将任何影片转换成东芝 REGZA 可辨识的 MPEG2 格式之范例
     ffmpeg -i inputfile -target ntsc-svcd -ab 128k -aspect 4:3 -s 720x480 outputfile.mpg
     连接复数的 AVI 影片档之范例（在此范例中须一度暂时将 AVI 档转换成 MPEG-1 档(MPEG-1, MPEG-2 PS
     DV 格式亦可连接)、
     ffmpeg -i input1.avi -sameq inputfile_01.mpg
     ffmpeg -i input2.avi -sameq inputfile_02.mpg
     cat inputfile_01.mpg inputfile_02.mpg > inputfile_all.mpg
     ffmpeg -i inputfile_all.mpg -sameq outputfile.avi
     =============================================================================
     http://ffmpeg.org/ffmpeg-doc.html 
     http://ubuntuforums.org/showthread.php?t=1392026 
     同时搞明白的一些问题
     在 alsa 体系中声卡（也可能是麦克风，）叫 hw:0,0 而在 oss 体系中叫/dev/dsp (用词可能不太专业)  Linux 在安装了声卡后，会有一些设备文件生

     成。 

       采集数字样本的 
     /dev/dsp 文件，针对混音器的 
     /dev/mixer 文件，用于音序器的 
     /dev/sequencer， 
     /dev/audio 文件一个 



     基于兼容性考虑的声音设备文件。只要向 
     /dev/audio 中输入 
     wav 文件就能发出声音。而对 
     /dev/dsp 文件读取就能得到 
     WAV 文件格式的声音文 
     件。 

**** MESSY 3 methods to convert mp4 to mp3              :ubuntu:videoConvert:
     Source: [2017-03-27 Mon], [[http://tieba.baidu.com/p/838513625][linux 下转 flv 为 mp3 格式的方法_linux 吧_百度贴吧]]


     方法一：在安装到有 mplayer 的情况下可以使用命令
         mplayer -dumpaudio filenametoconvert.flv -dumpfile filenametosave.mp3
         如我要将下载下来的 aa11.flv 转换为 bb22.mp3 则使用以下命令
         mplayer -dumpaudio aa11.flv -dumpfile bb22.mp3
     方法二：使用 vlc 中转换工具 位置在菜单栏中的文件／媒体（media） 转换／保存（convert／save） 在顶部选择文件（file） 文件选择（file selection）中点添加（add） 加入要转换的文件 然后点转换／保存（convert／save）按钮前面的箭头符号 选择转换 convert 进入转换对话框 在目标 destination 一栏选择转换后的路径 在设置中选择 audio－mp3 点后面的第一个图标设置转换 mp3 的参数（仅设置音频解码器 audec，主要是修改比特率 bitrate 和采样率 sample rate） 比特率一般设为 128 采样率为 44100 设置好后点保存 点开始 start 开始转换
     方法三：使用 ffmpeg 转换
     ffmpeg -i inputfile.flv -acodec copy output.mp3
     如我要将下载下来的 aa11.flv 转换为 bb22.mp3 则使用以下命令
     ffmpeg -i aa11.flv -acodec copy bb22.mp3
     此方法仅适合音频编码为 mp3 的情况（在命令行模式运行 mplay aa11.flv 在 open audio 一行显示 Opening audio decoder: [mp3lib] MPEG layer-2, layer-3
     ）

**** MESSY how to traverse all files of a directory
     Source: [2017-03-27 Mon], [[http://www.cnblogs.com/kaituorensheng/archive/2012/12/19/2825376.html][shell 编程--遍历目录下的文件 - jihite - 博客园]]


     shell 编程--遍历目录下的文件

     假定目录 text 下有如下文件
           目录：dir_1、dir_2、dir_3

           文件：text_1、text_2

     遍历目录下所有的文件是目录还是文件

     if -- if 类型：
     #+BEGIN_SRC shell
   #!bin/sh
   for file in ./*
   do
       if test -f $file
       then
           echo $file 是文件
       fi
       if test -d $file
       then
           echo $file 是目录
       fi
   done
     #+END_SRC

     if --else 类型:
     #+BEGIN_SRC shell
   #!bin/sh
   for file in ./*
   do
       if test -f $file
       then
           echo $file 是文件
       else
           echo $file 是目录
       fi
   done

     #+END_SRC

     #+BEGIN_SRC shell
#!/bin/bash

for file in ./*
do
   exiftool $file | grep File\ Name >>>list.txt
   echo >>list.txt
   exiftool $file | grep Media\ Duration >>>list.txt
done

     #+END_SRC
*** 2017-03-28 Tuesday

**** MESSY  手机挂载点在 linux 什么位置
     Source: [2017-03-28 Tue], [[http://blog.csdn.net/caz28/article/details/50903018][Ubuntu 下 MTP 设备的挂载目录 - caz28 的专栏 - 博客频道 - CSDN.NET]]


     我用的是 Ubuntu14.04，连接手机后，会自动连接 MTP，从桌面文件管理器可以很快访问手机，查看属性，其位置为 mtp://[usb:003,xxx]/，但是不知道怎么从命令行界面进入这个位置。
     经查找发现其挂载目录为：
     /run/user/$UID/gvfs/mtp:host=xxxxxxx
     这个路径可以从命令行界面进入。

**** MESSY  how to mount the android mpt in linux (failed to my samsung s7e)
     Source: [2017-03-28 Tue], [[http://blog.csdn.net/wfing/article/details/17524583][在 linux 下挂载 android 的 mtp 设备 - linux 内核探索 - 博客频道 - CSDN.NET]]


     mtp 应该是 Android 的 4.0 以上版本的新功能。取代了传统的Ｕ盘挂载方式。

     以下照抄原文：　http://www.miui.com/thread-960449-1-1.html

     Android3.x 以上使用了 MTP 协议连接移动设备的内部存储，在 Windows 上可以很方便的打开 MTP 设备，而在 Mac 上 google 提供了一个工具 “Android File Transfer”（http://www.android.com/filetransfer/），却唯独无视了 Linux 用户（难道是认为 Linux 用户动手能力足够强大？）。
     之前在 Ubuntu 上向 Galaxy Nexus 传输文件都是在手机的“USB 计算机连接”中改为使用 PTP 协议，但这个只能传输照片。因此挂上 MTP 才是王道。操作方法如下：
     1.安装必备的软件：sudo apt-get install mtpfs libfuse-dev libmad0-dev
     2.创建挂载点：sudo mkdir /media/mtp
     3.修改为目录所有者为自己，以便有读写权限：sudo chown 你的用户名 /media/mtp
     4.确认当前用户在 fuse  组中：System > Administration > Users and Groups > Manage Groups > fuse > properties，确保勾选了自己的用户名。
     5.挂载设备：mtpfs /media/mtp。用文件管理器访问，和操作同本地目录一样。
     6.卸载设备：fusermount -u /media/mtp

     请注意的是：
     usermod -a -G groupA user
     加上-a append，把一个用户加入组
     (FC4: usermod -G groupA,groupB,groupC user)
     -a 代表 append， 也就是 将自己添加到 用户组 groupA 中，而不必离开 其他用户组。 

     这样就可以通过ＵSB 操作 android 上的一些文件了。
*** 2017-03-29 Wednesday

**** MESSY 真的是‘绝知此事要躬行’，只有在做的过程中，某些灵感才会出现。
就拿今天擦窗户轨道的石子，就能看出，当我不动手去干的时候，这叫 *干想* 。
这个时候的方法往往非常脱离现实的细节，只有真正上手了，一些现实的琐碎细节
才能 *激发* 内心的灵感，才会有办法解决，这时候调动的不只是大脑，而是全身
的细胞去 *体悟* 。 这才能真正发现或发明或解决问题。
*** 2017-03-31 Friday

**** MESSY how to setup chinese source of PIP python install     :python:pip:
   Source: [2017-03-31 Fri], [[http://www.cnblogs.com/microman/p/6107879.html][让 PIP 源使用国内镜像，提升下载速度和安装成功率。 - microman - 博客园]]

:ISSUE:
PIP install 安装经常链接超时，失败
:END:
:SOLVE:
让 PIP 源使用国内镜像，提升下载速度和安装成功率。
:END:

   让 PIP 源使用国内镜像，提升下载速度和安装成功率。

   对于 Python 开发用户来讲，PIP 安装软件包是家常便饭。但国外的源下载速度实在太慢，浪费时间。而且经常出现下载后安装出错问题。所以把 PIP 安装源替换成国内镜像，可以大幅提升下载速度，还可以提高安装成功率。

   国内源：

   新版 ubuntu 要求使用 https 源，要注意。

   清华：https://pypi.tuna.tsinghua.edu.cn/simple

   阿里云：http://mirrors.aliyun.com/pypi/simple/

   中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/

   华中理工大学：http://pypi.hustunique.com/

   山东理工大学：http://pypi.sdutlinux.org/ 

   豆瓣：http://pypi.douban.com/simple/

   临时使用：

   可以在使用 pip 的时候加参数-i https://pypi.tuna.tsinghua.edu.cn/simple

   例如：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider，这样就会从清华这边的镜像去安装 pyspider 库。
    

   永久修改，一劳永逸：

   Linux 下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)

   内容如下：
#+BEGIN_QUOTE
   [global]
   index-url = https://pypi.tuna.tsinghua.edu.cn/simple
   [install]
   trusted-host=mirrors.aliyun.com
#+END_QUOTE
   windows 下，直接在 user 目录中创建一个 pip 目录，如：C:\Users\xx\pip，新建文件 pip.ini。内容同上。

**** MESSY 其实没有那么多的成年人，你也不要把所有成年人都当成年人看
当你不把他看做成年人时，反倒可以理解一些想法和行为模式；
** 2017-04 April
*** 2017-04-01 Saturday

**** MESSY update kernel, come up against 'missing initramfs' problem :ubuntu:initramfs:
   Source: [2017-04-01 Sat], [[http://askubuntu.com/questions/898449/kernel-panic-and-unable-to-boot-ubuntu-16-04-after-updating/898459][updates - Kernel panic and unable to boot Ubuntu 16.04 after updating - Ask Ubuntu]]
:ISSUE:
when update from kernle 4.4.0-70 to 4.4.0-71,then i cannot install
anything by sudo apt-get install. In my ele-os:
#+BEGIN_QUOTE
~  sudo dpkg --configure -a
Setting up linux-image-4.4.0-71-generic (4.4.0-71.92) ...
Running depmod.
sh: 1: /usr/sbin/update-initramfs: not found
Failed to create initrd image.
#+END_QUOTE
:END:
:SOLVE:
   You are missing the initramfs for kernel version 4.8.0-44.

   It looks like you got a kernel panic error message after updating the kernel
   in Ubuntu 16.04.1 to 4.8.0-44-generic. To fix it enter a text-only console
   and either replace 4.8.0-44-generic with the more stable default kernel
   version or run

   ~sudo update-initramfs -u -k 4.8.0-44-generic && sudo update-grub.~

   After the boot stops at the black screen, open a text-only console by using the keyboard shortcut Ctrl+Alt+F1
   At the login: prompt type your username and press Enter.
   At the Password: prompt type your user password and press Enter.
   After you have logged in in the console type:

   ~sudo apt remove linux-image-4.8.0-44-generic linux-image-extra-4.8.0-44-generic linux-headers-4.8.0-44-generic~
   ~sudo apt install linux-image-4.4.0-71-generic linux-headers-4.4.0-71 linux-headers-4.4.0-71-generic~
   ~sudo reboot~

   Alternatively you can run the following commands to update initramfs for kernel version 4.8.0-44-generic :

   ~sudo update-initramfs -u -k 4.8.0-44-generic~
   ~sudo update-grub~

   When the computer reboots wait until the manufacturer's splash screen
   disappears, then press the Shift key to show the GRUB boot options. From the
   purple GRUB screen select Advanced options for Ubuntu and press Enter. A new
   purple screen will appear showing a list of kernels. Select Ubuntu, with
   Linux 4.4.0-71-generic and press Enter. Ubuntu will load the selected kernel
   and proceed to the login screen as usual. Don't let Ubuntu update the kernel
   to the 4.8.0-44 version that caused the black screen again, or else you'll
   get the same black screen problem that you got before.

:END:

**** MESSY 这个世界上有些原本就属于“混沌”的东西，就不要把他清晰化
:DIARY:
1. 两个好事者，发现了一个叫做‘混沌’的东西，他们觉得混沌好可怜啊，
没有一窍一感，体验不到这个花花世界的美好，遂相约每天为混沌开
一窍，第 7 天混沌死了。。。。。

2. 语言是不足以概括万事万物的，更多的东西无法用语言描述，一旦描述必然
丢失很多精度。这也是古汉语和现在汉语的区别。

3. 一开始投篮挺准的，当有一天总结投篮技巧，一条条写下来的时候，反而
投篮都没那么准了

:END:
*** 2017-04-05 Wednesday

**** MESSY  [[https://pan.baidu.com/disk/home#list/vmode=list&path=/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6/Matlab%20R2016a][Matlab 2016 crack version]]                                :matlab:
   Captured On: [2017-04-05 Wed 20:37]
*** 2017-04-06 Thursday

**** MESSY bank id card
:ID:
| cmb | 6225,7583,4006,8278 | credit card      |
| cmb | 4515,         ,3940 | credit card visa |
| cmb | 6214,         ,8937 |                  |
:END:

**** MESSY 自学 ML 得失总结
1. 不应该埋头造车，应该每学一段时间，就去面试几次；
   1. 我一直埋头学这学那，丝毫不知道现在业界需要什么样的人才，会面试什么东西，可以说毫无重点
2. 应该先从汉语教材开始，先从科普性质的引导入门的课程开始，而不是直接看国外的 or 难度较大的
   1. 我学数据结构的时候直接看国外的视频，导致得一直看着翻译
   2. 降低了学习效果，学习热情，拉长了学习周期，得不偿失
   3. 过于忽视国内的视频和教材，认为国外的好
   4. 国外的即便好，也更适合有一定基础之后去做补充
*** 2017-04-07 Friday

**** MESSY how to get in NLP natural language process                :ML:NLP:
   Source: [2017-04-07 Fri], [[https://www.zhihu.com/question/19895141][自然语言处理怎么最快入门？ - 知乎]]


   说说自己的历程吧。
   我是一名非科班的自然语言，机器学习，数据挖掘关注者。
   因工作关系，5 年前需要做与自然语言处理的项目。当时的项目老大先是扔给我一本书《统计自然语言处理》，直接给我看蒙了。不能说一点都不懂，但是看的云里雾里，不知道 get 几层。
   但看这本书的过程中，我狂搜了些自然语言处理的课件，有北大的，中科院的，都写的很好，从语言模型开始。从分词，标注，语法树，语意等等。也大体知道自然语言处理，分词法，语法，语义。然后是各种应用，信息检索，机器翻译等自然语言经典应用问题。
   断断续续做了些小项目，基于语言模型的拼音输入法，仿照 sun'pinyin 写的，他们的 blog 写的很详细，从模型建模，到平滑处理，很详细，我也用 python 实现了一遍，当时这个输入法配合上一个简单的 ui 还在部门内部推广了，搞了个基于云的拼音输入法，获得个小奖品，很是洋洋得意。这个过程中，我看着 sunpinyin 的 blog, 回过头又去看课件，去了解很细节的问题，如拉普拉斯平滑，回退平滑的细节等，收获很多。
   后来老大告诉我，看自然语言问题时，可以找博士论文先看，因为博士论文一般都会来龙去脉讲的非常详细，看完一遍之后基本上这个问题就了解的差不多，然后就是 follow 业界的进度，那就是关注各种会议和期考，可自行百度和谷歌。
   搞好这个拼音输入法，进入实际项目，做一套中文自然语言的基础处理引擎，好在不是让我一个人来，公司开始找大学合作，我做企业项目负责跟进的，大学负责具体算法，我跟着自己调查分词标注算法，了解了有基于词典的，语言模型的，hmm,crf 的，那个 crf 的，我始终搞不大明白，后来先了解了 hmm 的 vertbe 算法，em 算法，大学的博士给我讲了一遍 crf，终于豁然开朗。还把解码过程写到了 http://52nlp.cn 上，关注的人还可以。从那以后我感觉我就真入门了。在来一个什么问题，我基本上也有套路来学习和研究了。

   总结下，
   1.先各种课件，加那本自然语言的书，搞清楚自然语言大概都有哪些问题，主要是为了解决什么问题的。
   2.基于某个问题看博士论文，了解来龙去脉。然后 follow 业界进度。
   3.找各种资源，会议的，期刊的，博客 http://52nlp.cn(不是打广告，我不是博主，不过博客真心不错)
   4.微博上关注各种这个领域的大牛，他们有时候会推荐很多有用的资料。
   当然，数学之美 我也读了，确实不错。

**** MESSY 快速入门 NLP,跟随工程                                     :ML:NLP:
   Source: [2017-04-07 Fri], [[https://www.zhihu.com/question/19895141][自然语言处理怎么最快入门？ - 知乎]]

   个人觉得可以先完整过一遍 NLP 的过程，自己经历过一遍，就可以更好了解怎么操作了。在经历的同时，也可以按需补充自己的知识。

   放一个 Github，从语料库，特征选取，到算法对比，评价指标，还附带参考论文，可以试着跑一跑

   GitHub - ZixuanKe/Ch2r_ood_understanding
   https://github.com/ZixuanKe/Ch2r_ood_understanding
*** 2017-04-10 Monday

**** MESSY  [[https://www.zhihu.com/question/34470160][机器学习各种算法怎么调参? - 知乎]]                      :ML:tuning:
   Captured On: [2017-04-10 Mon 11:07]
*** 2017-04-11 Tuesday

**** MESSY  [[http://baike.baidu.com/link?url=VZ2An0ArOW5hF9WfqCANwXRYbzwwGkYv8qTgHZtwq8qFU9VfDXnTpZekwQdARf-AvXfuNhYM-QSf2CgCHM-9s2ufEBuWqudiJulgtaSDReG][TSP 问题_百度百科]]
   Captured On: [2017-04-11 Tue 10:50]

**** MESSY  [[http://baike.baidu.com/link?url=lIrKlRkZ78t6MH-XtU8AraXgmSNlIpEqATmNQrSdlp5SFwUrQvOSJI3NYNCez5hCVuXcyPbeJf9VXoRc4PR9uK_MVfPSeapzwGMGZkN3_eTn_hoTJN0DnMcFgpGLvxbosjKTOUEPJJJqPIIv3X-9Ua][模拟退火算法_百度百科]]
   Captured On: [2017-04-11 Tue 10:52]

**** MESSY  [[https://www.youtube.com/user/saurabhschool/playlists?shelf_id=0&sort=dd&view=1][saurabhschool - YouTube]]                    :cs:youtube:interview:
   Captured On: [2017-04-11 Tue 13:23]

   面试可以参考这里的 youtube 视频，针对面试中的数据结构及 java 的多线程问题等等；

**** MESSY
   Source: [2017-04-11 Tue], [[https://www.zhihu.com/question/48370147][为什么很少用启发式算法去获得多层神经网络的最优解？ - 知乎]]


   后来在深度学习的积累多了一些，可以自己回答了。就是两个字“太慢”。
   深度学习的训练过程实质是一个非线性优化问题，要解一个 non-convex 的优化问题。此类问题的解法中，local optimal 和计算速度 （原谅本科是化学系的，来了美国读了几年化学 PhD 之后才转行读 CS PhD，有些专业词汇不是很清楚中文叫什么）始终是矛盾的，换句话说，解的越快的算法，越容易得到 local optimal，以下几个方法，计算速度从快到慢依次是：gradient descent, simulated annealing, genetic algorithm, exhaustive search. 其中 simulated annealing, genetic algorithm 都算是启发式算法。 当然，如果有充分的资源和时间，exhaustive search 总能得到全局最优，但是现实情况下是不可能的。gradient descent 是最容易本困在 local optimal 的。
   对 deep learning 的这个问题来说，在目前条件下，很明显，计算速度才是问题，所以基本无一例外都是使用基于 gradient descent 进行优化的。而最近的几篇论文，包括 https://arxiv.org/pdf/1605.07110v3.pdf 和 https://arxiv.org/pdf/1412.0233v3.pdf，都在理论上证明，local optimal 在 deep learning 的优化过程中不是什么问题。
   所以，deep learning 和 MLP 中，基本都都是 gradient descent 进行优化，而没有用启发式解法的。

**** MESSY 为什么很少用启发式搜索算法获得多层神经网络的最优解？   :ML:neural:
   Source: [2017-04-11 Tue], [[https://www.zhihu.com/question/48370147][为什么很少用启发式算法去获得多层神经网络的最优解？ - 知乎]]


   为什么很少用启发式算法去获得多层神经网络的最优解？
   我理解多层神经网络比如 CNN，核心也是求各个节点的最优权重来获得最佳的预测值，而求最优的解法中，启发式算法如遗传算法，蚁群算法为什么很少用来解这种多层神经网络问题?

   Yan Zhang PhD in Computer Science 后来在深度学习的积累多了一些，可以自己回答了。
   就是两个字“太慢”。 深度学习的训练过程实质是一个非线性优化问题，要解一个
   non-convex 的优化问题。此类问题的解法中，local optimal 和计算速度 （原谅本科是
   化学系的，来了美国读了几年化学 PhD 之后才转行读 CS PhD，有些专业词汇不是很清楚中
   文叫什么）始终是矛盾的，换句话说，解的越快的算法，越容易得到 local optimal，以
   下几个方法，
   计算速度从快到慢依次是：
   gradient descent, simulated annealing, genetic algorithm, exhaustive search.
   其中 simulated annealing, genetic algorithm 都算是启发式算法。
   当然，如果有充分的资源和时间，exhaustive search 总
   能得到全局最优，但是现实情况下是不可能的。gradient descent 是最容易本困在 local
   optimal 的。对 deep learning 的这个问题来说，在目前条件下，很明显，计算速度才是
   问题，所以基本无一例外都是使用基于 gradient descent 进行优化的。

   而最近的几篇论文，包括 https://arxiv.org/pdf/1605.07110v3.pdf 和
   https://arxiv.org/pdf/1412.0233v3.pdf，都在理论上证明，local optimal 在 deep
   learning 的优化过程中不是什么问题。所以，deep learning 和 MLP 中，基本都都是
   gradient descent 进行优化，而没有用启发式解法的。

**** MESSY how to avoid local optimal in 启发式搜索算法
   Source: [2017-04-11 Tue], [[https://www.zhihu.com/question/19731925][启发式优化算法中，如何使之避免陷入局部最优解？ - 知乎]]


   启发式优化算法中，如何使之避免陷入局部最优解？
    启发式优化算法，比如蚁群算法，粒子群算法，遗传算法等。目前知道的有引入混沌机制，类似于遗传算法里的变异吧。请问还有没有什么好的方式？
   启发式算法中，局部最优值的陷入无法避免。启发式，本质上是一种贪心策略，这也在客观上决定了不符合贪心规则的更好（或者最优）解会错过。

   简单来说，避免陷入局部最优就是两个字：随机。
   具体实现手段上，可以根据所采用的启发式框架来灵活地加入随机性。比如遗传里面，可以在交叉变异时，可以在控制人口策略中，也可以在选择父本母本样本时；禁忌里面，可以在禁忌表的长度上体现，也可以在解禁策略中使用，等等。这些都要结合具体问题特定的算例集，需要反复尝试摸索才行。参数的敏感性是一个问题，建议不要超过 3 个参数，参数越不敏感越好。不同算例集用不同种子运行多次（100 次左右才有统计意义），统计平均性能即可。需注意全局的随机重启通常来说不是一个好办法，因为等于主动放弃之前搜索结果，万不得已不要用，或者就是不用。

   三个原则应该把握：越随机越好；越不随机越好；二者平衡最好。

   越随机越好
   没有随机性，一定会陷入局部最优。为了获得更大的找到最优解的期望，算法中一定要有足够的随机性。具体体现为鲁棒性较好，搜索时多样性较好。算法的每一步选择都可以考虑加入随机性，但要控制好概率。比如，某个贪心策略下，是以概率 1 做某一动作，可以考虑将其改为以概率 0.999 做之前的操作，以剩余概率做其他操作。具体参数设置需调试。

   越不随机越好
   随机性往往是对问题内在规律的一种妥协。即没有找到其内在规律，又不知道如何是好，为了获得更好的多样性，逼不得已加入随机。因此，对给定问题的深入研究才是根本：分辨出哪些时候，某个动作就是客观上能严格保证最优的——这点至关重要，直接决定了算法性能。最好的算法一定是和问题结构紧密相连的，范范地套用某个启发式的框架不会有出色的性能。当然，如果不是追求性能至上，而是考虑到开发效率实现成本这些额外因素，则另当别论。

   二者平衡最好
   通常情况下，做好第一点，可以略微改善算法性能；做好第二点，有希望给算法带来质的提高。而二者调和后的平衡则会带来质的飞跃。
   贪心是“自强不息”的精进，不放过任何改进算法的机会；多样性的随机是“厚德载物”的一分包容，给那些目前看似不那么好的解一些机会。调和好二者，不偏颇任何一方才能使算法有出色的性能。要把握这种平衡，非一朝一夕之功，只能在反复试验反思中去细细品味。

   要结合具体问题而言，范范空谈无太大用。


   希望有所帮助，欢迎讨论。
   编辑于 2016-01-26
   72
   4 条评论
   分享
   收藏感谢收起

   知乎用户
   9 人赞同了该回答
   看了前面的回答，基本都是说“局部搜索-跳出”这样的策略。从算法的层面来说，对付陷入局部最优的最简单的策略显然是 Restart 策略（重新开始，重启）。

   1997 年 Science 这篇论文 sciencemag.org 中指出，对于困难的计算问题，重启是一个非常经济的策略。一个最好的例子就是使用浏览器打开网页的时候，如果网页持续缓冲，那么人们通常的做法并不是一直等待网页缓冲完毕，而是重新刷新网页。对应到随机优化算法上，当算法长时间无法找到好解的时候，重新启动算法通常是一个好的策略。

   说一下其中的原理。首先，我们针对随机算法，更准确的说 Las Vegas 算法，即算法的运行时间是一个随机变量，最终返回一个准确解的近似值。假定算法的运行时间服从某个分布，当算法运行到某个时点之后，有两个策略：
   继续运行算法到结束，
   重新启动算法。
   比较这两种策略，论文指出，当运行时间的分布（running time distribution, RTD)满足有些条件时（如方差较大），重新启动算法的期望运行时间 比继续运行算法的时间要少
   .
   这相当于多个算法并行运行，任何一个找到最优解就终止运行。重启策略承认我们对多峰问题没有特别好的有效的处理手段，然而反复运行算法总会找到好解。通常 RTD 用多次运行达到某个近似程度的累积分布表示，有兴趣的可以看 Holger H. Hoos Stochastic Local Search。此外 RTD 普遍用于进化算法的对比评估。


   一个 RTD 的例子如下图（DE 在单峰的 Ellipsoid 函数上的 running time distribution）。

   在复杂 TSP 问题和多峰问题上，其形状可能是


   在有很多局部极值的目标函数上，任何随机优化算法运行任意长时间找到全局最优解的概率都无法达到 1。 这时候 restart 策略总是适用的。并且相比各种复杂的跳出策略，简单的重启策略可能是更加实用的方案，尤其是问题很难而 success probability 很小的时候。

   这种方法最大的优点就是，不需要对算法做任何修改，重新初始化即可。

   重启策略在随机优化算法中主要是 Evolution strategies 中用的比较多，最重要的之一就是 CEC2005 的优胜算法 http://ieeexplore.ieee.org/document/1554902/
   GECCO 2012、13 的方法[1207.0206] Alternative Restart Strategies for CMA-ES。
   值得一提的是，如上面论文中的做法，对于多峰问题，增大种群规模几乎总是好的。

   更多的研究可见 Algorithm Portfolios
   http://www.sciencedirect.com/science/article/pii/S0004370200000813 ,
   http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.2.4644&rep=rep1&type=pdf,
   Restart strategies in optimization: parallel and serial cases
   On algorithm portfolios and restart strategies
   http://alumnus.caltech.edu/~amir/restartjnl.pdf

   最后指出，这种 restart 方法，实际起源于经典的算法而不是随机算法， 如 conjugate gradient 中也有相似的方法。Restart 也用于神经网络里面，如 Stochastic Gradient Descent with Restarts .


   是的，我扯了这么大一通，就是想告诉你: 再跑一次


   我的相关回答：
   神经网络的训练可以采用二阶优化方法吗(如 Newton, Quasi Newton)？
   有哪些学术界都搞错了，忽然间有人发现问题所在的事情？ - 知乎用户的回答 - 知乎
*** 2017-04-12 Wednesday

**** MESSY
   Source: [2017-04-12 Wed], [[https://www.liepin.com/job/197601104.shtml?imscid=R000000075&ckid=c1fb07bda10c1946&headckid=c1fb07bda10c1946&pageNo=0&pageIdx0&totalIdx=0&sup=1][【机器学习/数据挖掘专家(模型方向)招聘】天数科技最新招聘信息-猎聘网]]


   1. 数学、统计、计算机等相关专业硕士及以上学历；
   2. 具有 2 年以上机器学习和深度学习相关领域的工作经验；
   3. 对常用的机器学习和深度学习相关模型与算法原理理解透彻；
   4. 精通分布式系统（hadoop,spark）,能够在分布式框架上熟练开发相关模型；
   5. 精通 python，R，matlab 等数据分析语言，熟悉数据挖掘相关的库；
   6. 有金融量化，图像处理及人工智能相关项目工作经验优先；
   7. 良好的逻辑思维能力，能够从海量数据中发现有价值的规律；
   8. 不惧困难，面临挑战充满激情，面临挫折充满斗志，面临质疑临危不惧；
   9. 具有良好的沟通能力，和良好的团队合作精神。

**** MESSY
   Source: [2017-04-12 Wed], [[https://www.liepin.com/job/197439347.shtml?imscid=R000000075&ckid=c1fb07bda10c1946&headckid=c1fb07bda10c1946&pageNo=0&pageIdx1&totalIdx=1&sup=1][【算法工程师招聘】明略软件最新招聘信息-猎聘网]]


   岗位要求：
   1. 精通机器学习、深度学习等数据挖掘技术，深入理解相关数据挖掘算法，并能熟练使用主流的开源数据挖掘工具。
   2. 有丰富的数据挖掘实践经验，作为主要建模人员做过多个数据挖掘项目，并且取得了良好的效果。
   3. 良好的代码能力，精通数据结构和通用算法，从事过较长时间的代码工作。
   4. 了解大数据背景知识，对常用的大数据技术有一定的了解。
   5. 有强烈的学习热情，渴望学习新知识、新技术。

**** MESSY
   Source: [2017-04-12 Wed], [[https://www.liepin.com/job/197942780.shtml?imscid=R000000075&ckid=c1fb07bda10c1946&headckid=c1fb07bda10c1946&pageNo=0&pageIdx8&totalIdx=8&sup=1][【高级机器学习工程师招聘】亚信科技最新招聘信息-猎聘网]]


   1、 研究生及以上学历，3 年以上相关工作经验，
   2、 计算机基本功及数学基础，熟练运用各种常用算法和数据结构;
   3、 有丰富的数据挖掘/机器学习/自然语言处理/推荐算法等相关工作经验或者研究经历;
   4、 对技术有热情，乐于挑战，有责任心
   5、 英文技术文献阅读和理解能力。
   6、 良好的分析及解决问题的能力，良好的团队合作精神

**** MESSY
   Source: [2017-04-12 Wed], [[https://www.liepin.com/job/196467350.shtml?imscid=R000000075&ckid=c1fb07bda10c1946&headckid=c1fb07bda10c1946&pageNo=0&pageIdx9&totalIdx=9&sup=1][【机器学习算法研究方向招聘】南京擎盾最新招聘信息-猎聘网]]


   数据挖掘&自然语言处理研发工程师
   1)了解机器学习和自然语言处理的常用算法（主题分类、聚类、自动推荐、中文分词、序列化标注、句法分析等），有相关经验工作者优先；
   2)能熟练调用现有国内外深度机器学习框架者优先，如 TensorFlow、Theano、Scikit-Learn；Deeplearning4j 等；
   3)熟悉 java/python 编程语言，有丰富的项目经验者优先；
   4)概率学，统计学，线性代数等基础数学知识扎实；
   5)热爱大数据挖掘分析和自然语言处理，有浓厚的学习兴趣和专研精神。

**** MESSY
   Source: [2017-04-12 Wed], [[https://www.liepin.com/a/9132874.shtml?imscid=R000000075&ckid=c1fb07bda10c1946&headckid=c1fb07bda10c1946&pageNo=0&pageIdx15&totalIdx=15&sup=1][【机器学习算法工程师招聘_机器学习算法工程师工作职责】-猎聘网]]


   1、深入理解数据挖掘的理论基础；
   2、熟悉常用算法，如分类、聚类、回归、关联规则等；
   3、有文本挖掘、时序数据挖掘、地理信息挖掘、信用建模项目经验者优先考虑；
   4、精通数据挖掘的脚本语言：python、R、matlab、Octave、Julia 其中的一种；
   5、精通数据包 SK-learn、Weka 等类似工具；
   6、熟悉常用的编程语言 C，C++，Java 等；
   7、熟悉分布式系统 hadoop，spark 等；
   8、熟悉常用的数据库。

**** MESSY
   Source: [2017-04-12 Wed], [[https://www.liepin.com/a/9069179.shtml?imscid=R000000075&ckid=c1fb07bda10c1946&headckid=c1fb07bda10c1946&pageNo=0&pageIdx18&totalIdx=18&sup=1][【个性化推荐算法部门负责人招聘_个性化推荐算法部门负责人工作职责】-猎聘网]]


   1、负责个性化推荐算法平台设计与开发，根据用户画像，实时行为等为用户推荐感兴趣的商品；
   2、结合业务需求设计和开发推荐系统模块，满足业务需求；
   3、跟踪国内外推荐系统前沿算法与技术，对个性化推荐系统效果与性能进行持续优化，提升个性化推荐系统各项评测指标

**** MESSY
   Source: [2017-04-12 Wed], [[https://www.liepin.com/a/9120946.shtml?imscid=R000000075&ckid=c1fb07bda10c1946&headckid=c1fb07bda10c1946&pageNo=0&pageIdx21&totalIdx=21&sup=1][【自然语言处理工程师招聘_自然语言处理工程师工作职责】-猎聘网]]


   1、负责商业智能领域语义分析算法、自然语言处理相关技术和方法的研发；
   2、负责将语义分析的数据挖掘算法应用到智能人机对话产品中，解决实际问题；
   3、积极探索自然语言、人工智能研究领域的研究动向，并迅速进行转化

   任职要求：
   1、教育背景：自然语言处理、模式识别或机器学习相关专业本科以上学历；
   2、经验：至少 1 年自然语言处理相关经验包括语法分析、句法分析、文本分类/聚类、问答系统、对话系统等；
   3、专业知识：熟悉语义分析和理解技术（相似度计算、知识表示、本体理论、分领域的 语义网络、机器推理等）；
   4、具备良好的 JAVA 和 C++编程能力；良好的抗压能力和团队精神。

**** MESSY
   Source: [2017-04-12 Wed], [[https://www.liepin.com/a/9069179.shtml?imscid=R000000075&ckid=c1fb07bda10c1946&headckid=c1fb07bda10c1946&pageNo=0&pageIdx18&totalIdx=18&sup=1][【个性化推荐算法部门负责人招聘_个性化推荐算法部门负责人工作职责】-猎聘网]]


   1、计算机或者数学相关专业硕士及以上学历；2、3 年以上推荐系统，数据相关工作经验，有电商业务经验者优先；3、具备机器学习、数据挖掘或自然语言处理等至少一种的研究背景和项目背景；4、对常用的推荐算法（协同过滤，关联规则，LR 等）有较深入了解，有实际算法调优经验；5、掌握常用的数据挖掘和机器学习算法，如分类/聚类算法、预估算法；6、熟悉大数据相关技术，包括 Hadoop,Storm,Spark 等；7、具备 Linux/Unix 环境开发经验，熟悉以下 Java/C++/python 至少一种编程语言；8、学习能力强，易沟通，团队合作精神佳；
*** 2017-04-17 Monday
**** MESSY
   Source: [2017-04-17 Mon], [[https://segmentfault.com/a/1190000005859547][使用 pyenv + virtualenv 打造多版本 Python 开发环境 - PyLixm'Wiki - SegmentFault]]


   本文最早发表于个人博客 Pylixm'wiki: http://pylixm.cc

   配置环境：

   CentOS release 6.8
   pyenv 20160509
   在工作开发中，一直使用 virtualenv 来管理 python 的包环境。很好的解决了不同项目使用不同 python 包的需求。对于多 python 版本的问题如何解决一直无解，虽然可以安装多个

   版本的 python，靠绝对路径或靠创建虚拟环境的时候指定 python（virtualenv -p）版本来解决，但总感觉不是那么的优雅。同事推荐了 pyenv，一直没用过，特从网上找了些资料试着配置了下，记录如下。

   pyenv vs virtualenv
   pyenv 是针对 python 版本的管理，通过修改环境变量的方式实现；

   virtualenv 是针对 python 的包的多版本管理，通过将 python 包安装到一个模块来作为 python 的包虚拟环境，通过切换目录来实现不同包环境间的切换。

   pyenv 原理
   pyenv 的美好之处在于，它并没有使用将不同的 $PATH 植入不同的 shell 这种高耦合的工作方式，而是简单地在 $PATH 的最前面插入了一个垫片路径（shims）：~/.pyenv/shims:/usr/local/bin:/usr/bin:/bin。所有对 Python 可执行文件的查找都会首先被这个 shims 路径截获，从而架空了后面的系统路径。

   pyenv 安装使用
   自动安装
   pyenv 提供了自动安装的工具，执行命令安装即可：

   curl -L https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash
   需保证系统有 git，否则需要新安装 git 工具。

   手动安装
   将 pyenv 检出到你想安装的目录。建议路径为：$HOME/.pyenv

    $ cd
    $ git clone git://github.com/yyuu/pyenv.git .pyenv
   添加环境变量。PYENV_ROOT 指向 pyenv 检出的根目录，并向 $PATH 添加 $PYENV_ROOT/bin 以提供访问 pyenv 这条命令的路径

    $ echo 'export PYENV_ROOT="$HOME/.pyenv"' >> ~/.bash_profile
    $ echo 'export PATH="$PYENV_ROOT/bin:$PATH"' >> ~/.bash_profile
   这里的 shell 配置文件（~/.bash_profile）依不同 Linux 而需作修改——Zsh：~/.zshenv；Ubuntu：~/.bashrc

   向 shell 添加 pyenv init 以启用 shims 和命令补完功能

   $ echo 'eval "$(pyenv init -)"' >> ~/.bash_profile
   配置文件的位置同上一条一样需要修改

   重启 shell（因为修改了 $PATH）

   $ exec $SHELL
   pyenv 常用命令
   python 配置

   $ pyenv versions -- 查看系统当前安装的 python 列表
   $ pyenv install -v 3.5.1 -- 安装 python
   $ pyenv uninstall 2.7.3 -- 卸载 python
   $ pyenv rehash -- 创建垫片路径（为所有已安装的可执行文件创建 shims，如：~/.pyenv/versions/*/bin/*，因此，每当你增删了 Python 版本或带有可执行文件的包（如 pip）以后，都应该执行一次本命令）
   python 切换

   $ pyenv global 3.4.0 -- 设置全局的 Python 版本，通过将版本号写入 ~/.pyenv/version 文件的方式。
   $ pyenv local 2.7.3 -- 设置面向程序的本地版本，通过将版本号写入当前目录下的 .python-version 文件的方式。通过这种方式设置的 Python 版本优先级较 global 高。
   pyenv 会从当前目录开始向上逐级查找 .python-version 文件，直到根目录为止。若找不到，就用 global 版本。
   $ pyenv shell pypy-2.2.1 -- 设置面向 shell 的 Python 版本，通过设置当前 shell 的 PYENV_VERSION 环境变量的方式。这个版本的优先级比 local 和 global 都要高。--unset 参数可以用于取消当前 shell 设定的版本。
   $ pyenv shell --unset
   python 优先级

   shell > local > global

   pyenv 插件: pyenv-virtualenv
   安装
   使用自动安装 pyenv 后，它会自动安装部分插件，通过 pyenv-virtualenv 插件可以很好的和 virtualenv 结合：

   [root@linux3311 ~]# cd .pyenv/plugins/
   [root@linux3311 plugins]# ll
   insgesamt 24
   drwxr-xr-x. 4 root root 4096 19. Jun 05:17 pyenv-doctor
   drwxr-xr-x. 5 root root 4096 19. Jun 05:18 pyenv-installer
   drwxr-xr-x. 4 root root 4096 19. Jun 05:18 pyenv-update
   drwxr-xr-x. 7 root root 4096 19. Jun 05:18 pyenv-virtualenv
   drwxr-xr-x. 4 root root 4096 19. Jun 05:18 pyenv-which-ext
   drwxr-xr-x. 5 root root 4096 19. Jun 05:17 python-build

   使用
   创建虚拟环境 $ pyenv virtualenv 2.7.10 my-virtual-env-2.7.10
   若不指定 python 版本，会汇报认使用当前环境 python 版本。
   列出当前虚拟环境 pyenv virtualenvs
   激活虚拟环境 pyenv activate
   退出虚拟环境 pyenv deactivate
   删除虚拟环境 pyenv uninstall my-virtual-env
   使用 pyenv 来管理 python，使用 pyenv-virtualenv 插件来管理多版本 python 包。

   此时，还需注意，当我们将项目运行的 env 环境部署到生产环境时，由于我们的 python 包是依赖 python 的，需要注意生产环境的 python 版本问题(详见 这里)。

   以上为个人拙见，欢迎小伙伴们留言交流。小伙伴们若有更好的 python 多版本环境管理方案，希望留言不吝赐教，在此，先谢过了！

   参考
   pyenv 下载地址 这里
   virtualenv 中文文档地址 这里
   http://my.oschina.net/lionets/blog/267469
   https://github.com/yyuu/pyenv-virtualenv
*** 2017-04-18 Tuesday

**** MESSY how to add ref or link to src block in org file
1. in special editing mode of src block, press hotkey of 'org-store-link'
   to add tag to a particular line, and give it a *name*;
2. add '-r' to end of line '#+BEGIN_SRC python'
3. press 'C-c C-l' and input the tag-name definde in step1, you get the link.

**** MESSY display math symbol and formula in org-mode

1. display simple math symbol
   C-c C-x \
   org-toggle-pretty-entries
2. display latex formula directly in org file
   C-c C-x C-l
   org-toggle-latex-fragment

**** MESSY  [[http://www.zmonster.me/2016/06/03/org-mode-table.html][强大的 Org mode(3): 表格的基本操作及公式、绘图 · ZMonster's Blog]]
   Captured On: [2017-04-18 Tue 11:12]
   emacs 中的表格竟然能直接生成图片，这个功能太猛了。
**** MESSY  [[https://www.douban.com/group/topic/34240539/][推荐推公式记笔记使用 TeXmacs]]
   Captured On: [2017-04-18 Tue 11:13]

**** MESSY get result from python code in org babel
   Source: [2017-04-18 Tue], [[http://stackoverflow.com/questions/18598870/emacs-org-mode-executing-simple-python-code][Emacs Org Mode: Executing simple python code - Stack Overflow]]


   There are two ways of getting the result of a source block - output and value. You mixed them up, hence the troubles.

   First block is fine.

   To fix the second block:

   #+begin_src python :results value
return 1+1
   #+end_src
   To fix the third block:

   #+begin_src python :results output
print 1+1
   #+end_src
   When output mode is value you must return. Just putting it there like you did with 1+1 won't do. In the third one you want the result to be printed output, but your default session setting is value(mine defaults to output btw).

   And this bit about org-confirm-babel-evaluate is kind of irrelevant to the question. I just have it set to nil.

**** MESSY
   Source: [2017-04-18 Tue], [[http://stackoverflow.com/questions/18598870/emacs-org-mode-executing-simple-python-code][Emacs Org Mode: Executing simple python code - Stack Overflow]]


   There are two ways of getting the result of a source block - output and value. You mixed them up, hence the troubles.

   First block is fine.

   To fix the second block:

   #+begin_src python :results value
return 1+1
   #+end_src
   To fix the third block:

   #+begin_src python :results output
print 1+1
   #+end_src
   When output mode is value you must return. Just putting it there like you did with 1+1 won't do. In the third one you want the result to be printed output, but your default session setting is value(mine defaults to output btw).

   And this bit about org-confirm-babel-evaluate is kind of irrelevant to the question. I just have it set to nil.
*** 2017-04-21 Friday

**** MESSY 在 org 的 headline 按下 “=”，来对真个 headline 所属 content 进行缩进
   #+end_example

   Link:  [[file:~/Documents/org-notes/CS/DataStructure.org::*Merge%20Sort(a%20selection%20sort%20whose%20'S'%20and%20'I'%20are%20sorted%20list)][Merge Sort(a selection sort whose 'S' and 'I' are sorted list)]]
   File:  /home/yiddi/Documents/org-notes/CS/DataStructure.org
*** 2017-04-22 Saturday

**** MESSY how to add a link of reference to certain line of src block in org file
1. you open special-mode of an src block by pressing ~, '~
2. then, you use function ~org-store-link~,which i bind to ~f7~,to setup a ref to some line of code
3. input some discription or name
4. ~, c~ to go back to your org file
5. place the link where you want to, by ~org-insert-link~, whick i bind to ~f6~, and choose that ref from list occur in minibuffer
*** 2017-04-23 Sunday

**** MESSY Jonathan Schewchuk, Introduction to Machine Learning
1. https://www.youtube.com/watch?v=WMqNik4OWvU
2. https://www.youtube.com/watch?v=rhu0NoQYnQw
3. https://www.youtube.com/watch?v=4kjAVLkWNJ0
4. https://www.youtube.com/watch?v=RI9Q1yFGTzE
5. https://www.youtube.com/watch?v=VjY7WAyP778
*** 2017-04-30 Sunday

**** MESSY 使用 aboabo 的 org-download 去插入图片在 org 中
这个 package 需要 安装 gnome-screenshot
[[http://linux.softpedia.com/get/Utilities/GNOME-Screenshot-102903.shtml%0A][Download gnome-screenshot]]
安装这个包需要一些依赖：
1. gtk3.0-dev
2. 其他一些根据提示输入即可
** 2017-05 May
*** 2017-05-04 Thursday

**** MESSY 3 ways to set enviroment var in linux
   Source: [2017-05-04 Thu], [[http://kangyang.blog.51cto.com/471772/590840][Linux 里设置环境变量的方法（export PATH） - Mr. Kang - 51CTO 技术博客]]


   使用 linux 的朋友越来越多了，在 linux 下做开发首先就是需要配置环境变量，下面以配
   置 java 环境变量为例介绍三种配置环境变量的方法。

***** 1.修改/etc/profile 文件
      如果你的计算机仅仅作为开发使用时推荐使用这种方法，因为所有用户的 shell 都有
      权使用这些环境变量，可能会给系统带来安全性问题。

      (1)用文本编辑器打开/etc/profile

      (2)在 profile 文件末尾加入：

            JAVA_HOME=/usr/share/jdk1.5.0_05
            PATH=$JAVA_HOME/bin:$PATH
            CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
            export JAVA_HOME
            export PATH
            export CLASSPATH

      (3)重新登录
      注解：
             a. 你要将 /usr/share/jdk1.5.0_05jdk 改为你的 jdk 安装目录
             b. linux 下用冒号“:”来分隔路径
             c. $PATH / $CLASSPATH / $JAVA_HOME 是用来引用原来的环境变量的值,在设置环境变量时特别要注意不能把原来的值给覆盖掉了，这是一种常见的错误。
             d. CLASSPATH 中当前目录“.”不能丢,把当前目录丢掉也是常见的错误。
             e. export 是把这三个变量导出为全局变量。
             f. 大小写必须严格区分。
***** 2. 修改.bashrc 文件　　
      这种方法更为安全，它可以把使用这些环境变量的权限控制到用户级别，如果你需要
      给某个用户权限使用这些环境变量，你只需要修改其个人用户主目录下的.bashrc 文
      件就可以了。

      (1)用文本编辑器打开用户目录下的.bashrc 文件
      (2)在.bashrc 文件末尾加入：　　

              set JAVA_HOME=/usr/share/jdk1.5.0_05
              export JAVA_HOME
              set PATH=$JAVA_HOME/bin:$PATH
              export PATH
              set CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
              export CLASSPATH

      (3)重新登录
***** 3. 直接在 shell 下设置变量
      不赞成使用这种方法，因为换个 shell，你的设置就无效了，因此这种方法仅仅是临
      时使用，以后要使用的时候又要重新设置，比较麻烦。只需在 shell 终端执行下列命
      令：

              export JAVA_HOME=/usr/share/jdk1.5.0_05
              export PATH=$JAVA_HOME/bin:$PATH
              export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
*** 2017-05-16 Tuesday

**** MESSY Eshell alias

     Alias 'll' to 'ls -l'
     Make sure that the positional parameters are included:
     ~ $ alias ll 'ls -l $*'

     Alias 'emacs' to 'find-file'
     ~ $ alias emacs 'find-file $1'

     Note that without the quotes, the positional parameter will get lost:

     ~ $ alias emacs find-file $1
     ~ $ alias
     alias emacs find-file

     Note also that $* will not work because ‘find-file’ expects exactly one
     parameter. Using $* instead of $1 will pass a list of parameters to
     find-file, and find-file will barf:

     ~ $ alias emacs 'find-file $*'
     ~ $ emacs test.txt
     Wrong type argument: stringp, ("test.txt")
*** 2017-05-18 Thursday
*** 2017-05-30 Tuesday

**** MESSY  Python 模块之 __future__
   Source: [2017-05-30 Tue], [[http://www.cnblogs.com/bluescorpio/archive/2009/09/09/1563634.html][Python 模块之 __future__ - 小楼 - 博客园]]


   Python 模块之 __future__

   今天在学习 Python Cookbook 的时候，发现一句语法 from __future__ import division，很奇怪__future__这个名字，网上搜了一下，原来是很有用的一个模块。

   详细说明见这里。按照官方的解释，至少确保在 2.1 之前版本的 Python 可以正常运行一些新的语言特性，需要使用语句 'from __future__ import *'。举例来说：

   # Enable nested scopes in Python 2.1
   from __future__ import nested_scopes

   如果使用这个语句，则该语句必须是模块或程序的第一个语句。此外，'__ future__' 模块中存在的特性最终将成为 Python 语言标准的一部分。到那时，将不再需要使用 '__future__' 模块。

   更多示例：

   1. Python 2.6 中也有一个 __future__ import 使得所有的字符串文本成为 Unicode 字符串。这就意味着\u 转义序列可以用于包含 Unicode 字符。

   from __future__ import unicode_literals

   s = ('\u751f\u3080\u304e\u3000\u751f\u3054'
   '\u3081\u3000\u751f\u305f\u307e\u3054')
   print len(s) # 12 Unicode characters

   2. Python 2.6 可以通过 import __future__ 来将 print 从语言语法中移除，让你可以使用函数的形式。例如：

   from __future__ import print_function
   print('# of entries', len(dictionary), file=sys.stderr)

   3. 整数除法

   python 2.5 中：23/6 # 得 3
   from __future__ import division 之后：
   23/6 # 得 3.8333333333333335
*** 2017-05-31 Wednesday

**** MESSY use *watch* to exec program periodically
   Source: [2017-05-31 Wed], [[http://www.cnblogs.com/Suzzz/p/4106581.html][Linux 命令行监视显卡使用情况 - Suzzz - 博客园]]


   watch 命令简介

   watch 是做什么的？ 看一下系统怎么说

   1 $ whatis watch
   2 watch(1)        - execute a program periodically, showing output fullscreen
   功能很明白，周期性执行某一命令，并将输出全屏显示

   watch 的基本用法是

   1 watch [options]  command
   最常用的参数是 -n， 后面指定是每多少秒来执行一次命令。

   监视显存

   我们设置为每 10s 显示一次显存的情况

   watch -n 10 nvidia-smi
** 2017-06 June
*** 2017-06-01 Thursday

**** MESSY
   Source: [2017-06-01 Thu], [[http://www.cnblogs.com/kungfupanda/p/5237255.html][python 中的__init__ 、__new__、__call__小结 - 功夫 熊猫 - 博客园]]


   python 中的__init__ 、__new__、__call__小结

   这篇文章主要介绍了 python 中的__init__ 、__new__、__call__小结,需要的朋友可以参考下
   1.__new__(cls, *args, **kwargs)  创建对象时调用，返回当前对象的一个实例;注意：这里的第一个参数是 cls 即 class 本身
   2.__init__(self, *args, **kwargs) 创建完对象后调用，对当前对象的实例的一些初始化，无返回值,即在调用__new__之后，根据返回的实例初始化；注意，这里的第一个参数是 self 即对象本身【注意和 new 的区别】
   3.__call__(self,  *args, **kwargs) 如果类实现了这个方法，相当于把这个类型的对象当作函数来使用，相当于 重载了括号运算符
    

   看具体的例子：

   复制代码 代码如下:

   class O(object):
       def __init__(self, *args, **kwargs):
           print "init"
           super(O, self).__init__(*args, **kwargs)

       def __new__(cls, *args, **kwargs):
           print "new", cls
           return super(O, cls).__new__(cls, *args, **kwargs)

       def __call__(self,  *args, **kwargs):
           print "call"
         

       oo = O()
       print "________"
       oo() 


   打印出来的是：
   复制代码 代码如下:

   new
   init
   ________
   call

   比如：Python Singleton（单例模式）实现，那我们是不是只是重载一些__new__方法就可以了
   复制代码 代码如下:

   class Singleton1(object):
       """ 重载 new 方法"""
       def __new__(cls, *args, **kwargs):
           if not "_instance" in vars(cls):
               cls._instance = super(Singleton1, cls).__new__(cls, *args, **kwargs)
           return cls._instance
   可不可以重载__init__方法呢？明显不可以，因为__init__之前调用了__new__方法，这时候已经生成了一个对象了，没办法实现单例模式

   ===========================================
    
   注意 1、__init__并不相当于 C#中的构造函数，执行它的时候，实例已构造出来了。

   1
   2
   3
   4
   5
   class A(object):
       def __init__(self,name):
           self.name=name
       def getName(self):
           return 'A '+self.name
   当我们执行

   1
   a=A('hello')
   时，可以理解为

   1
   2
   a=object.__new__(A)
   A.__init__(a,'hello')
   即__init__作用是初始化已实例化后的对象。

   注意 2、子类可以不重写__init__，实例化子类时，会自动调用超类中已定义的__init__

   1
   2
   3
   4
   5
   6
   7
   class B(A):
       def getName(self):
           return 'B '+self.name
    
   if __name__=='__main__':
       b=B('hello')
       print b.getName()
   但如果重写了__init__，实例化子类时，则不会隐式的再去调用超类中已定义的__init__

   1
   2
   3
   4
   5
   6
   7
   8
   9
   class C(A):
       def __init__(self):
           pass
       def getName(self):
           return 'C '+self.name
    
   if __name__=='__main__':
       c=C()
       print c.getName()
   则会报"AttributeError: 'C' object has no attribute 'name'”错误，所以如果重写了__init__，为了能使用或扩展超类中的行为，最好显式的调用超类的__init__方法

   1
   2
   3
   4
   5
   6
   7
   8
   9
   class C(A):
       def __init__(self,name):
           super(C,self).__init__(name)
       def getName(self):
           return 'C '+self.name
    
   if __name__=='__main__':
       c=C('hello')   
       print c.getName()
    
    
   What Doesn't Kill Me Makes Me Stronger

**** MESSY
   Source: [2017-06-01 Thu], [[http://zqpythonic.qiniucdn.com/data/20091016221631/index.html][如何理解并正确使用 python 中的 self init - python - huaihe0410]]


   如何理解并正确使用 python 中的 self init
   《简明 python 教程》对 self 的用法介绍如下：
    
   类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称，但是在调用这个方法的时候你不为这个参数赋值，Python 会提供这个值。这个特别的变量指对象本身，按照惯例它的名称是 self。

   虽然你可以给这个参数任何名称，但是 强烈建议 你使用 self 这个名称——其他名称都是不赞成你使用的。使用一个标准的名称有很多优点——你的程序读者可以迅速识别它，如果使用 self 的话，还有些 IDE（集成开发环境）也可以帮助你。

   =======================================================

   给 C++/Java/C#程序员的注释
   Python 中的 self 等价于 C++中的 self 指针和 Java、C#中的 this 参考。

   =======================================================

   你一定很奇怪 Python 如何给 self 赋值以及为何你不需要给它赋值。举一个例子会使此变得清晰。假如你有一个类称为 MyClass 和这个类的一个实例 MyObject。当你调用这个对象的方法 MyObject.method(arg1, arg2)的时候，这会由 Python 自动转为 MyClass.method(MyObject, arg1, arg2)——这就是 self 的原理了。

   这也意味着如果你有一个不需要参数的方法，你还是得给这个方法定义一个 self 参数。

   我这里补充一下几个实例程序以加深理解：

   class Person:
    def sayHi(self):
     print 'Hello,how are you?'
   p=Person()
   p.sayHi()

   结果显示为：

   Hello,how are you?

   改一下：

   class Person:
    def sayHi(self):
     print 'Hello,how are you?'
   p=Person()
   Person.sayHi(p)

   结是同上！

   再改一下：（去掉 self,会怎么样呢？）

   class Person:
    def sayHi():
     print 'Hello,how are you?'
   p=Person()
   Person.sayHi(p)
   p.sayHi()

   出现如下错误信息：

   Traceback (most recent call last):
     File "C:\pro\Person2.py", line 5, in ?
       Person.sayHi(p)
   TypeError: sayHi() takes no arguments (1 given)

   --------------------------------------------------------
   --------------------------------------------------------
   __name__是用来识别一个模块是直接运行还是作为一般的模块被导入的状态。当一个模块是直接运行时，__name__就等于__main__，如果它是作为一般模块被导入时，__name__就是模块本身的名字。

   示例:
   if __name__ == "__main__":
     run()

   self 是一种约定。在 Python 中，类方法的第一个参数表示对象本身，在 Python 中一般使用 self。你也可以使用 this.

   示例:
   a 是你想用的方法。但 self 是一种约定。在调用一个对象的方法时，对象本身被作为 self 参数传入。如：

   class A:
       def p(self, name):
           print name
   a=A()
   a.p('aa')

   这时，相当于 A.p(a, 'aa')
   --------------------------------------------------------
   --------------------------------------------------------
   -------------------------------------------------------
   -----------------------------------------------------------
    
    
   Python 的对象不一定要有__init__方法，无论它是基类还是子类。因为__init__不是构造函数，Python 对象在调用__init__的时候已被构造出来，称为“初始化”比较合适。

   如果一个对象是子类，且需要有__init__，那么在__init__的第一个语句就是父类的__init__（除非父类是像 dict 一样的内置数据类型则不需要__init__）。调用完后再进行子类的相关初始化，作为方法覆盖。

   一般在子类覆盖“专有类方法”，并触发相关动作，这样不必使用__init__也能进行更高级的初始化。

   如果子类的方法覆盖了父类，想调用父类的方法怎么吗？Python 没有 super 啊。很简单，直接“父类名.方法”即可。

   一般在类定义中方法之外的属性叫“类属性”，它跟定义在方法内的属性有什么区别呢？“ 类属性”可以使得不必生成实例也可以调用，而嵌在方法内的（特别是由__init__初始化后产生的属性），一定得产生实例才可以调用之。

   所有的类的实例都享有统一的“类属性”，那这“类属性”是否就是类的常量？不是！通过在任意实例调用 self.__class__.NAME 就可以修改“类属性”，修改后所有的实例都将应用这一新的“类属性”。self.__class__即代表类的引用，不代表任何实例，实例就是 self。

**** MESSY
   Source: [2017-06-01 Thu], [[https://www.saltycrane.com/blog/2008/01/how-to-use-args-and-kwargs-in-python/#calling-a-function][How to use *args and **kwargs in Python - SaltyCrane Blog]]


   How to use *args and **kwargs in Python
   Date: 2008-01-03  |  Modified: 2012-12-20  |  Tags: python  |  97 Legacy Comments  |  Add a comment
   Or, How to use variable length argument lists in Python.

   The special syntax, *args and **kwargs in function definitions is used to pass a variable number of arguments to a function. The single asterisk form (*args) is used to pass a non-keyworded, variable-length argument list, and the double asterisk form is used to pass a keyworded, variable-length argument list. Here is an example of how to use the non-keyworded form. This example passes one formal (positional) argument, and two more variable length arguments.

   def test_var_args(farg, *args):
       print "formal arg:", farg
       for arg in args:
           print "another arg:", arg

   test_var_args(1, "two", 3)
   Results:

   formal arg: 1
   another arg: two
   another arg: 3

   Here is an example of how to use the keyworded form. Again, one formal argument and two keyworded variable arguments are passed.

   def test_var_kwargs(farg, **kwargs):
       print "formal arg:", farg
       for key in kwargs:
           print "another keyword arg: %s: %s" % (key, kwargs[key])

   test_var_kwargs(farg=1, myarg2="two", myarg3=3)
   Results:

   formal arg: 1
   another keyword arg: myarg2: two
   another keyword arg: myarg3: 3

   Using *args and **kwargs when calling a function

   This special syntax can be used, not only in function definitions, but also when calling a function.

   def test_var_args_call(arg1, arg2, arg3):
       print "arg1:", arg1
       print "arg2:", arg2
       print "arg3:", arg3

   args = ("two", 3)
   test_var_args_call(1, *args)
   Results:

   arg1: 1
   arg2: two
   arg3: 3
   Here is an example using the keyworded form when calling a function:

   def test_var_args_call(arg1, arg2, arg3):
       print "arg1:", arg1
       print "arg2:", arg2
       print "arg3:", arg3

   kwargs = {"arg3": 3, "arg2": "two"}
   test_var_args_call(1, **kwargs)
   Results:

   arg1: 1
   arg2: two
   arg3: 3

**** MESSY
   Source: [2017-06-01 Thu], [[http://www.jb51.net/article/81151.htm][浅析 Python 编写函数装饰器_python_脚本之家]]


   编写函数装饰器
   本节主要介绍编写函数装饰器的相关内容。
   跟踪调用
   如下代码定义并应用一个函数装饰器，来统计对装饰的函数的调用次数，并且针对每一次调用打印跟踪信息。
   ?
   1
   2
   3
   4
   5
   6
   7
   8
   9
   10
   11
   class tracer:
   def __init__(self,func):
   self.calls = 0
   self.func = func
   def __call__(self,*args):
   self.calls += 1
   print('call %s to %s' %(self.calls, self.func.__name__))
   self.func(*args)
   @tracer
   def spam(a, b, c):
   print(a + b + c)
   这是一个通过类装饰的语法写成的装饰器，测试如下：
   ?
   1
   2
   3
   4
   5
   6
   7
   8
   9
   10
   >>> spam(1,2,3)
   call 1 to spam
   6
   >>> spam('a','b','c')
   call 2 to spam
   abc
   >>> spam.calls
   2
   >>> spam
   <__main__.tracer object at 0x03098410>
   运行的时候，tracer 类和装饰的函数分开保存，并且拦截对装饰的函数的随后的调用，以便添加一个逻辑层来统计和打印每次调用。
   装饰之后，spam 实际上是 tracer 类的一个实例。
   @装饰器语法避免了直接地意外调用最初的函数。考虑如下所示的非装饰器的对等代码：
   ?
   1
   2
   3
   4
   5
   6
   7
   8
   calls = 0
   def tracer(func,*args):
   global calls
   calls += 1
   print('call %s to %s'%(calls,func.__name__))
   func(*args)
   def spam(a,b,c):
   print(a+b+c)
   测试如下：
   ?
   1
   2
   3
   4
   5
   6
   7
   8
   9
   10
   11
   ?
   1
   2
   3
   4
   5
   >>> spam(1,2,3)
   6
   >>> tracer(spam,1,2,3)
   call 1 to spam
   6
   这一替代方法可以用在任何函数上，且不需要特殊的@语法，但是和装饰器版本不同，它在代码中调用函数的每个地方都需要额外的语法。尽管装饰器不是必需的，但是它们通常是最为方便的。
   扩展——支持关键字参数
   下述代码时前面例子的扩展版本，添加了对关键字参数的支持：
   ?
   1
   2
   3
   4
   5
   6
   7
   8
   9
   10
   11
   12
   13
   14
   class tracer:
   def __init__(self,func):
   self.calls = 0
   self.func = func
   def __call__(self,*args,**kargs):
   self.calls += 1
   print('call %s to %s' %(self.calls, self.func.__name__))
   self.func(*args,**kargs)
   @tracer
   def spam(a, b, c):
   print(a + b + c)
   @tracer
   def egg(x,y):
   print(x**y)
   测试如下：
   ?
   1
   2
   3
   4
   5
   6
   7
   8
   9
   10
   11
   12
   >>> spam(1,2,3)
   call 1 to spam
   6
   >>> spam(a=4,b=5,c=6)
   call 2 to spam
   15
   >>> egg(2,16)
   call 1 to egg
   65536
   >>> egg(4,y=4)
   call 2 to egg
   256
   也可以看到，这里的代码同样使用【类实例属性】来保存状态，即调用的次数 self.calls。包装的函数和调用计数器都是针对每个实例的信息。
   使用 def 函数语法写装饰器
   使用 def 定义装饰器函数也可以实现相同的效果。但是有一个问题，我们也需要封闭作用域中的一个计数器，它随着每次调用而更改。我们可以很自然地想到全局变量，如下：
   ?
   1
   2
   3
   4
   5
   6
   7
   8
   9
   10
   11
   12
   13
   14
   calls = 0
   def tracer(func):
   def wrapper(*args,**kargs):
   global calls
   calls += 1
   print('call %s to %s'%(calls,func.__name__))
   return func(*args,**kargs)
   return wrapper
   @tracer
   def spam(a,b,c):
   print(a+b+c)
   @tracer
   def egg(x,y):
   print(x**y)
   这里 calls 定义为全局变量，它是跨程序的，是属于整个模块的，而不是针对每个函数的，这样的话，对于任何跟踪的函数调用，计数器都会递增，如下测试：
   ?
   1
   2
   3
   4
   5
   6
   7
   8
   9
   10
   11
   12
   >>> spam(1,2,3)
   call 1 to spam
   6
   >>> spam(a=4,b=5,c=6)
   call 2 to spam
   15
   >>> egg(2,16)
   call 3 to egg
   65536
   >>> egg(4,y=4)
   call 4 to egg
   256
   可以看到针对 spam 函数和 egg 函数，程序用的是同一个计数器。
   那么如何实现针对每一个函数的计数器呢，我们可以使用 Python3 中新增的 nonlocal 语句，如下：
   ?
   1
   2
   3
   4
   5
   6
   7
   8
   9
   10
   11
   12
   13
   14
   15
   16
   17
   18
   def tracer(func):
   calls = 0
   def wrapper(*args,**kargs):
   nonlocal calls
   calls += 1
   print('call %s to %s'%(calls,func.__name__))
   return func(*args,**kargs)
   return wrapper
   @tracer
   def spam(a,b,c):
   print(a+b+c)
   @tracer
   def egg(x,y):
   print(x**y)
   spam(1,2,3)
   spam(a=4,b=5,c=6)
   egg(2,16)
   egg(4,y=4)
   运行如下：
   ?
   1
   2
   3
   4
   5
   6
   7
   8
   call 1 to spam
   6
   call 2 to spam
   15
   call 1 to egg
   65536
   call 2 to egg
   256
   这样，将 calls 变量定义在 tracer 函数内部，使之存在于一个封闭的函数作用域中，之后通过 nonlocal 语句来修改这个作用域，修改这个 calls 变量。如此便可以实现我们所需求的功能。
   陷阱：装饰类方法
   【注意，使用类编写的装饰器不能用于装饰某一类中带 self 参数的的函数，这一点在 Python 装饰器基础中介绍过】
   即如果装饰器是如下使用类编写的：
   ?
   1
   2
   3
   4
   5
   6
   7
   8
   class tracer:
   def __init__(self,func):
   self.calls = 0
   self.func = func
   def __call__(self,*args,**kargs):
   self.calls += 1
   print('call %s to %s'%(self.calls,self.func.__name__))
   return self.func(*args,**kargs)
   当它装饰如下在类中的方法时：
   ?
   1
   2
   3
   4
   5
   6
   7
   class Person:
   def __init__(self,name,pay):
   self.name = name
   self.pay = pay
   @tracer
   def giveRaise(self,percent):
   self.pay *= (1.0 + percent)
   这时程序肯定会出错。问题的根源在于，tracer 类的__call__方法的 self——它是一个 tracer 实例，当我们用__call__把装饰方法名重绑定到一个类实例对象的时候，Python 只向 self 传递了 tracer 实例，它根本没有在参数列表中传递 Person 主体。此外，由于 tracer 不知道我们要用方法调用处理的 Person 实例的任何信息，没有办法创建一个带有一个实例的绑定的方法，所以也就没有办法正确地分配调用。
   这时我们只能通过嵌套函数的方法来编写装饰器。
   计时调用
   下面这个装饰器将对一个装饰的函数的调用进行计时——既有针对一次调用的时间，也有所有调用的总的时间。
   ?
   1
   2
   3
   4
   5
   6
   7
   8
   9
   10
   11
   12
   13
   14
   15
   16
   17
   18
   19
   20
   21
   22
   23
   24
   25
   26
   27
   28
   29
   30
   31
   32
   import time
   class timer:
   def __init__(self,func):
   self.func = func
   self.alltime = 0
   def __call__(self,*args,**kargs):
   start = time.clock()
   result = self.func(*args,**kargs)
   elapsed = time.clock()- start
   self.alltime += elapsed
   print('%s:%.5f,%.5f'%(self.func.__name__,elapsed,self.alltime))
   return result
   @timer
   def listcomp(N):
   return [x*2 for x in range(N)]
   @timer
   def mapcall(N):
   return list(map((lambda x :x*2),range(N)))
   result = listcomp(5)
   listcomp(50000)
   listcomp(500000)
   listcomp(1000000)
   print(result)
   print('allTime = %s'%listcomp.alltime)
   print('')
   result = mapcall(5)
   mapcall(50000)
   mapcall(500000)
   mapcall(1000000)
   print(result)
   print('allTime = %s'%mapcall.alltime)
   print('map/comp = %s '% round(mapcall.alltime/listcomp.alltime,3))
   运行结果如下：
   ?
   1
   2
   3
   4
   5
   6
   7
   8
   9
   10
   11
   12
   13
   listcomp:0.00001,0.00001
   listcomp:0.00885,0.00886
   listcomp:0.05935,0.06821
   listcomp:0.11445,0.18266
   [0, 2, 4, 6, 8]
   allTime = 0.18266365607537918
   mapcall:0.00002,0.00002
   mapcall:0.00689,0.00690
   mapcall:0.08348,0.09038
   mapcall:0.16906,0.25944
   [0, 2, 4, 6, 8]
   allTime = 0.2594409060462425
   map/comp = 1.42
   这里要注意的是，map 操作在 Python3 中返回一个迭代器，所以它的 map 操作不能和一个列表解析的工作直接对应，即实际上它并不花时间。所以要使用 list(map())来迫使它像列表解析那样构建一个列表
   添加装饰器参数
   有时我们需要装饰器来做一个额外的工作，比如提供一个输出标签并且可以打开或关闭跟踪消息。这就需要用到装饰器参数了，我们可以使用装饰器参数来制定配置选项，这些选项可以根据每个装饰的函数而编码。例如，像下面这样添加标签：
   ?
   1
   2
   3
   4
   5
   6
   7
   8
   9
   def timer(label = ''):
   def decorator(func):
   def onCall(*args):
   ...
   print(label,...)
   return onCall
   return decorator
   @timer('==>')
   def listcomp(N):...
   我们可以将这样的结果用于计时器中，来允许在装饰的时候传入一个标签和一个跟踪控制标志。比如，下面这段代码：
   ?
   1
   2
   3
   4
   5
   6
   7
   8
   9
   10
   11
   12
   13
   14
   15
   16
   17
   import time
   def timer(label= '', trace=True):
   class Timer:
   def __init__(self,func):
   self.func = func
   self.alltime = 0
   def __call__(self,*args,**kargs):
   start = time.clock()
   result = self.func(*args,**kargs)
   elapsed = time.clock() - start
   self.alltime += elapsed
   if trace:
   ft = '%s %s:%.5f,%.5f'
   values = (label,self.func.__name__,elapsed,self.alltime)
   print(format % value)
   return result
   return Timer
   这个计时函数装饰器可以用于任何函数，在模块中和交互模式下都可以。我们可以在交互模式下测试，如下：
   ?
   1
   2
   3
   4
   5
   6
   7
   8
   9
   10
   11
   12
   13
   14
   15
   16
   17
   18
   19
   20
   21
   22
   >>> @timer(trace = False)
   def listcomp(N):
   return [x * 2 for x in range(N)]
   >>> x = listcomp(5000)
   >>> x = listcomp(5000)
   >>> x = listcomp(5000)
   >>> listcomp
   <__main__.timer.<locals>.Timer object at 0x036DCC10>
   >>> listcomp.alltime
   0.0011475424533080223
   >>>
   >>> @timer(trace=True,label='\t=>')
   def listcomp(N):
   return [x * 2 for x in range(N)]
   >>> x = listcomp(5000)
   => listcomp:0.00036,0.00036
   >>> x = listcomp(5000)
   => listcomp:0.00034,0.00070
   >>> x = listcomp(5000)
   => listcomp:0.00034,0.00104
   >>> listcomp.alltime
   0.0010432902706075842</locals>
   有关 Python 编写函数装饰器相关知识小编就给大家介绍到这里，希望对大家有所帮助！
*** 2017-06-03 Saturday

**** MESSY exec-path 相关
   Source: [2017-06-03 Sat], d


   Tern is installed in /home/anthony/.npm-global/bin. (getenv "PATH") returns:

   "/home/anthony/bin:/home/anthony/.cabal/bin:/home/anthony/.local/bin:/home/anthony/.npm-global/bin:/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/lib/jvm/default/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl"
   But I think I just found my answer. I need to add /home/anthony/.npm-global/bin to my exec-path to use tern, not Emacs' PATH environment variable.

   Here's a page from the Emacs wiki for reference: https://www.emacswiki.org/emacs/ExecPath

**** MESSY 这篇关于 emacs 配置的文章，写的非常好
   Source: [2017-06-03 Sat], Warning (emacs): Please update your Org Protocol handler to deal with new-style links.


   1 InitEmacs

   1.1 准备工作

   1.1.1 安装 emacs
   emacs 安装参考: http://emacs.sexy/
   windows
   http://emacsbinw64.sourceforge.net/
   osx
   https://emacsformacosx.com/
   1.1.2 安装字体
   SourceCodePro
   微软雅黑
   1.1.3 Windows 设置 HOME 环境变量
   设置 HOME 环境变量为 D:\
   emacs 配置会放置到 D:/Documents/MyCore 下面
   1.1.4 Windows 安装 cgwin
   安装 cgwin 到 d:/Applications/cygwin 目录下.
   安装 cgwin 时选择安装 apt-cyg，apt-cyg 类似 apt-get 可用于安装其他软件
   https://github.com/transcode-open/apt-cyg
   安装 cgwin 时选择安装 git find grep lua 插件
   spacemacs 会用到 git
   emacs 的完整功能会用到 find grep
   cgwin 安装
   网易 cgwin 源
   http://mirrors.163.com/cygwin/
   1.1.5 pip 安装
   使用 python layer 需要安装 pip
   1.1.6 TAGS 支持
   ctags 支持
   Universal Ctags
   https://github.com/universal-ctags/ctags
   windows
   下面地址可以在线编译 universal-ctags 并下载编译好的文件。
   https://ci.appveyor.com/project/masatake/ctags/branch/master/job/yjgxuou78st55ik4/artifacts
   Exuberant Ctags
   以后可以考虑放弃 Exuberant Ctags 了
   osx 配置
   # Exuberant Ctags
   # step 1 install Exuberant Ctags
   brew install ctags
   # step 2 check ctags version
   ctags --version
   # ==> Exuberant Ctags 5.8, Copyright (C) 1996-2009 Darren Hiebert
   which ctags
   # ==> /opt/local/bin/ctags
   windows
   百度云里面去找 ctags58.zip
   etags 支持
   etags 比较弱可以放弃不用
   osx 配置
   使用 brew 进行安装
   使用 which/where 查看 etags 路径
   windows
   windows 下 ctags 放置在 D:\Applications\emacs\bin,在 PATH 环境变量中添加该路径即可,需要注意的是该配置要放到自己安装的 ctags 路径之后，否则会默认使用 emacs 目录下的 ctags。
   gtags 支持
   global
   安装
   osx 下安装
   # step 1 install GNU GLOBAL
   brew install global
   #下面的命令指定安装支持 pygments 和 ctags 的 global
   #brew install global --with-pygments --with-ctags

   # step 2 check global version
   global --version
   # ==> global (GNU GLOBAL) 6.5.4
   which global
   # ==> /usr/local/bin/global
   windows 下安装
   下载地址 http://adoxa.altervista.org/global/
   安装 GLOBAL 到 D:\Applications\GLOBAL 目录下
   环境变量 PATH 中添加 D:\Applications\GLOBAL\bin
   配置
   # windows config
   cp dot.win.globalrc ~/.globalrc
   # osx or linux config
   cp dot.globalrc ~/.globalrc
   globalrc 配置说明
   https://www.gnu.org/software/global/globaldoc_toc.html
   以‘#’开头的行为注释，一个记录由一个或多个字段组成，字段之间通过‘:’分割，以换行为结束。第一个字段必须为一个标签名称，剩余的字段为变量定义.
   有三种类型的变量：
   Boolean: This type has no value; existence of variable means true else false.
   Number: This type has a number value after ’#’.
   String: This type has a string value after ’=’.
   Tips:
   如果数据中包含‘:’或者是换行，你应该通过\\来引用它。
   当包含多个定义时，前面的定义被采纳。langmap gtags_parser 属于例外,他们的定义会被连接在一起。
   下面的代码指定了 exuberant-ctags 程序的路径
   :ctagscom=$HOME/Applications/ctags/exuberant-ctags/ctags:\
   global 使用
   global 教程
   https://www.gnu.org/software/global/globaldoc_toc.html
   # 生成 TAGS
   gtags
   # 查询 Print1_y 的定义
   global -x Print1_y
   # ==> Print1_y            1 y.cpp            void Print1_y()
   # 查询 Print1_y 的引用
   global -xr Print1_x
   # ==> Print1_y           10 x.cpp            Print1_y();
   # 使用正则表达式进行查询
   # The ‘-s’ command locates symbols which are not defined in ‘GTAGS’.
   global -sx 'Print[12].*'
   # ==> Print1_a            1 a.lua            function Print1_a()
   # ==> Print1_b            1 b.lua            function Print1_b()
   # ==> Print2_a            4 a.lua            function Print2_a()
   # ==> Print2_a            9 b.lua            Print2_a()
   # ==> Print2_b            9 a.lua            Print2_b()
   # ==> Print2_b            4 b.lua            function Print2_b()
   pygments
   osx 下安装
   sudo pip install Pygments
   pygmentize --version
   where pygmentize
   windows 下安装
   easy_install Pygments
   1.1.7 plantuml 支持
   安装 java runtime environment

   windows
   直接在软件中心搜索安装
   安装 graphviz

   osx
   # 安装 graphviz
   brew install graphviz
   # 查看 graphviz 安装路径
   brew info graphviz
   # 设置环境变量
   export GRAPHVIZ_DOT=/usr/local/bin/dot
   windows
   安装 graphviz
   http://www.graphviz.org/Download_windows.php
   设置环境变量
   My Computer/Properties/Advanced/Environment Variables
   Create GRAPHVIZ_DOT User Variables
   GRAPHVIZ_DOT = D:\Applications\Graphviz\bin\dot.exe
   安装 plantuml
   下载 plantuml.jar 到 ~/Documents/MyCore/Config/EmacsConfig/Resource 目录下
   http://plantuml.com/download
   测试
   java -jar plantuml.jar -version
   问题修复
   Error: unable to access jarfile
   windows 下选中 plantuml.jar 鼠标右键->属性->解除锁定
   修改 puml-mode.el 文件中 puml-preview 函数内容如下：
   ;; old
    (let ((ps (start-process "PUML" buf
                                "java" "-jar" (shell-quote-argument puml-plantuml-jar-path)
                                (puml-output-type-opt) "-p")))
   ;; new
    (let ((ps (start-process "PUML" buf
                                "java" "-jar" (convert-standard-filename puml-plantuml-jar-path)
                                (puml-output-type-opt) "-p")))
   参考
   https://github.com/skuro/puml-mode/issues/10
   1.2 安装 spacemacs

   # step0 安装 emacs
   emacs 安装参考:http://emacs.sexy/
   # step1 克隆 spacemacs 到~/.emacs.d
   mv ~/.emacs.d ~/.emacs.d.bak
   git clone https://github.com/syl20bnr/spacemacs ~/.emacs.d
   # step2 克隆插件到~/.emacs.d/elpa
   git clone https://github.com/wolfand11/_spacemacs_elpa.git ~/.emacs.d/elpa
   1.3 初始化配置

   1.3.1 配置说明
   ~\DOCUMENTS\MYCORE\CONFIG\EMACSCONFIG
   |   custom_init.el                        // 自定义初始化  用于调用 Config 目录下的配置脚本
   |   dot.emacs.el                          // 跨平台的.emacs 文件
   |   dot.emacs.local.el                    // 本地特化的 emacs 配置
   |   dot.globalrc                          // global 的配置文件
   |   dot.spacemacs.el                      // spacemacs 配置
   |   main.el                               // emacs 配置入口
   |
   +---Config
   |       init-environment-variable.el      // emacs 的环境变量
   |       init-plug-org.el                  // org 插件配置 -- 目前已经移到 wolfand11 spacemacs 插件中
   |       init-utility-function.el          // 功能函数     -- 目前已经移到 wolfand11 spacemacs 插件中
   |
   +---Plugin
   |   \---wolfand11      // wolfand11 spacemacs 插件
   |           config.el
   |           funcs.el
   |           packages.el
   |
   \---Resource
       \---snippets       // snippets
           \---org-mode
                   blog.snippet
                   eg.snippet
   1.3.2 安装配置
   cp dot.emacs.el ~/.emacs.el
   # you can change .emacs.local context for local
   cp dot.emacs.local.el ~/.emacs.local.el
   cp dot.spacemacs.el ~/.spacemacs
   # 配置 global
   cp dot.globalrc ~/.globalrc
   1.4 Emacs Debug 开启

   emacs --debug-init
   在 emacs 中执行以下命令，开启出错 Debug.
   M-x toggle-debug-on-error
   1.5 问题修复

   1.5.1 emacs 中命令找不到
   查看 exec-path 变量，是否包含了指定命令的路径.
   1.5.2 emacs 命令调用不正确
   查看 exec-path 变量中，指定命令是否比同名的另一个命令靠前。
   例如：window linux osx 下都有 find 命令，但是他们参数并不同，在 windows 下，要确保 cgwin 的 find 命令要靠前。
   1.5.3 spacemacs 自动安装插件失败
   在.emacs.el 文件中注释或者添加下面的代码
   (package-initialize)
   1.5.4 lua 模式下代码缩进始终为 2 个空格
   这是因为 spacemacs 中特写了 lua-indent-level
   直接修改/layers/+lang/lua/packages.el 中 lua-indent-level 的值为 4
   1.5.5 自动补全支持
   c/c++自动补全支持
   (c-c++ :variables c-c++-enable-clang-support t)
   lua 自动补全支持
   ;; config.el 中定义
   (spacemacs|defvar-company-backends lua-mode)
   ;; package.el 中添加
   (defun wolfand11/post-init-company ()
     (progn
       (setq company-minimum-prefix-length 1
             company-idle-delay 0.08)

       (when (configuration-layer/package-usedp 'company)
         (spacemacs|add-company-hook shell-script-mode)
         (spacemacs|add-company-hook makefile-bsdmake-mode)
         (spacemacs|add-company-hook sh-mode)
         (spacemacs|add-company-hook lua-mode)
         (spacemacs|add-company-hook nxml-mode)
         (spacemacs|add-company-hook conf-unix-mode)
         (spacemacs|add-company-hook json-mode)
         (spacemacs|add-company-hook graphviz-dot-mode)
         )
       ))

   (defun wolfand11/post-init-lua-mode ()
     (progn
       (add-hook 'lua-mode-hook 'evil-matchit-mode)
       (add-hook 'lua-mode-hook 'smartparens-mode)
       (setq lua-indent-level 4)
       ;;; add lua language, basic, string and table keywords.
       (with-eval-after-load 'lua-mode
         (require 'company-keywords)
         (push '(lua-mode  "setmetatable" "local" "function" "and" "break" "do" "else" "elseif" "self" "resume" "yield"
                           "end" "false" "for" "function" "goto" "if" "nil" "not" "or" "repeat" "return" "then" "true"
                           "until" "while" "__index" "dofile" "getmetatable" "ipairs" "pairs" "print" "rawget" "status"
                           "rawset" "select" "_G" "assert" "collectgarbage" "error" "pcall" "coroutine"
                           "rawequal" "require" "load" "tostring" "tonumber" "xpcall" "gmatch" "gsub"
                           "rep" "reverse" "sub" "upper" "concat" "pack" "insert" "remove" "unpack" "sort"
                           "lower") company-keywords-alist))

       ))
   elisp 自动补全错误
   (defun wolfand11/post-init-emacs-lisp ()
     (remove-hook 'emacs-lisp-mode-hook 'auto-compile-mode))
   1.5.6 修改 tab 显示
   ;; 控制 tab 对应的空格数目
   (setq tab-width 4)
   (setq default-tab-width 4)
   1.5.7 Symbol’s value as variable is void: company-backends-xxxx
   导出 org 文件为 html 时，会提示这个错误。这是因为 company 配置错误。修改方法如下：
   ;; 修改 company 配置
   (defun wolfand11/post-init-company ()
     (progn
       (when (configuration-layer/package-usedp 'company)
         (spacemacs|add-company-backends : modes lua-mode nxml-mode json-mode ))
       ))
   参考链接：https://github.com/syl20bnr/spacemacs/issues/8496
   1.5.8 MELPA 的包不可见
   spacemacs 默认设置是支持 MELPA 和 marmalade 的。请检查.emacs.el 中是不是添加了下面的代码，导致默认设置出错。
   (package-initialize)
   参考链接：https://github.com/syl20bnr/spacemacs/issues/4402
   2 Init AutoHotKey

   执行 init.ahk 脚本 (点击打开脚本，就会自动执行)
   开机自动执行 init.akh 脚本
   # 将 init.ahk 的快捷方式复制到下面路径
   cp init-shortcut.ahk.lnk "C:\Users\guodong\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup"
   # 查看自动运行路径下的文件
   ls -al 'C:\Users\guodong\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup'
   3 InitVim

   3.1 安装 vim

   osx
   https://github.com/macvim-dev/macvim/releases
   windows
   直接在软件中心搜索安装
   3.2 初始化配置

   cp dot.vimrc ~/.vimrc
   :: 在 windows 下 vim 的配置为_vimrc
   cp dot.vimrc ~/_vimrc
   4 InitVisualStuido

   4.1 配置

   4.1.1 设置代码格式
   工具-选项-文本编辑器-C#-格式设置
   4.2 安装各种插件

   4.2.1 VsVim
   在 Extension 中搜索 VsVim 进行安装
   重启 VisualStudio
   4.2.2 Visual Assist
   http://www.wholetomato.com/
   C:盘根目录下搜索 VA_X.dll 可以找到该插件的安装目录
   4.2.3 C# Outline 2015
   在 Extension 中搜索 VsVim 进行安装
   该插件可以让 VS 支持函数内语句的折叠
   4.2.4 Nuget
   windows 包管理软件。
   http://www.nuget.org/
   使用方法
   为 VisualStudio 安装 NuGet.Tools.vsix 插件. （或者在 Extension 中搜索 NuGet 进行安装）
   VisualStudio 中 Quick Launch 中输入 package manager,选择打开 package mangager 窗口.
   搜索 Autofac，选择合适的版本。进行安装。
   5 Shell Tools

   5.1 windows babun

   http://babun.github.io/
   ::在 cmd 中运行 install 脚本
   install /target D:\Applications\babun
   5.2 oh-my-zsh 配置

   基本安装配置参考 oh-my-zsh 官网:http://ohmyz.sh/

   配置文件列表:
   dot_zshrc
   dot_zshrc.custom
   dot_zshrc.local
   Soliah.zsh-theme（主题配置）

   配置说明:
   通用的自定义配置放在 dot_zshrc.custom 中，本地的自定义配置放在 dot_zshrc.local 中，
   dot_zshrc 会加载 dot_zshrc.custom 和 dot_zshrc.local
   调用下面的命令进行配置:
   cp dot_zshrc ~/.zshrc
   cp dot_zshrc.local ~/.zshrc.local
   cp Soliah.zsh-theme ~/.oh-my-zsh/themes/Soliah.zsh-theme
   6 SSH Config

   rm -R ~/.ssh
   cp -R SSHConfig ~/.ssh
   chmod 600  ~/.ssh/id_rsa
   password:******gh

   # 配置.ssh 路径， 对 /etc/passwd 文件内容做如下修改：
   # 旧内容 - Administrator:unused:500:513:Dong Guo,U-WIN-10\Administrator,S-1-5-21-2357673517-1225067227-1474234480-500:/cygdrive/c/Users/Administrator:/bin/zsh
   # 新内容 - Administrator:unused:500:513:Dong Guo,U-WIN-10\Administrator,S-1-5-21-2357673517-1225067227-1474234480-500:/cygdrive/d                    :/bin/zsh

   # 可以使用下面方法调试 ssh 对 private key 的选择
   ssh -vT git@github.com
   ssh -vT git@git.coding.net
   本文标题:Init My Core
   文章作者:wolfand11
   发布时间:2016-09-08, 00:00:00
   最后更新:2017-04-02, 21:45:46
   原始链接:http://wolfand11.coding.me/2016/09/08/tools/InitMyCore/
   许可协议: "署名-非商用-相同方式共享 4.0" 转载请保留原文链接及作者。

**** MESSY 开两个 zshell in emacs

~M-x rename buffer~
给原来的 zshell 重命名之后，
就可以继续利用这个命令，再开一个 zshell
~M-x shell~
*** 2017-06-04 Sunday

**** MESSY Dependancy injection
https://www.youtube.com/watch?v=GB8k2-Egfv0
https://www.youtube.com/watch?v=IKD2-MAkXyQ&list=PLM-218uGSX3CiutA_kFUe1bvS0x6P9S_m&index=2

这两个教程很好的解释了什么是 dependancy injection

简单来说，dependancy injection 就是 ·「找代理」

我是个超市，                                      ---> target class

我想进货：服饰类，食品类，家电类 等等。               ---> many dependant class

我不可能自己去进货，检测，谈判，然后再去卖，这得累死。   ---> coupling

所以我对外招商，每一个大的种类招一个代理商。           ---> super class of <dependant classes>

代理商负责给我进货，检测，谈价

我只负责·「选择代理商」                            ---> super class's instant as variable
                                                ---> a setter() method to select super class

我需要货物，但不·「直接」依赖货物，是通过代理商·「间接」实现的

这种·「非直接依赖」就叫做 dependancy injection

Dependancy Injection
Dependency is pushed into the class from the OUTSIDE,
which means you should not instantiate denpendencies by new operator
from inside a class, instead, take it as a constructor PARAMETER or
via a SETTER.

Dependency Inversion Principle
DIP is that code should DEPEND UPON ABSTRACTIONS.
By depend upon abstraction we're decoupling our implementations
from each other.

Dependency Injection Container
You don't own commodities, you just own many suppliers.

·「总结依赖注入步骤」：
1. 抽象依赖为接口
2. 持有依赖为变量
3. 公有化设置依赖

**** MESSY A great youtuber teahcing SOAP, Spring, RESTful
https://www.youtube.com/channel/UCYt1sfh5464XaDBH0oH_o7Q

**** MESSY a great course of wangJiaLin about apache spark and scala
https://www.youtube.com/channel/UCmzfq5WPcApoj8-XCrJMBig
*** 2017-06-05 Monday

**** MESSY watch youtube [How to speed up a python program 11400times]
https://www.youtube.com/watch?v=e08kOj2kISU

**** MESSY pdf-tool 查看 pdf 文件乱码问题
根据 github 安装好所有依赖以后，仍让乱码，
最后通过 *安装 xpdf* 解决
*** 2017-06-06 Tuesday

**** MESSY How to use macro recorder in emacs

   Source: [2017-06-06 Tue],

   开始录制宏

   可以按 "C-x (" 也可以按 "F3" 开始录制宏，接下来的操作就会被录制下来。例如：在录制之前，先将 emacs 切成两个窗口(C-x 2 或 C-x 3) 并将光标放置到正确位置，开始录制宏。

   处理数据

   这个过程就是为了得到一个可以循环操作的宏，可以包括查找、复制、删除等一切 emacs 中的正常操作。例如：从 1 个窗口中，拷贝需要的数据后，移动到另外一个窗口，粘贴数据，将光标移动到下一个位置，最后再将光标回到原来的窗口位置。

   循环执行宏

   "C-x e" 执行一次，"C-u 执行次数 C-x e" 将会执行设定的次数遍，也可以用 "C-执行次数 C-x e"
   执行完毕后，可以用 “M-x name-last-kbd-macro”为最后一次的宏命令命名，
   再有，可以将宏命令，保存下来，设定到 emacs 的加载文件中，这样以后打开软件就可以使用这个宏了。

   (load-file "~/macros")

   打开 "~/macros" 文件，移动到末尾，执行“M-x insert-kbd-macro”输入刚才命名的名字，就将录制的宏命令保存下来了。
   当你要使用这个宏的时候，只要用`M-x <宏名>‘就可以调用你的宏了。

   推荐
   其实，这些操作在文档中有说明，只是根据自己的经验和习惯设定不同的宏，确实可以将一些很处理重复的，很麻烦的数据文件变得很简单，很整洁！我很喜欢这个功能，极力推荐给大家使用！

**** MESSY Advanced Python course in NYU 非常全面的 python 教程，从初级到高级，纽约大学 https://www.youtube.com/channel/UCHEGSn2vswSkH1LNXpfQ3IA/playlists :youtube:edu:cs:python:
*** 2017-06-27 Tuesday

**** MESSY 如何快速给 org 文字添加 bold, italic, underline 等格式
     如何快速给文字添加：加粗，斜体，下划线 等格式？
     1. vim 模式下选中；
     2. 命令：
        1) ~, x b~ : bold
        2) ~, x i~ : italic
        1) ~, x u~ : underline

**** MESSY how to install eclipse by its installer in ubuntu
     1. Download the installer here
     2. Extract the archive, e.g the 64-bit version
        ~tar xf eclipse-inst-linux64.tar.gz~
     3. Change your folder
        ~cd eclipse-installer~
     4. Run the installer WITHOUT sudo to UPGRADE the installer
        ~./eclipse-inst~

**** MESSY How to install eclim
     安装 eclipse 的 package 版本，不要使用 installer

**** MESSY Setting up Emacs for java dev
     http://www.goldsborough.me/emacs,/java/2016/02/24/22-54-16-setting_up_emacs_for_java_development/
*** 2017-06-28 Wednesday

**** MESSY 使用 gradle 来编译和运行 eclim project
     必须是 ~src/main/java~ 的目录结构，否则提示找不到 main class

**** MESSY how to activate a virtual env in anaconda
     ~source activate <env_name>~

**** MESSY 入党信息
     1. 姓名：袁龙     2. 性别：男    3;
** 2017-08 August
*** 2017-08-02 Wednesday

**** MESSY color unicode to color
     最简单的方式是直接 M-x rainbow-mode
*** 2017-08-06 Sunday

**** MESSY 关于 conda 如何管理包
我想为某个 conda 的虚拟环境安装包，
比如为我的虚拟环境 tensorflow 安装 feedparser 包该怎么做呢？
1. 如果这个包已经被 conda 下载过：conda install feedparser
   那么这个包其实已经存在你电脑里了，只是没有被包含进虚拟环境中，这时
   可以直接 source active tesnsorflow 激活该虚拟环境
   然后 conda install feedparser 即可
2. 如果还没有通过 conda 下载过，就可以直接下载，然后在虚拟环境中再下载一次
   这样做其实只下载了一次，激活虚拟环境后下载只是将其包含进虚拟环境的包
   列表中而已，并没有执行下载动作。
*** 2017-08-08 Tuesday

**** MESSY 配置 emacs jupyter note book 过程
     1) 在 ~spc f e d~ 配置文件中加入 ~ipython-notebook~ laye
     2) shell 启动 jupyter notebook: ~jupyter notebook~
     3) 步骤 2 会显示网址 ,port 和 token
     4) emacs 中 M-x ~ein:notebooklist-login~, 提示输入 _port 和 token_
     5) emacs 中 M-x ~ein:notebooklist-open~ 即可打开
** 2017-09 September
*** 2017-09-05 Tuesday
*** 2017-09-06 Wednesday

**** MESSY  [[https://www.youtube.com/watch?v=KzFe4T0PwQ8&t=137s][(72) Apache Spark vs. MapReduce #WhiteboardWalkthrough - YouTube]]
   Captured On: [2017-09-06 Wed 22:43]
   非常好的，解释了很多 spark 基本且重要的概念

**** MESSY  [[http://training.databricks.com/workshop/sparkcamp.pdf][]]
   Captured On: [2017-09-06 Wed 22:55]
   spark 初级教程的 ppt
   https://www.youtube.com/watch?v=EuWDz2Vb1Io
*** 2017-09-19 Tuesday

**** MESSY 关于 ensime 的一些神奇 bug
事情经过：
1. 开始使用 ensime，直接输入 <spc><spc> ensime 没出什么问题
2. 经过查看 ensime 文档： <spc> h <spc> 得知每个 project 都需要一个 ensime session
3. coursera 下载第一个课程作业，使用上述方法没问题，但是第二天再开机就出现问题了，提示
   ~Error reading configuration file, nil: (wrong-type-argument stringp nil)~
4. 找了半天不知道怎么错的，然后无意中按了一个命令 ~<spc> <spc> ensime-sbt-doclean~ 好像有可以了

**** 就今天知道的关于 ensime sbt 的一些信息
     似乎 sbt 本身有一个默认的编译地址： ~/target/scala-2.12
     如果工程没有声明自己的依赖和编译目的地，就会编译到上述目录中
* 数据挖掘：理论与算法
**** introduction
     在数据科学，DRIP 是什么的缩写（不含标点符号）data rich information poor
     weka is simple, and has GUI. you can glance data mining by it

     - *difference between cluster and classification*
     | cluster(group) | no label | unsupervisor | no predefined concept                 |                                 |
     | PCA            |          |              |                                       |                                 |
     |----------------+----------+--------------+---------------------------------------+---------------------------------|
     | classification | label    | supervisor   | has predefined concept eg,male/femail | need a "teacher" to give labels |
     | LDA            |          |              |                                       |                                 |

     - *Association Rule*
     {milk,bear} => {paper}

     - *what is a linear regression?*
       not the line produced by the polynormial. but the /delta*x is linear

     - *GIGO*
       garbage input garbage output

     - *data preprocessing is very annoy, but important*

     - *selection between decision tree and nerual netwrok*
       decision tree, can produce a rule, has a good interpretability.
       nerual network is diffcult to interpret, to explain
     - *lottery cannot be predict by data mining.*
       basical data is random!
     - PCA is unsupervisor learning. no  label.
     - LDA is supervisor   learning. has lable
     - the most important thing to dimensionality reduction is choose the direction of projection
     - Neural Network/ Bayes-Decision-Tree are all 分类器
**** MESSY Tsinghua Data analysis exercise-Bayes and Decision-Tree, 3.3 exercise
     Source: [2017-03-28 Tue], [[http://www.xuetangx.com/courses/course-v1:TsinghuaX+80240372X+sp/courseware/36f14de73ded47a29068e083d79900be/802b4060eb024961ad0d945b607d97e2/][单选题 | 数据、规则与树 | 80240372X 课件 | 学堂在线]]


     单选题  (1/1 分数)
     作为一种分类器，决策树模型的主要优点是：
     - [ ] 训练时间短
     - [X] 可解释性好 - 正确
     - [ ] 善于处理缺失值 鲁棒性好

     单选题  (1/1 分数)
     下列哪一种情况被称为过学习现象：
     - [ ] 在训练集上 A 优于 B，在测试集上 A 也优于 B
     - [X] 在训练集上 A 优于 B，在测试集上 B 优于 A - 正确
     - [ ] 相对于分类数据集，决策树过于简单 在训练集上决策树的误差很小

     单选题  (1/1 分数)
     任何一个候选属性在生成的决策树中：
     - [ ] 必须被使用
     - [ ] 只能被使用一次
     - [X] 可以被使用多次 - 正确
     - [ ] 可以在任意位置被使用多次

     单选题  (1/1 分数)
     以下关于决策树的说法正确的是：
     - [ ] 决策树越复杂，分类能力越强
     - [ ] 在性能相同的情况下，通常选择能充分利用各种属性的决策树
     - [ ] 对于某一个数据集，只有一个决策树可以将其完美分开
     - [X] 对于某一个数据集，可以生成多个决策树 - 正确

     多选题  (1/1 分数)
     奥卡姆的剃刀指的是：
     - [X] Entities are not to be multiplied beyond necessity.,
     - [X] Among competing hypotheses, the one with the fewest assumptions should be selected.,
     - [X] The simplest explanation is usually the correct one., - 正确
     - [ ] 中世纪英国上流社会的一种生活用品

**** MESSY Tsinghua Data analysis exercise-Bayes and Decision-Tree, 3.4 exercise
     单选题  (1/1 分数)
     为什么一般不推荐在决策树中使用“生日”属性：
     - [ ] 星座信息更有说服力
     - [ ] 容易造成过学习 - 正确
     - [ ] 可能的取值太多，计算量过大
     - [ ] 两个人可能生日相同
     提交  显示答案 揭示答案

     单选题  (1/1 分数)
     决策树模型中建树的基本原则是：
     - [ ] 取值多的属性应放在上层
     - [ ] 取值少的属性应放在上层
     - [ ] 信息增益大的属性应放在上层 - 正确
     - [ ] 应利用尽可能多的属性
     提交  显示答案 揭示答案

     多选题  (1/1 分数)
     哪些情况下必须停止树的增长：
     - [X] 当前数据子集的标签一致,
     - [X] 没有更多可用属性,
     - [X] 当前数据子集为空, - 正确
     - [ ] 当前训练误差已经较低
     提交  显示答案 揭示答案

     单选题  (1/1 分数)
     关于决策树剪枝操作正确的描述是：
     - [ ] 从中间节点开始
     - [ ] 从叶节点开始 - 正确
     - [ ] 有助于保持树的平衡
     - [ ] 可以有效降低训练误差
     提交  显示答案 揭示答案

     单选题  (1/1 分数)
     在决策树模型中，校验集的用途是：
     - [ ] 用于校验模型的训练误差
     - [ ] 用于校验模型的测试误差
     - [ ] 用于校验模型的正确性
     - [ ] 用于控制对模型的剪枝操作 - 正确
     提交  显示答案 揭示答案

     单选题  (1 满分)
     决策树模型中应如何妥善处理连续型属性：
     - [ ] 直接忽略
     - [ ] 利用固定阈值进行离散化
     - [X] 根据信息增益选择阈值进行离散化
     - [ ] 随机选择数据标签发生变化的位置进行离散化 - 不正确
     提交

**** MESSY Tsinghua Data analysis exercise-Bayes and Decision-Tree, 3.1 exercise
   Source: [2017-03-28 Tue], [[http://www.xuetangx.com/courses/course-v1:TsinghuaX+80240372X+sp/courseware/36f14de73ded47a29068e083d79900be/d713d4dda32b46cfbcdef4d8e5a5237f/][单选题 | 贝叶斯奇幻之旅 | 80240372X 课件 | 学堂在线]]


   单选题  (1/1 分数)
   有监督的学习和无监督的学习的根本区别在于：


   学习过程是否需要人工干预 学习样本是否需要人工标记 学习样本是否需要人工标记 - 正确 学习结果是否需要人工解释 学习参数是否需要人工设置
     显示答案 揭示答案
   单选题  (1/1 分数)
   已知池中有两种鱼，比例为 7:3，若随机捞上一条，按照 70%和 30%概率随机猜测其种类，则整体误差最接近于：


   20% 30% 40% 40% - 正确 50%
     显示答案 揭示答案
   单选题  (1/1 分数)
   2015 年 10 月，中国共产党第十八届中央委员会第五次全体会议公报指出：坚持计划生育基本国策，积极开展应对人口老龄化行动，实施全面二孩政策。提问：小明的妈妈有两个孩子，已知其中一个是男孩儿，问另一个也是男孩儿的概率是：


   二分之一 三分之一 三分之一 - 正确 四分之一 真的不关我的事
     显示答案 揭示答案
   单选题  (1 满分)
   已知甲乙丙三人射击命中率分别为 0.8，0.6 和 0.5，若每人各开一枪，则目标被命中的概率最接近：


   - 未答复 0.85 0.90 0.95 1.00

   单选题  (1/1 分数)
   当化验报告呈阳性的时候，正确的做法是：


   心如死灰，万念俱灭 散尽家财，及时行乐 置若罔闻，我行我素 及时复检，防止假阳性 及时复检，防止假阳性 - 正确
     显示答案 揭示答案

**** MESSY Tsinghua Data analysis exercise-Bayes and Decision-Tree, 3.2 exercise
   Source: [2017-03-28 Tue], [[http://www.xuetangx.com/courses/course-v1:TsinghuaX+80240372X+sp/courseware/36f14de73ded47a29068e083d79900be/b0aa19f06a424af899aadebe130799c5/][单选题 | 朴素是一种美德 | 80240372X 课件 | 学堂在线]]


   朴素贝叶斯分类器的朴素之处在于：


   只能处理低维属性 只能处理离散型属性 分类效果一般 属性之间的条件独立性假设 属性之间的条件独立性假设 - 正确
     显示答案 揭示答案
   单选题  (1/1 分数)
   以下关于两个变量 X 和 Y 说法正确的是：


   若独立一定不相关 若独立一定不相关 - 正确 若不相关一定独立 若独立不一定不相关 我已经晕了
     显示答案 揭示答案
   单选题  (1/1 分数)
   两个事件 A 和 B 条件独立指的是：

   P(A, B)=P(A)P(B) P(A, B)=P(A|B)P(B) P(A|B, C)=P(A|C) P(A|B, C)=P(A|C) - 正确 P(A|B)=P(A)
     显示答案 揭示答案
   单选题  (1/1 分数)
   以下关于拉普拉斯平滑说法正确的是：

   防止计算条件概率时分母为零 防止计算条件概率时分子为零 防止计算条件概率时分子为零 - 正确 用于解决训练集中的噪声 用于解决训练集中的异常值
     显示答案 揭示答案
   单选题  (1/1 分数)
   在文本分类应用中，关于词袋模型的描述正确的是：


   任何一个单词只能存在于某一个词袋中 一个单词可能存在于多个词袋中但频率不同 一个单词可能存在于多个词袋中但频率不同 - 正确 所有词袋中单词的并集就等同于词汇表 词袋模型描述的是单词在所有文本中出现的频率

**** MESSY Tsinghua Data analysis exercise-Neural Networks, 4.1
单选题  (1/1 分数)
我们很难刻意忘掉一个人的原因是：


记性好，没办法 刻骨铭心，矢志不渝 天长地久有时尽，此情绵绵无绝期 神经元的大规模分布式信息存储机制 神经元的大规模分布式信息存储机制 - 正确
提交  显示答案 揭示答案
单选题  (1/1 分数)
如图所示的感知机（阈值为 0）实现的逻辑功能是：
#+BEGIN_SRC ditta

#+END_SRC

或门 与门 与门 - 正确 非门 与非门
提交  显示答案 揭示答案
单选题  (1/1 分数)
在感知机的判决函数中，w0 的作用是：

为了后续学习算法推导的方便 其实在实际中可以略去 控制判决平面到原点的距离 控制判决平面到原点的距离 - 正确 控制判决平面的方向

**** MESSY Tsinghua Data analysis exercise-Neural Networks, 4.2


若神经元的误差对某输入的权重的偏导大于零说明：


权重应增加 权重应减小 权重应减小 - 正确 不能确定
提交  显示答案 揭示答案
单选题  (1/1 分数)
根据 Delta 规则，在 stochastic learning 模式下，若神经元的实际输出大于期望输出，权重应：

顺势而为：增大 反其道而行之：减小 若相应输入大于零：减小 若相应输入大于零：减小 - 正确 若相应输入小于零：减小
提交  显示答案 揭示答案
单选题  (1/1 分数)
以下关于感知机说法正确的是：

在 batch learning 模式下，权重调整出现在学习每个样本之后 只要参数设置得当，感知机理论上可以解决各种分类问题 感知机的训练过程可以看成是在误差空间进行梯度下降 感知机的训练过程可以看成是在误差空间进行梯度下降 - 正确 感知机的激励函数必须采用门限函数

**** MESSY Tsinghua Data analysis exercise-Neural Networks, 4.3
单选题  (1/1 分数)
以下关于感知机说法正确的是：

多层感知机比感知机只多了一个隐含层 感知机只能形成线性判决平面，无法解决异或问题 感知机只能形成线性判决平面，无法解决异或问题 - 正确 多层感知机可以有多个隐含层，但是只能有一个输出单元 隐含层神经元的个数应当小于输入层神经元的个数
提交  显示答案 揭示答案
单选题  (1/1 分数)
多层感知机解决线性不可分问题的原理是：

分而治之，对原始问题空间进行划分 将原始问题向更高维空间映射 在输出层和隐含层之间形成非线性的分界面 将原始问题在隐含层映射成线性可分问题 将原始问题在隐含层映射成线性可分问题 - 正确
提交  显示答案 揭示答案
多选题  (1/1 分数)
采用 Sigmod 函数作为激励函数的主要原因是：

有固定的输出上下界, 导数存在解析解, 处处可导, - 正确 有固定的输出上下界 计算复杂度较低 导数存在解析解 处处可导

**** MESSY Tsinghua Data analysis exercise-Neural Networks, 4.4
单选题  (1/1 分数)
在误差逆传播算法中，输出层神经元权重的调整机制和感知机的学习规则相比：

考虑到线性不可分问题，学习规则更为复杂 一模一样，等价于多个感知机 遵循相同的原理，激励函数可能有所不同 遵循相同的原理，激励函数可能有所不同 - 正确 所有输出层神经元的权重需要同步调整
提交  显示答案 揭示答案
单选题  (1/1 分数)
在误差逆传播算法中，隐含层节点的误差信息应当：

根据自身的期望输出和实际输出的差值计算 根据所有输出层神经元的误差的均值计算 根据自身下游神经元的误差进行加权计算 根据自身下游神经元的误差进行加权计算 - 正确 根据自身下游神经元的误差的均值计算
提交  显示答案 揭示答案
单选题  (1/1 分数)
为了克服学习空间中存在的局部最优点应当：

尝试从不同的初始点开始训练 尝试从不同的初始点开始训练 - 正确 将权重初始化为接近于 0 的值 采用较小的学习率 增加隐含层神经元个数
提交  显示答案 揭示答案
单选题  (1/1 分数)
关于学习率参数的设置，正确的描述是：

较大的值有助于提高算法的收敛稳定性 较小的值有助于提高算法的收敛速度 在开始阶段应该较大，然后逐渐减小 在开始阶段应该较大，然后逐渐减小 - 正确 在开始阶段应该较小，然后逐渐增大
提交  显示答案 揭示答案
单选题  (1/1 分数)
在权重更新公式中引入冲量的主要目的是：

提高算法的收敛精度 提高算法的稳健性 提高算法的全局优化能力 有助于摆脱误差平缓区域

**** MESSY Tsinghua Data analysis exercise-SVM, 5.1
单选题  (1/1 分数)
在 SVM 领域中，margin 的含义是：

盈利率 马金 间隔 间隔 - 正确 保证金
提交  显示答案 揭示答案
单选题  (1/1 分数)
线性 SVM 和一般线性分类器的区别主要是：

是否进行了空间映射 是否确保间隔最大化 是否确保间隔最大化 - 正确 是否能处理线性不可分问题 训练误差通常较低
提交  显示答案 揭示答案
单选题  (1/1 分数)
为什么通常要选择 margin 最大的分类器？

所需的支持向量个数最少 计算复杂度最低 训练误差最低 有望获得较低的测试误差 有望获得较低的测试误差 - 正确
提交  显示答案 揭示答案
单选题  (1/1 分数)
假设超平面为 w*x+b=0，其 margin 的大小为：

1/|w| 2/|w| 2/|w| - 正确 |b|/|w| 2|b|/|W|
提交  显示答案 揭示答案
单选题  (1/1 分数)
支持向量（support vectors）指的是：

对原始数据进行采样得到的样本点 决定分类面可以平移的范围的数据点 决定分类面可以平移的范围的数据点 - 正确 位于分类面上的点 能够被正确分类的数据点

**** MESSY Tsinghua Data analysis exercise-SVM, 5.2
     单选题  (1/1 分数)
在 SVM 的求解过程中，支持向量与 alpha 的关系是：

alpha=0 的数据点是支持向量 alpha>0 的数据点是支持向量 alpha>0 的数据点是支持向量 - 正确 alpha<0 的数据点是支持向量 两者没有固定关系
提交  显示答案 揭示答案
单选题  (1/1 分数)
在 SVM 当中，主要的运算形式是：

向量内积 向量内积 - 正确 矩阵乘法 矩阵转置 矩阵分解
提交  显示答案 揭示答案
单选题  (1/1 分数)
软间隔（soft margin）的主要用途是：

解决线性不可分问题 解决不完全线性可分问题 解决不完全线性可分问题 - 正确 降低算法时间复杂度 提高算法分类精确
**** MESSY Tsinghua Data analysis exercise-SVM, 5.3
     单选题  (1/1 分数)
在 SVM 当中进行空间映射的主要目的是：

降低计算复杂度 提取较为重要的特征 对原始数据进行标准化 提高原始问题的可分性 提高原始问题的可分性 - 正确
提交  显示答案 揭示答案
单选题  (1/1 分数)
对于 SVM，在映射后的高维空间直接进行计算的主要问题是：

模型可解释性差 计算复杂度高 计算复杂度高 - 正确 容易出现奇异矩阵 容易出现稀疏矩阵
提交  显示答案 揭示答案
单选题  (1/1 分数)
所谓 kernel trick，指的是：

利用在原始空间定义的函数替代高维空间的向量内积操作 利用在原始空间定义的函数替代高维空间的向量内积操作 - 正确 利用在高维空间定义的函数替代原始空间的向量内积操作 核函数的导数具有简单的解析解，简化了运算 核函数具有固定的上下界，可以输出（-1, +1）区间中的连续值
提交  显示答案 揭示答案
单选题  (1 满分)
通过运用核函数，我们可以：

 提高算法的可解释性 生成数量较少的支持向量 生成数量较多的支持向量 避免高维空间运算，降低算法复杂度
**** MESSY Tsinghua Data analysis exercise-SVM, 5.4
     单选题  (1 满分)
SVM 核心技术的发展经历了：

 10 年 20 年 30 年 40 年
提交
单选题  (1 满分)
线性 SVM 思想最初被提出的时候，你在：

 上幼儿园 上小学 上中学 不知道在哪儿
提交
单选题  (1/1 分数)
一个分类模型的 capacity 指的是：

能够解决几分类问题 能解决多大规模的问题 能将多少个点分开，不论如何分配标签 能将多少个点分开，不论如何分配标签 - 正确 能达到的精确度
提交  显示答案 揭示答案
单选题  (1/1 分数)
为什么当两个模型的训练误差相同或接近的时候，通常会选择比较简单的一个：

复杂模型的测试误差一定较大 简单模型的测试误差一定较小 在相同置信度条件下，复杂模型的测试误差上界较大 在相同置信度条件下，复杂模型的测试误差上界较大 - 正确 只是一种经验，并没有理论依据
提交  显示答案 揭示答案
多选题  (1/1 分数)
Владимир Наумович Вапник（Vladimir Vapnik）为什么是真神：

惊天引用次数, 支持向量机开天辟地, 统计学习理论一代宗师, 目光如炬，深不可测, - 正确 惊天引用次数 支持向量机开天辟地 统计学习理论一代宗师 目光如炬，深不可测
**** MESSY Tsinghua Data analysis exercise-Clustering, 6.1
     单选题  (1/1 分数)
聚类中的簇与分类中的类的关系是：

簇即是类、类即是簇 簇是类的一种具体表现形式 类是簇的一种具体表现形式 不是一码事，但实际中有一定联系 不是一码事，但实际中有一定联系 - 正确
提交  显示答案 揭示答案
单选题  (1/1 分数)
在市场营销中，聚类最有可能帮助经营者：

对客户群进行划分 对客户群进行划分 - 正确 进行商品推荐 识别优质客户 辅助商品定价
提交  显示答案 揭示答案
多选题  (1/1 分数)
一个好的聚类算法应当具备哪些潜质：

能够处理非球形的数据分布, 能够处理噪点和离群点, 对样本输入序列不敏感, 对海量数据的可扩展性, - 正确 能够处理非球形的数据分布 能够处理噪点和离群点 对样本输入序列不敏感 对海量数据的可扩展性
提交  显示答案 揭示答案
单选题  (1/1 分数)
关于数据预处理对聚类分析的影响的错误说法是：

可能改变数据点之间的位置关系 可能改变簇的个数 有助于提升聚类质量 有助于提升聚类质量 - 正确 可能产生不确定影响
提交  显示答案 揭示答案
单选题  (1/1 分数)
在基于聚类的图像分割例子中：

色彩越复杂的图，需要的簇的个数越少 属于同一个物体的像素对应同一个簇 簇的个数越少，分割后图像越接近原始图像 簇的个数越多，分割后图像越接近原始图像
**** MESSY Tsinghua Data analysis exercise-Clustering, 6.2
     单选题  (1/1 分数)
如何衡量聚类的质量：

簇内数据点散布越小越好 簇中心点之间的距离越大越好 簇的个数越小越好 需要考虑数据点间的连通性 需要考虑数据点间的连通性 - 正确
提交  显示答案 揭示答案
单选题  (1/1 分数)
对于 Silhouette 图表述正确的是：

每个点的取值范围为[0, 1] 每个点的取值越接近于 0 越好 可以体现出簇的紧凑性 可以体现出簇的紧凑性 - 正确 对于离群点，取值可能超过 1
提交  显示答案 揭示答案
单选题  (1/1 分数)
关于 K-Means 算法的表述正确的是：

对数据分布没有特殊的要求 能较好处理噪点和离群点 对初始中心点较为敏感 对初始中心点较为敏感 - 正确 计算复杂度较高
提交  显示答案 揭示答案
单选题  (1/1 分数)
K-Means 算法中的初始中心点：

可随意设置 必须在每个簇的真实中心点的附近 必须足够分散 直接影响算法的收敛结果 直接影响算法的收敛结果 - 正确
提交  显示答案 揭示答案
单选题  (1/1 分数)
在 Sequential Leader 算法中：

需对数据集进行多次遍历 无法人为控制最终聚类的个数 需要事先生成初始中心点 聚类结果可能受数据访问顺序影响
**** MESSY Tsinghua Data analysis exercise-Clustering, 6.3
     单选题  (1/1 分数)
基于模型的聚类与基于分割的聚类相比：

有更高的精确度 有更低的计算复杂度 有更好的鲁棒性 对数据分布有更好的描述性 对数据分布有更好的描述性 - 正确
提交  显示答案 揭示答案
单选题  (1/1 分数)
在混合高斯模型中，每一个数据点：

只能被某一个高斯生成 可以被所有高斯等概率生成 可以被任一高斯生成但概率可能不等 可以被任一高斯生成但概率可能不等 - 正确 可以被任一高斯生成且概率由高斯的权重决定
提交  显示答案 揭示答案
单选题  (1/1 分数)
在混合高斯模型中，每个高斯的权重：

可以为负值 相加必须等于 0 相加必须等于 1 相加必须等于 1 - 正确 须由用户预先设定
提交  显示答案 揭示答案
单选题  (1/1 分数)
以 K-Means 算法为例，期望最大化算法中的：

模型参数指的是每个数据点的簇标号 隐含参数指的是每个数据点的簇标号 隐含参数指的是每个数据点的簇标号 - 正确 模型参数指的是簇的个数（即 K 值） 隐含参数指的是簇中心点坐标
提交  显示答案 揭示答案
单选题  (1/1 分数)
在掷硬币的例子中，期望最大化算法的隐含参数指的是：

每组实验中正面朝上的次数 每组实验中选择的硬币 每组实验中选择的硬币 - 正确 每枚硬币正面朝上的概率 每枚硬币被选中的次数
**** MESSY Tsinghua Data analysis exercise-Clustering, 6.4
     单选题  (1/1 分数)
与 K-Means 相比，基于密度的 DBSCAN 的优点不包括：

能妥善处理噪点和离群点 能处理不规则的数据分布 不需要预先设定簇的个数 较低的计算复杂度 较低的计算复杂度 - 正确
提交  显示答案 揭示答案
单选题  (1/1 分数)
在 DBSCAN 中，对数据点类型的划分中不包括：

中心点 中心点 - 正确 核心点 边缘点 噪点
提交  显示答案 揭示答案
单选题  (1/1 分数)
在 DBSCAN 中，对于噪点：

划分到最近的簇 所有噪点单独形成一个簇 直接无视 直接无视 - 正确 不做特别区分
提交  显示答案 揭示答案
单选题  (1/1 分数)
在层次型聚类中：

需要用户预先设定聚类的个数 需要用户预先设定聚类个数的范围 对于 N 个数据点，可生成 1 到 N 个簇 对于 N 个数据点，可生成 1 到 N 个簇 - 正确 对于 N 个数据点，可生成 1 到 N/2 个簇
提交  显示答案 揭示答案
单选题  (1/1 分数)
在层次型聚类中，两个点集之间的距离计算方法通常不包括：

由点集间距离最近的一对点的距离决定 由点集间距离最远的一对点的距离决定 由点集间随机的一对点的距离决定 由点集间随机的一对点的距离决定 - 正确 由点集间所有点的平均距离决定

* Sentdex:Python4ML
** Regression intro
:PIP:
1. sklearn
2. quandl
3. pandas
:END:

* 面试准备
** 知乎解答数据挖掘面试

如何准备机器学习工程师的面试 ？
我之前面试一些公司的机器学习或者数据挖掘工程师的职位。感觉自己准备的不够充分。想了解下一般会问哪些问题，考察哪些方面的东西。
*****  1
机器学习方面的面试主要分成三个部分：
1. 算法和理论基础
2. 工程实现能力与编码水平
3. 业务理解和思考深度

1. 理论方面，我推荐最经典的一本书《统计学习方法》，这书可能不是最全的，但是讲得最精髓，薄薄一本，适合面试前突击准备。

我认为一些要点是：
统计学习的核心步骤：模型、策略、算法，你应当对 logistic、SVM、决策树、KNN 及各种聚类方法有深刻的理解。能够随手写出这些算法的核心递归步的伪代码以及他们优化的函数表达式和对偶问题形式。

非统计学习我不太懂，做过复杂网络，但是这个比较深，面试可能很难考到。

数学知识方面，你应当深刻理解矩阵的各种变换，尤其是特征值相关的知识。

算法方面：你应当深刻理解常用的优化方法：梯度下降、牛顿法、各种随机搜索算法（基因、蚁群等等），深刻理解的意思是你要知道梯度下降是用平面来逼近局部，牛顿法是用曲面逼近局部等等。

2. 工程实现能力与编码水平
机器学习从工程实现一般来讲都是某种数据结构上的搜索问题。

你应当深刻理解在 1 中列出的各种算法对应应该采用的数据结构和对应的搜索方法。比如 KNN 对应的 KD 树、如何给图结构设计数据结构？如何将算法 map-red 化等等。
一般来说要么你会写 C，而且会用 MPI，要么你懂 Hadoop，工程上基本都是在这两个平台实现。实在不济你也学个 python 吧。

3. 非常令人失望地告诉你尽管机器学习主要会考察 1 和 2
但是实际工作中，算法的先进性对真正业务结果的影响，大概不到 30%。当然算法必须要足够快，离线算法最好能在 4 小时内完成，实时算法我没搞过，要求大概更高。

机器学习大多数场景是搜索、广告、垃圾过滤、安全、推荐系统等等。对业务有深刻的理解对你做出来的系统的结果影响超过 70%。这里你没做过实际的项目，是完全不可能有任何体会的，我做过一个推荐系统，没有什么算法上的高大上的改进，主要是业务逻辑的创新，直接就提高了很明显的一个 CTR（具体数目不太方便透露，总之很明显就是了）。如果你做过实际的项目，一定要主动说出来，主动让面试官知道，这才是最大最大的加分项目。

最后举个例子，阿里内部机器学习挑战赛，无数碾压答主 10000 倍的大神参赛。最后冠军没有用任何高大上的算法而是基于对数据和业务的深刻理解和极其细致的特征调优利用非常基本的一个算法夺冠。所以啥都不如真正的实操撸几个生产项目啊。
编辑于 2016-12-08
***** 1
SVM 的原理，SVM 里面的核
K-means，如何用 hadoop 实现 k-means
naive bayes 和 logistic regression 的区别
LDA 的原理和推导
做广告点击率预测，用哪些数据什么算法
推荐系统的算法中最近邻和矩阵分解各自适用场景
用户流失率预测怎么做（游戏公司的数据挖掘都喜欢问这个）
一个游戏的设计过程中该收集什么数据
如何从登陆日志中挖掘尽可能多的信息

这些问题我回答的情况，分几种。一种是在面试官的提示下，算是勉强完成了答案。一种是
在面试官的提示下，答了一点但是答得不够好。一种是面试官不提示也没有反馈，我回答了
但是我不知道回答得怎样。

我非常后悔的一点是我现在才想起来总结。有一个题是游戏玩家流失率预测，我被问过两次。
但是每次我都说是个分类问题。最近我突然想起来去网上查了下，有两个点，数据不平衡问
题和时间序列分析。我网上查到是一个大学教授和人人游戏合作的课题。我然后查了下这个
老师的 publication。没发现相关的论文。可能公司不让发表吧。

这些问题的特点是很基础很简单，因为实际中很少用复杂的算法，复杂的算法不好控制，而
且理论要求高。另一个特点是注重考查实际工程能力，我经常被问到自己实现了哪些算法。
还有的问题很契合实际。

我觉得如果现在再给我准备的机会。我会准备下面几点。首先是计算机基础知识和算法，这
些都是会正常考察的。有些公司考的少，有些公司正常考察。针对机器学习这部分，需要理
论扎实，还需要自己动手实现代码。另外 hadoop，mpi，最近比较火的 spark，应该都是加分
项。另一个是接触下实际的数据分析系统。我在学校里面看的论文，都是讲算法的多，讲应
用系统的少。这个可以靠之前的实习，也可以看些比较实用的论文。

PS 我是题主，自问自答下。
PS2 我面试的都是国内互联网公司和游戏公司。
***** 1
抛砖引玉，在读硕士，半个月前去面了某公司机器学习 intern 铩羽而归了。机器学习部分一个面试官问了我一个小时，我估计如果真正能上的人光机器学习部分应该还会多来几轮。

首先介绍自己的研究经历。会随机问一些细节。
我面的推荐，问了各类协同过滤的好与坏。

然后我说我做过 LDA，问我，Dirichlet Distribution 的定义和性质，并问我，为什么它和
multinomial distribution 是共轭的，顺便问了我啥叫共轭分布。

问了一个很有意思的问题，现实应用中的 Top-N 推荐问题和学术研究中的评分预测问题之间有什么不同。

问我 ItemCF 的工程实现，面对大数据如何实现，又追问了有没有什么工程优化算法。这个问
题我没答好，一开始我说了一个 MapReduce 模型，他问能不能更快一点，我就卡那了。。。
最后面试官告诉我，不能只从算法角度分析，要从系统设计分析，利用内存来减小
MapReduce 的吞吐量。（当然也许从 MapReduce 那一刻开始我就输了也不一定）


最后考了我一个基本概念，什么叫判别模型什么叫生成模型。

回忆以前有一个去百度做广告业务的师兄分享的面试经历，记得没问什么高深算法，马尔科夫系列？

现在工业界的机器学习业务也不会太多，公司不是学术界在学术研究灌水上有多少追求，算法可实现，能可扩展高效分布式运行才是重点。

所以个人认为，机器学习工程师的核心还是在于工程师的能力，实际应用的问题分析能力和
算法的实现能力很重要。机器学习的算法并不是重点。

***** 1
可以参考我的这篇文章《机器学习面试的那些事儿》，有时间再补充点其他的内容。

假设我们做过一个垃圾邮件分类器的项目。为了建立这个分类器，我们首先对数据进行清理及预处理，如缺失数据的处理、数据的归一化等。在获得初始特征向量后，用 PCA 进行了特征选择。利用特征选择得到的特征向量及对应数据，训练一个随机森林的分类器作为我们的垃圾邮件分类器。针对的这样一个项目，有这样几个点可以进行挖掘和准备。


1. 项目简介

如何向面试官介绍你做过的项目，这是一个非常基础、非常常见但是又充满技巧的问题。首
先，项目简介不应过于冗长，力争用最短的几句话勾勒出项目的框架。其次，数据科学相关
项目通常是业务与技术并存，因此，既要突出项目过程中解决的技术难题及应用的相关技术，
又应该兼顾项目带来的业务上的影响。


2. 模型简介

这类问题同样是机器学习面试中最普遍最常见的一类问题，面试的形式一般为介绍一个你最
喜欢的模型，或是介绍项目中应用的某种模型。与项目简介相同，模型简介也应力求简洁，
用最简短的几句话，讲清楚模型是用了什么样的原理完成了怎样的目标。wikipedia 中关于
随机森林的定义给我们提供了一个非常好的学习模板，可以用来借鉴：


Random forests is a notion of the general technique of random decision forests
that are an ensemble learning method(怎样的方法) for classification, regression
and other tasks(解决了什么问题), that operate by constructing a multitude of
decision trees at training time and outputting the class that is the mode of the
classes (classification) or mean prediction (regression) of the individual
trees(基本原理).


但是，wikipedia 中大部分模型的描述更偏书面化的表达，并不适合原封不动地照搬到面试中。我们需要将它转化为更口语化的表达。


3. 模型的优缺点

模型的优缺点与模型简介是紧密相关的，可以将两个问题结合起来一起准备。比如之前我们
谈到了什么是随机森林，紧接着可以谈一下随机森林有什么优点，如：a. 对于很多数据集
表现良好，精确度比较高；b. 不容易过拟合；c. 可以得到变量的重要性排序；d. 既能处
理离散型数据，也能处理连续型数据，且不需要进行归一化处理；e. 能够很好的处理缺失
数据；f. 容易并行化等等。同时，将理论与实践结合也是非常好的切入点，如随机森林的
诸多优点是如何体现在垃圾邮件分类器项目中，这样的结合能更好的展示出面试人对于模型
的理解及掌控。


4. 模型原理及相关技术细节

模型简介与模型优缺点的问题属于概念性问题，偏向于考察面试人是否了解某种模型，而更
进一步的则是对于模型原理及相关技术细节的考察，比如模型假设、目标函数、优化过程、
算法收敛性等。所谓知其然，又知其所以然，这是对于面试人的进一步要求。


例如，在模型的优缺点中，我们提到了随机森林可以对变量重要性进行排序。相应地，我们
应该能够解释随机森林是如何对变量重要性进行排序，有哪几种常见的排序指标，比如利用
OOB 误分率的改变或者分裂时信息增益的变化等。当然，问题并非到此终止，基于上面提到
的两种常见的变量重要性排序指标，又可以衍生出新的问题。例如，针对 OOB 误分率这个指
标，解释一下什么是 OOB，随机森林中 OOB 是如何计算的，它有什么样的优缺点；针对信息增
益，同样会有很多与之有关的问题，如什么是信息增益，如何计算信息增益，什么是熵，什
么是 GINI 指数，他们之间的区别是什么，他们之间的区别会对建树产生怎样的影响等。


再如，在垃圾邮件分类器项目中，有一部分数据存在缺失，而随机森林具有处理缺失数据的
优点，建模的过程中我们充分利用了这一特性。那么，与之相关的问题可能会是，随机森林
为什么会有这个优点？随机森林是怎样对缺失数据进行训练及预测？


5. 模型的横向比较

模型原理及相关技术细节的考察属于对机器学习知识深度考察的范畴，与之对应的是机器学
习知识广度方面的考察。广度上的考察主要有两大部分，一方面是从理论上对不同算法进行
横向比较，如模型假设，优化方法等。另一方面，是结合实际案例对不同算法进行横向比较，
这要求面试人不仅仅要熟知不同模型的原理及技术细节，更需要将抽象的理论与具体的实践
结合，在实际案例中对算法进行比较。


在垃圾邮件分类器项目中，随机森林被用作最终的分类器模型。面试官可能会就此提出以下
问题：为什么选择随机森林而非其他模型，比如朴素贝叶斯或者支持向量机。一般来说，面
试者可以从数学理论和工程实现两个方面进行比较回答。从理论上讲，数据表现出来的特征，
以及模型所基于的假设都是很好的突破口;从工程实现上讲，实现的难易程度，是否易于
scale 都是可以考虑的点。


6. 开放性问题

除了对机器学习知识深度和广度上的考察，开放性问题也是面试中经常会遇到的问题，对于
初学者来说这也是最难准备的一类问题。一方面这类问题很难在教科书中见到，没有固定的
问题清单；另一方面，这类问题没有标准答案，很多时候是对过往经验的总结。针对这一类
问题，更多的是靠平时工作学习过程中多思考、多总结、多积累，临阵抱佛脚很难起到效果。


再次回到垃圾邮件分类器项目，这个项目中有多个开放性问题可以被提问。比如，1. 邮件
数据存在缺失，通常情况下，如何对缺失数据进行处理？2. 垃圾邮件分类是一个非平衡数
据集分类的问题，针对这一类问题，我们应该如何进行建模。3. 项目中，PCA 被用于特征选
择，除此而外，还有哪些方法可以用来进行特征选择？


7. 准备材料

在准备机器学习的过程中，我主要用了如下的材料：

A. Stanford CS229 Machine Learning.

B. CMU 10-701 Introduction to Machine Learning.

C. The Elements of Statistical Learning. By Trevor Hastie, Robert Tibshirani and Jerome Friedman.

D. Pattern Recognition and Machine Learning. By Christopher Bishop.


A.和 B.是 Stanford 和 CMU 机器学习课程的课件，里面涵盖了各种常用算法，应该力求掌握这
些算法。C.和 D.是经典中的经典，难度适中，内容没有太理论，语言也没有太晦涩，是机器
学习内功修炼的不二法门。


关于材料再说句题外话，我之前是个资料收集整理爱好者，总是在努力充实自己的资料库，
总是担心遗漏任何有用的材料。但是后来才逐渐意识到，资料求精不求多，存在脑子里面的
叫知识，存在硬盘里叫文档。
***** 1
数据结构算法水题+常用机器学习算法推导+模型调优细节+业务认识
*****  1
算法有 svm  em 算法  都要推导证明
因为我做过文本主题  所以问了很多 lda 的知识
其它的就比较扯了
***** 1
常用模型和算法，至少有那么一两个能推导，能说出适用范围，能自己实现，有过应用。

另外，要有算法工程师的气质，那种对任何事物都愿意且能够深入思考的倾向。

据说，如果是应聘大公司初级工程师的话，刷题貌似有那么一丢丢用处，仅仅是一丢丢。

***** 1
先总结几点，再谈个人经历。
1. 基本的 Model 要懂
Kmeans 必须懂 KNN 懂原理不用写 SVM、MR 和 Pagerank 多看看，遇到问题多用这些方法讨论
（不关乎信仰，面试官都懂）

2. 高层次的 Model 是关乎信仰的，不需要浪费时间在上面
比如 LDA。以前信贝爷，觉得高大上。做过才知道坑有多深，出 paper 搞点黑数据可以，真正
业界要用效果甚不稳定。HMM 可以做语句分析优化，别的地方用也不显著。绝大多数时候搞
个 word net，做个 tf idf 就足够了，不行自己再加些 hardcode，效果也比所谓的 model 好，
性能也高。另一说就是面试官不期望你懂这么高级的模型，就跟他们不能因为你不会拉小提
琴而觉得你智商不够把你拒掉一样。

3. 人品、自信、反客为主的面试思路
以我的个人经历（Observation）（详见文末），不懂但人品好就拿到了 Offer，懂但人品不
好就拿不到 Offer。（请随意 Predict）个人比较成功的面筋是看好面试官的 cd 间隔放大招：
比如看简历沉没的时候主动说 high light 一下，有条件就把线上的 project 拿出来秀；代码
写完主动说说能有什么改进思路，把面试官拐跑，就不会被他带到挖好的坑上来了。

4. 数据敏感性
比如预估数据规模和运行时间。

经历过以下几种 case，不知是否 match。
1. 10 年，北京，刚毕业。申请国外 phd 跪了。魂友指明路去 T 大某 ML 实验室历练。提前两周
   看了下，感觉最懂的也只有贝叶斯公式了（其余只知道个缩写看着眼熟）约了时间也只
   能硬着头皮去了。
结果老板就看了看简历，只问我啥时候可以过去。=_=

2. 一年半后，在美读硕。经济压力山大，暑假前就开始找实习（真心困难，因为当时招 ML
   或者 Data Scientist 的都只招 Fulltime 或者经老板介绍的 PhD）简历投了也没人鸟，感觉
   还是懂 iOS Android 的吃香。好不容易遇到个 start-up，面试时候我主动展示之前做的项
   目，挺满意，让我写个 Page Rank，30 分钟拍好 Over。（允许看 wiki 看公式）老板不懂/
   不信 LDA，反正 SVM 各种搞。

3. 有同学拿到 EBay 电面，抓我去帮忙递纸条，问的概率论基础，线性回归，码字符串处理，
   都是基本功。

4. 后来面了次 Yelp，电面第二轮，代码拍太快了，导致他有时间问了第二个 Follow up
   question，投票统计相关，我提了两种 normalize 方案，都不太完善，后来就不要我了。

5. FB 一直没理我，估计是之前在 Graph 上面抓数据超了两次 limit 被封过 ID（他们自己文档
   不写清楚）Google 问的都是基本码农问题，跟 ML 关系不大。因为面的 Test，码完让我自
   己出数据，我出多了，被鄙视，锯。

6. 去面 Bing。Super Day 面了 6 个人，前面问算法，后面吃着混沌面问的 Query 分析。最后没
   给 Offer，因为收了 N 记 2 万 5 员工用完招人名额。（据说还给 EVP 打了报告，没批。算了）

最后忠告：
攒人品。
信自己的数学和逻辑直觉，不要信 Model。
信不信贝爷和得不得永生是相对独立事件。
所以“信贝爷得永生”在贝爷的公理范围内至少是悖论。
关于考察方面，上面已经讲得很详细了，直接给你贴几个面试数据挖掘实习生经验贴，都是 15 年崭新的血与泪啊。（网站是 100 块钱的国外虚拟空间，没有进行什么优化处理，所以网页打开会非常慢，请见谅。）
***** 1
百度数据挖掘实习工程师一、二现场面试（深圳）
阿里巴巴电话面试 2 面总结（数据挖掘，天猫事业部）
百度 NLP 电话面试总结

如何准备面试呢？个人经验：

1. 代码算法：基本算法（如快排等，需要熟练掌握） + 剑指 Offer（面试经常出相似的题） + LeetCode（剑指 Offer 的补充，增强动手能力）
2. 机器学习：李航《统计学习方法》（读 3 遍都不为过啊！） + Coursera
   Stanford《Machine Learning》（讲得很基础，但是没有告诉你所以然） + Coursera
   台湾大学《机器学习高级技法》（里面详解了 SVM，Ensemble 等模型的推导，优劣）
3. 请详细地回忆自己做过的项目，项目用了什么算法，为什么用它，有什么优缺点等。如
   果没项目经验可以参加天猫大数据比赛和 Kaggle 比赛。
4. 教你如何迅速秒杀掉：99%的海量数据处理面试题。（基本每次都有一道海量数据处理的面试题）

1 决策树的模型很重要，不会问你 ID3 这些简单的，甚至 CART 都不会，不过会问 GBDT，随机森林。
2 SVM 不可能不问。
3 理解得很深才能给面试官讲明白。

会逻辑回归就够了，其他的大致看看，编程扎实一点，特征怎么抽怎么处理的详细了解一下，
就够了，没那么多扯犊子东西。主要靠练，准备的话看看 C 加加，熟悉一下自己的项目。
***** 1
一、一些常见的机器学习算法
1. 如果有背景，item 和 cf 协同过滤的优缺点，如何从计算公式证明，各种情况的惩罚，
   hadoop 上 mr 的实现，包括各种情况的惩罚。
2. 线性回归的梯度下降和牛顿法求解公式的推导
3. 贝叶斯分类器的优化和特殊情况的处理
决策树的的训练……

二、单机的算法如数据结构
1.最简单的 top n
2 偶尔会有一些简单的 poj
3.数据结构

三、系统设计，包括算法和工程系统
1. 如一个热门微博排行榜等

***** 1
最近在 Quora 上看到了一个相关回到，于是搬到这里来。
链接在此 quora.com 的页面
搞机器学习的阅读英文肯定毫无压力了，就不翻译了

-----以下是原回答------
First, here is my list of all skills I might want to see for this position:

Academic
CS coursework
Stats and linear algebra
Some ML coursework, covering at least
regression
classification
clustering
recommendation
graphical models

Data Collection Tools
Hadoop-based tools like Flume / Sqoop
Text munging languages like Python, or maybe Perl
Basic SQL

Data Modeling Tools
A library like scipy / numpy or Weka
A tool like R (or commercial equivalents like SAS, SPSS)

Model Serving Tools
(Ideally) some familiarity with PMML
Basic knowledge of a NoSQL store
Systems language skill, like Java

Business Smarts
Communication skills
Some facility with a visualization tool, even if gnuplot or Excel
Domain knowledge relevant to my business

You certainly don't need all of that. In fact, for an internship, you can't be
expected to have most of it. I assume you are in school, so I would expect you
to have much of the academic background, and would like to see that you have
some of the tool skills. I would not expect business skills, but believe me,
communication skills are a big differentiator.


So what to focus on? First, academics. If I were interviewing you I would
probably ask about this as a filter. If you're not able to explain the very
basics, like what linear regression does, that means there's a big lack of
either knowledge or communication skills. So I would feel comfortable with the
very basics. I'd ask you to explain one moderately advanced algorithm and why it
works, of your choice. Same reasoning, if you can't pick something out of
everything you know to explain reasonably, probably not going to proceed.

Unfortunately I do think a lot of interviews focus too much on the math and
algorithms like it was an exam. I would not want to work at places that think
that's the important thing. I personally would want to see that you're smart and
communicate well and know the basics. Chances are that whatever math is relevant
to my business is something you'll need to learn (more) anyway.


I know you're asking about tools though. The tools that are relevant really
depend on the kind of place you're applying. A classic research department is
going to focus mostly on modeling tools. Since you can't get SAS / SPSS easily,
focus on R and Weka as a skill.

At the other end of the spectrum, say, a small startup, the requirement is
broader and shallower. They won't need you to know R. They will need you to
quickly understand a business problem and put together a production-ready system
to solve it. So it's much more about data collection, munging, a little
modeling, and then integration. For that I would make sure you know how to get
data out of a DB or log files, into a modeling tool, and then how to transform a
model into some code someone could put in a web server. So: basic SQL, Python or
Java, and whatever DB / web serving tools the company uses.


Kaggle is great practice although it will not 'test' your data collection skills
or the serving side of things. But it will challenge you to understand a
business problem, munge real data and model it. I would look favorably on an
intern who had taken the time to solve a Kaggle problem and done reasonably
well.
***** 1
1. 实现一个分布式的矩阵向量乘的算法。。。
好吧 这个我学过 blabla 讲了一堆 也不知道对不对
2. 最速下降法和共轭梯度法 wolfe 条件 最速下降法和共轭梯度法的收敛速度如何判断。。。
两种方法的概念答上来了 wolfe 条件没准备到 收敛速度大概回答了一下 我印象中只记得共
轭梯度的误差估计了
3. 约束优化的 KKT 条件 KKT 条件在边界区域的搜索行为的物理意义是什么。。。
KKT 条件 ok 物理意义没答上来
4. 实现一个分布式的 topN 算法。。。
topN 看过 不过分布式嘛。。。 就是追着你问 问到你不会为止
5. 为什么可以使用 logistic 回归。。。
这个我不懂。。。 好吧 hr 让我去看看《离散选择方法》这本书。。。 算是学到了
6. 你了解的机器学习算法有哪些。。。
这个简单。。。
7  选一个你熟悉的算法 详细推导公式过程。。。
推公式我在行 不过 hr 貌似不感冒
8  一个实际应用的问题 因为没有背景 所以只好放弃
然后就没有然后了
** Coder
** some expearence
*** logistic regression -1
當我們想要「預測」一件事情，最常用的統計工具就是「迴歸」（regression），要被預測
或被瞭解的變項叫做依變項（Dependent variable），它可以是名目變項（nominal）、順
序變項（Ordinal）、等距變項（interval）以及比率變項（ratio）。如果依變項是屬於後
兩者，我們稱作連續變項（Continuous），那麼我們習慣用線性迴歸（Linear regression）
去配適資料。


然而在實際的情況下，所收集回來的資料不見得會是連續變項，而常常是名目變項與順序變
項（我們稱為間斷變項, discrete variable），例如醫學統計最常遇到的就是「死亡與否」、
「有無生病」、「有無發生」，此時依變項只有兩種情況，那麼傳統的線性迴歸再也不適用
於配適這樣的類別性資料，原因有很多，例如殘差常態性不可能成立、依變項的預測值可能
會超過 1 等等。此時若對依變項作一個轉換，稱作 logit 轉換則可以解決以上諸多問題（關於
詳細的轉換過程要參見教科書）。


傳統線性迴歸的迴歸係數（regression coefficient）的解釋為「當自變項增加一個單位，
依變項則會增加多少單位」，但是在 Logistic regression 的迴歸係數解釋為「當自變項增
加一個單位，依變項 1 相對依變項 0 的機率會增加幾倍」，也就是說「自變項增加一個單位，
依變項有發生狀況（習慣稱為 Event）相對於沒有發生狀況（non-event）的比值」，這個比
值就是勝算比（Odds ratio, OR）。我們可以這樣說，除了迴歸係數的解釋方法不太相同之
外，基本上可說傳統線性迴歸跟 Logistic regression 是一樣的分析。


以上我們提到的是當依變項是二元的（Binary）時的 Logistic regression，不過有的時候
依變項的類別會超過 3 類，例如人格心裡學就常常把人格分成「五大人格」，而且這五個人
格之間是互斥的（沒有順序關係），此時想要「預測」這個人的人格會是哪一種類型的迴歸
方法就是多項邏輯模型（Multinomial logistic regression），它是 Logistic regression
的擴充，解釋方法都一樣。唯一不同之處在於要將依變項其中一個類別設為「參照組」
（Baseline category / Reference group），假設依變項有三類，那麼迴歸係數解讀為
「當自變項增加一個單位，依變項 A 相對依變項 C 的機率會增加幾倍」，此時依變項 C 為我們
選定的參照組（分母，或說被比較的那一組），參照組可隨意設定，因為結果會完全一樣。
(我想上統計課程)


最後要提到的當依變項是順序尺度，例如「傷病等級」分成 3 類，但是並非為等距變項，此
時要預測的統計工具可選用比例勝算模型（Odds proportional model）或累積機率模型
（Cumulative probability model）。此時迴歸係數的解讀為「當自變項增加一個單位，依
變項 A 相對依變項 B 與 C 的機率以及依變項 A 與 B 相對依變項 C 的機率會增加幾倍」，所以是一種
累積機率的概念，實務上也很常用。


最後推薦國內 劉應興 教授翻譯的「類別資料分析導論」，原作者為 Alan Agresti，是一本
很棒的 Logistic regression 導論，如果覺得這本書太簡單，可考慮研讀 David Kleinbaum 的
Logistic regression: A self-learning text，是一本應用性與原理性都兼顧到的好書。
*** logsitic regression -2
解讀 logistic regression 在 什麼是線性迴歸？(What is Multiple Linear Regression?)
談論過迴歸分析主要可用來作預測與作因果分析，那既然迴歸分析這麼好，為什麼還要談
logistic regression (中文有人翻：羅吉斯迴歸) 呢？

最主要的原因：在一般的迴歸分析中，dependent variable (DV) 是連續變項 (continuous
variable)；如果 DV 不是連續變項，而是二分變項 (dichotomous variable，如：男或女、
存活或死亡、通過考試與否) 等情況，這時你就必須使用 logistic regression 了。

當然，如果你堅持的話，你也可以跑 OLS regression，一樣會得到結果的。如果你得到的
coefficient 是 0.066 的話，解讀就是：當 IV 增加 1 的時候，DV 發生的機率增加 6.6%
。然而，這樣作是有缺點的，通常沒辦法準確地估算 IV 對 DV 的影響 (通常是低估)。

為了解決這個問題，統計學家用 odds ratio (勝算比) 於 logistic regression 之中。要
說勝算比之前，要先了解什解什麼是勝算。勝算指的是：一件事情發生的機率與一件事情沒
發生機率的比值。以拋硬幣為例，拿到正面與拿到反面的機率都是 0.5，所以 odds ratio
就是 0.5 / 0.5 = 1。如果一件事情的發生的機率是 0.1，那勝算是 0.1 / 0.9 = 1/9。
如果一件事情發生的機率是 0.9，那勝算是 0.9 / 0.1 = 9。所以勝算是介於 0 與無限大
之間。

odds ratio 則是兩件事情的 odds 作比較。舉個例子來說，如果高學歷的人寫部落格的勝
算(odds) 是 2.33，低學歷的人寫部落格的勝算是 0.67，那與低學歷的人比起來，高學歷
的人寫作部落格的勝算是他們的 3.48 倍 (2.33/0.67)，所以勝算比 (odds ratio)就是
3.48。

那如何解讀 logistic regression 的結果呢？通常你會看到文章裡呈現兩種結果：一種如
果沒特別指名的話，就叫 coefficient，它的 DV 是某件事的 log odds ratio，是勝算比
取了自然對數；一種是 odds ratio。這兩種值是可以互相轉換的，如果你的 log odds
ratio 得到的 coefficient 是 0.405，你可以計算 odds ratio，在 stata 指令列輸入
dis exp(0.405)，會得到 1.500。所以在讀文章的時候一定要讀清楚作者呈現的是 log odds
ratio 或是 odds ratio。

結果怎麼解讀呢？可從 log odds ratio 開始，解讀是：當 IV 增加一單位，log odds 會
增加 ##。其實這解讀與 OLS regression 的解讀是一樣。如果你看到的是 odds ratio，解
讀是：當 IV 增加一單位，odds 會增加 (##-1)*100%。兩種解讀方式都套上剛剛的數字，
那結果會是：

log odds ratio: 當 IV 增加 1，log odds ratio of 某件事會增加 0.405 (請原諒我的英
式中文@@)。

odds ratio: 當 IV 增加 1，odds of 某件事會增加 (1.5-1)*100% = 50%。所以如果本來是
2，增加 50%的話，會變成 2 * 50% + 2 = 3。換句話說，你也可以直接解讀為：當 IV 增
加 1，odds 某件事 (或是某件事的勝算。注意：這裡是勝算，不是勝算比) 會變成原本的值
乘以 1.5。

如果你的勝算比 odds ratio 的 coefficient 是 0.667，那應該怎麼解讀呢？當 IV 增加 1，
某件事的勝算會變成原本的值 (or 勝算) 乘以 0.667。所以原本的勝算比如果是 3 的話，
當 IV 增加 1 時，某件事的勝算會變成 2。你也可以說：當 IV 增加 1 時，某件事的勝算會
減少 (1-.667)* 100% =33%

* 数据挖掘面经
作者：ZakeXu
链接：https://www.nowcoder.com/discuss/15168
来源：牛客网

《数据挖掘
  ——
  从入门到求职》


   by ZakeXu


  最近秋招也已经慢慢接近尾声了，从去年
  8
  月底开始，先后参加了
  datacastle
  ，阿里天池，牛客网各自举办的数据挖掘比赛（都是
  top10
  ），今年
  4
  月份又先后去百度，腾讯实习，到现在秋招快结束，也将近一年的时间，最终拿到手的比较有分量的
  offer
  主要是腾讯，百度，华为三家企业的
  offer
  ，都是
  sp
  ，下面就将过去一年的一些经验做一下小总结，不一定是最合适的方法，但是当毫无头绪的时候，可以参考参考。






    （一）



    简介



  1.

  首先介绍企业对该岗位的一些能力需求，直接贴
  bat
  在该方向的相应岗位
  jd
  ：


  （
  1
  ）百度：机器学习
  /
  数据挖掘工程师





  （
  2
  ）阿里：算法工程师





  （
  3
  ）腾讯：基础研究





  2.

  个人感觉数据挖掘是一个比较大的概念，可以理解为：


  数据挖掘
   =
  业务知识
   +
  自然语言处理技术（
  NLP
  ）
  +
  计算机视觉技术（
  CV
  ）
  +
  机器学习
  /
  深度学习（
  ML/DL
  ）


  （
  1
  ）其中业务知识具体指的是个性化推荐，计算广告，搜索，互联网金融等；
  NLP
  ，
  CV
  分别是处理文本，图像视频数据的领域技术，可以理解为是将非结构化数据提取转换成结构化数据；最后的
  ml/dl
  技术则是属于模型学习理论；


  （
  2
  ）在选择岗位时，各个公司都没有一套标准的称呼，但是所做的事情无非
  2
  个大方向，一种是主要钻研某个领域的技术，比如自然语言处理工程师，计算机视觉工程师，机器学习工程师等；一种是将各种领域技术应用到业务场景中去解决业务需求，比如数据挖掘工程师，推荐系统工程师等；具体的称呼不重要，重要的是平时的工作内容；


  PS
  ：在互联网行业，数据挖掘相关技术应用比较成功的主要是推荐以及计算广告领域，而其中涉及到的数据主要也是文本，所以
  NLP
  技术相对来讲比较重要，至于
  CV
  技术主要还是在人工智能领域（无人车，人脸识别等）应用较多，本人了解有限，相关的描述会较少；


  3.

  根据之前的分析，也可以看到该岗位所需要的
  3
  种基本能力分别是业务经验，算法能力与工程能力；






    （二）



    入门




    1.



    工程能力



  （
  1
  ）编程基础：需要掌握一大一小两门语言，大的指
  C++
  或者
  JAVA
  ，小的指
  python
  或者
  shell
  脚本；需要掌握基本的数据库语言；


  建议：
  MySQL + python + C++
  ；语言只是一种工具，看看语法就好；


  推荐书籍：《
  C++ primer plus
  》


  （
  2
  ）开发平台：
  Linux
  ；


  建议：掌握常见的命令，掌握
  Linux
  下的源码编译原理；


  推荐书籍：《
  Linux
  私房菜》


  （
  3
  ）数据结构与算法分析基础：掌握常见的数据结构以及操作（线性表，队，列，字符串，树，图等），掌握常见的计算机算法（排序算法，查找算法，动态规划，递归等）；


  建议：多敲代码，多上
  OJ
  平台刷题；


  推荐书籍：《大话数据结构》《剑指
  offer
  》


  （
  4
  ）海量数据处理平台：
  hadoop
  （
  mr
  计算模型，
  java
  开发）或者
  spark
  （
  rdd
  计算模型，
  scala
  开发），重点推荐后者；


  建议：主要是会使用，有精力的话可以看看源码了解集群调度机制之类的；


  推荐书籍：《大数据
  spark
  企业级实战》



    2.



    算法能力



  （
  1
  ）数学基础：概率论，数理统计，线性代数，随机过程，最优化理论


  建议：这些是必须要了解的，即使没法做到基础扎实，起码也要掌握每门学科的理论体系，涉及到相应知识点时通过查阅资料可以做到无障碍理解；


  （
  2
  ）机器学习
  /
  深度学习：掌握
  常见的机器学习模型（线性回归，逻辑回归，
  SVM
  ，感知机；决策树，随机森林，
  GBDT
  ，
  XGBoost
  ；贝叶斯，
   KNN
  ，
  K-means
  ，
  EM
  等）；掌握常见的机器学习理论（过拟合问题，交叉验证问题，模型选择问题，模型融合问题等）；掌握常见的深度学习模型（
  CNN
  ，
  RNN
  等）；


  建议：这里的掌握指的是能够熟悉推导公式并能知道模型的适用场景；


  推荐书籍：《统计学习方法》《机器学习》《机器学习实战》《

    UFLDL

  》


  （
  3
  ）自然语言处理：掌握常见的方法（
  tf-idf
  ，
  word2vec
  ，
  LDA
  ）；



    3.



    业务经验



  （
  1
  ）了解推荐以及计算广告相关知识；


  推荐书籍：《推荐系统实践》《计算广告》


  （
  2
  ）通过参加数据挖掘竞赛熟悉相关业务场景，常见的比赛有
  Kaggle
  ，阿里天池，
  datacastle
  等；


  PS:
  以上都是一些入门级别的介绍，在长期的学习中，应该多看顶会
  paper
  ，多读开源代码，多学习优秀解决方案；


  PS:
  以上推荐的书籍对应的电子版可以联系本人（
  Q:1434909067
  ）


  PS：
   链接：http://pan.baidu.com/s/1i4GQ7cT 密码：61io






    （三）



    求职



  1.

  简历


  （
  1
  ）格式：个人信息（姓名，联系方式，教育背景，求职意向，照片可有可无）
  +
  竞赛经历
  +
  实习经历
   +
  项目经历
   +
  掌握技能
   +
  获奖情况；


  PS:
  最好写成一页；


  （
  2
  ）加分：博客，
  github
  ，竞赛
  top10
  ，顶会
  paper
  ；


  PS:
  如果感兴趣的话可以联系我要简历模板（
  Q:1434909067
  ）


  PS:
  牛逼的简历可以让你有更多的面试机会，更关键的是让面试官在面试时潜意识给你打高分，当然前提是简历要真实，所以平时得为了牛逼的简历多做准备工作；


  2.

  海投


  （
  1
  ）国内设有该岗位且还不错的公司：


  百度，腾讯，阿里，网易（互联网，游戏，有道），华为，今日头条，滴滴研究院，一点咨讯，
  360
  ，美团等；


  （
  2
  ）如果选择留在广东深圳发展，就业的机会比较少，比较好的主要就是百度深研，腾讯总部，华为深圳，京东好像在深圳也有个做数据挖掘的团队；（楼主倾向去深圳发展）


  （
  3
  ）个人建议在
  3
  月份的时候可以通过实习生的身份进入相关企业，争取实习生留用；一般企业给应届生的
  hc
  分配比例大概是实习生留用：校招提前批：校招正式
  =4
  ：
  3
  ：
  3
  ，实习生留用相对比较容易；


  （
  4
  ）一般投递简历时，尽量联系公司内部的师兄师姐或者熟人，帮忙将简历直接给到团队
  leader
  手中，这样做的好处是可以同时面试同个公司的多个团队，前提是简历在公司校招系统未被锁定的前提下，具体情况多咨询公司内部熟人，在求职过程中，信息来源非常重要，一定要注意这点，不然会踩很多坑；


  （
  5
  ）加入各种求职交流群，多认识些人，共享资源；


  （
  6
  ）投简历时候尽量内推，很多公司内推可以免笔试；


  PS
  ：笔试纯属看
  rp
  ，总之就是多刷题，上牛客网多练练并针对性复习就好；


  3.

  面试


  （
  1
  ）一般该岗位的面试起码都有
  3
  轮，
  2
  轮技术面，
  1
  面
  hr
  面，
  hr
  面主要看情商，这里不多说；
  2
  轮技术面的区别就是越到后面面试官的级别越高，所以面试的风格也可能越偏向于技术视野等一些吹水的话题上；


  （
  2
  ）一般技术面有以下一些环节：自我介绍，项目介绍，算法提问（推公式），数据结构提问（写代码）；


  1
  ）自我介绍：一般尽量简短，主要讲清楚自己的研究方向，所取得成就以及优势所在即可；


  2
  ）项目介绍：简历上的项目一定要熟悉，介绍时候分三部曲：项目背景，项目方案，项目成果；对项目中涉及到的一些技术点一定要很熟悉；


  3
  ）算法提问：一般是问常见机器学习模型原理或者一些机器学习常见问题的解决方案（比如正负样本不平衡之类的），所以常见的机器学习模型一定要很清楚原理，必须会推公式，能知道工程实现的一些
  trick
  的话，那你就离
  sp
  不远了；


  4
  ）数据结构提问：常见的数据结构一定要掌握，基础的代码一定要会手写（快排，冒泡，堆排，归并排序，二分查找，二叉树的遍历，二叉树增删查改）；剑指
  offer
  的题目要会；有精力的话可以刷下
  leetcode
  ；


  （
  3
  ）面试的时候多准备一些素材，在面试过程中主动引导面试官提问，比如面试官让你讲解
  gbdt
  原理时，这会你可以跟他说一般说起
  gbdt
  ，我们都会跟
  rf
  以及
  xgboost
  一块讲，然后你就可以主动地向面试官输出你的知识；面试并不是死板地你问我答，而是一种沟通交流，所以尽可能地把面试转化成聊天式的对话，多输出自己一些有价值的观点而不是仅仅为了回答面试官的问题；


  （
  4
  ）在面试过程中，除了基础的东西要掌握，可以适当地向面试官展示你的一些其他的亮点，比如跟面试官谈论某些最近
  paper
  的进展以及一些技术方面的想法等，突出自己的与众不同；


  （
  5
  ）不同公司的面试风格都略有不同：


  1
  ）百度：技术派，现场面，最大的风格就是写代码，
  2
  面技术加一面经理面，技术面必写代码；


  2
  ）阿里：内推可以电话面，主要是聊项目跟问一些基础的数据结构方面的知识，看看剑指
  offer
  一般可以应付；


  3
  ）腾讯：内推可以电话面，主要聊项目跟推公式；


  4
  ）华为：主要聊项目，智力题以及聊价值观之类的东西；


  5
  ）滴滴研究院：百度系，面试风格跟百度差不多；


  （
  6
  ）常见面试题（由于有的面试时间较久，主要靠记忆写下来）


  1
  ）几种模型（
  svm
  ，
  lr
  ，
  gbdt
  ，
  em
  ）的原理以及公式推导；


  2
  ）
  rf
  ，
  gbdt
  的区别；
  gbdt
  ，
  xgboost
  的区别（烂大街的问题最好从底层原理去分析回答）；


  3
  ）决策树处理连续值的方法；


  4
  ）特征选择的方法；


  5
  ）过拟合的解决方法；


  6
  ）
  kmeans
  的原理，优缺点以及改进；


  7
  ）常见分类模型（
  svm
  ，决策树，贝叶斯等）的优缺点，适用场景以及如何选型；


  8
  ）
  svm
  为啥要引入拉格朗日的优化方法；


  9
  ）假设面试官什么都不懂，详细解释
  CNN
  的原理；


  10
  ）海量的
  item
  算文本相似度的优化方法；


  11
  ）梯度下降的优缺点；


  12
  ）
  em
  与
  kmeans
  的关系；


  13
  ）
  L1
  与
  L2
  的区别以及如何解决
  L1
  求导困难；


  14
  ）如何用尽可能少的样本训练模型同时又保证模型的性能；


  15
  ）解释
  word2vec
  的原理以及哈夫曼树的改进；


  16
  ）对推荐算法的未来看法；


  17
  ）在模型的训练迭代中，怎么评估效果；


  18
  ）有几个
  G
  的文本，每行记录了访问
  ip
  的
  log
  ，如何快速统计
  ip
  出现次数最高的
  10
  个
  ip
  ；如果只用
  linux
  指令又该怎么解决；


  19
  ）一个绳子烧完需要
  1
  个小时，假设所有绳子的材质都不一样，也不均匀，怎么取出
  1
  小时加
  15
  分钟；


  20
  ）假设有个
  M*N
  的方格，从最左下方开始往最右上方走，每次只能往右或者往上，问有多少种走法，假设中间有若干个格子不能走，又有多少种走法；


  21
  ）实现
  hmm
  的状态转移代码；


  22
  ）最短路径代码；


  23
  ）拼车软件是如何定价的以及如何优化；


  24
  ）
  100
  张牌，每次只能抽一张，抽过的牌会丢掉，怎么选出最大的牌；


  25
  ）怎么预测降雨量；


  26
  ）
  kmeans
  代码；


  27
  ）
  mr
  方案解决矩阵相乘的代码；


  28
  ）
  sql
  语句的一些优化技巧；


  29
  ）关于集群调度的一些经验
  trick
  掌握多少；


  30
  ）设计一个系统可以实时统计任意
  ip
  在过去一个小时的访问量；


  31
  ）设计
  LRU
  系统；


  PS:
  以上的面试题仅供参考，主要是提供一个方向，大概了解这个岗位的面试考核方向，具体还得多刷刷面经（牛客网）；
* Data Structure

** lec 21: HashTable
*** what is a hash table?
1. a hash table is a data structure
2. offers fast *insertion and searching*
3. they are limited in size because they are *based on arrays*
   1. can be resized, but it should be avoided
4. they are hard to order

why hash table important?
i want the INFO with ID ---> compression(hashCode(ID)) ---> *directly* find id in hashtable and get INFO

*** Dictionaries
    two-letter words and definitions

 - words is a key that addresses the definition
 26 * 26 = 676 words.
 Insert a definition into dectionary:
 - function hashCode(): maps each word, eg (key) to integer 0...675
 - index into array, we call it buckhead, where we're going to store the definition for that word

 #+BEGIN_SRC java
public class Word{
    public static final int
        LETTERS = 26,
        WORDS = LETTERS * LETTERS;
    private String word;

    public int hashCode(){
        return LETTERS * (word.charAt(0) - 'a') +
            (word.charAt(1) - 'a');
        // java treat a chararter as a number
        // char - 'a'  = 0...25
        // this is how you map a 2 letter word to a unique num
    }
}

public class WordDictionary{
    private Definition[] defTable = new Definition[Word.WORDS];
    public void insert(Word w, Definition d){
        defTable[w.hashCode()] = d;
    }

    Definition find(Word w){
        return defTable[w.hashCode()];
    }
}
 #+END_SRC

 #+BEGIN_SRC ditta


 #+END_SRC
 -----------
 Problems with long letter word
 2 letter word ==> 26^2 items array
 3 letter word ==> 26^3
 n letter word ==> 26^n

 this number is too large to store in computer.

 now hashtable comes

*** HashTable: lec-note
 | notation | meaning                                               |
 |----------+-------------------------------------------------------|
 | n        | numbers of keys(words) actually you want to store     |
 | N        | table of N buckets, N a bit longer than n, 20% longer |

 A hash table maps huge set of possible keys into N buckest by applying a compression
 function to each hash code

 n - i can still map every possible english word to a number from 0 ~ 26^45
 N - but then i will compress it down, so that i'm not using more than a million buckets

 h(hashCode) = hashCode mod N
 - h is the name of compression function
 - hashCode ofen negative
 - because 'mod N' is a random *compression*, you will have collisions

 Collision:
 several keys hash to same bucket
 if h(hashCode1) = h(hashCode2)

 How to solve Collision --- Chaining:
 chaining, each bucket is no longer store just one word,
 instead, store a references a linked list of entries, that link
 is called a chain.

 then, when i seach a definition of a word, how to locate it in this chain?
 Not just install the definitions, i have to store the original words as well.
 Store eahc key in table with definition, as a pair in that table.

 entry = (key, value)

 #+NAME: defTable
 #+BEGIN_SRC ditaa
defTable
 #+END_SRC

    1.insert(key,value)
 when getting key and value, it combines them together into an entry object
 and stores that entry in the hash table and for some reason here 'insert' will also return
 the entry object creates to store your key in your value

 public Entry insert(key, value)
    - compute the key's hash code
    - compress it to determine bucket.
    - insert the entry into the bucket's chain

 public Entry find(key)
    - hash the key to hash code
    - search chain for entry with given key
    - if found, return it; else null.

 public Entry remove(key)
    - hash key to hash code
    - search the chain of bucket
    - remove from chain if found
    - return entry or null.


 But, still hava some issues:
 what if you try to insert multiple copies of the same key into the dictionary, like
 maybe a word has two different definitions and you want to put each of those definitions
 in as a separate entry.

 2 entries in same key. 2 approaches to handle this:

 1. G&T(book): insert both, find() arbitrary returns one. also this book give a findALL() function
    to give all items matching a certain key.
    so now your chain has tow different entries in it that have the
    same key or five different entries or 100 diffenent entries.
 2. Replace old value with new. Only one entry has given key.

 how to choose, depend on your application.


**** A Big Warning:
 insert sth into hash, eg an refference of object, you should NOT change the object, once you do,
 this will change its hashCode, because you change an object in a way that changes its hashcode,
 will make this object in the WRONG bucket and you'll never be able to look it up again.


**** Performance of Hash Table:
 performance of hash table is depand on how *much* stuff you try to pack into how *big* a hash table
 Load factor of a hash table: n/N = (items you want to store into hashtable)/(number of buckets)

 If load factor stay low, and if hash code & compress function are 'good', and no duplicate keys
 , THEN the chains are short, & each opreation takes O(1) time. And performance of hash table ,also
 depends on how big the chain is, that you have to search. if chain is big , it'll take >O(1)

 If load factor get BIG(n>>N), O(n) time.

**** Troublesome 1: Compression fn
 key -------(hashcode func)------> hashcode ----(compression func)------> bucket[0,N-1]

 Ideal: Map each key to a random bucket(use random function). with each bucket being equally likely.

 Bad compression function,eg:
 suppose keys are ints.
 hashCode(i) = i.
 Compression function h(hashCode) = hashCode mod N
 N = 10,000 buckets.
 Suppose keys are divisible by 4.
 h() is divisible by 4 too.
 Very Bad news, because 3/4 of our buckets are wasted.
 this means every bucket has a chain of 4 entries ,need handle with 4 collision.

 Some compression fn better if N is prime, any num mod N, they won't be divisible by
 any particular number.

 Better: chap9.2.4 of G&T
 h(hashCode) = ((a*hashCode + b) mod p) mod N)
 a,b,p : positive integers
 p: large prime
 p >> N

 'mod p' as scrambling the bits really well;
 'mod N' make it fit in your table

 the advantage of this over below, is now, N(buckets) dosen't need to be prime.

**** Troublesome 2: HashCode fn
if you have some string key, then string must convet to number.

Good hash code for Strings:
#+NAME: hashCode-fn
#+BEGIN_SRC java
private static int hashCode(String key){
    int hashval = 0;
}
#+END_SRC

*** hash table: java
#+BEGIN_SRC java
import java.util.Arrays;

public class HashFunction {

    String[] theArray;
    int arraySize;
    int itemsIntArray = 0;

    public static void main(String[] args){

    }
}

HashFunction(int size){
    arraySize = size;
    theArray = new String[size];
    Arrays.fill(theArray, "-1");
}
#+END_SRC

** lec 22: Stack and Queues
* How to setup tensorflow and cuda enviroment in emacs
  1. install tensorflow in anaconda virtual enviroment:
     1) conda info --envs
     2) conda create --name flowers --clone snowflakes
        or you can create a virtual env by *.yml* file
        1) conda env create -f environment.yml
           #+BEGIN_QUOTE
           name: stats2
           channels:
             - javascript
           dependencies:
             - python=3.4   # or 2.7
             - bokeh=0.9.2
             - numpy=1.9.*
             - nodejs=0.10.*
             - flask
             - pip:
               - Flask-Testing
           #+END_QUOTE
  2. setup ~elpy~ by just add 'elpy' in ~spc fed~ file of spacemacs-additional-package() function
  3. activate the virtual env in emacs, ~, V a~ to choose the ~/ananconda3/envs/tensorflow
  4. modify ~spc fed~ to add some PATH env.
     #+BEGIN_SRC emacs-lisp
     ;; yiddi: add python path
     (add-to-list 'exec-path "/home/yiddi/anaconda3/envs/tensorflow/bin")
     (add-to-list 'exec-path "/home/yiddi/anaconda3/envs/tensorflow/lib")
     (add-to-list 'exec-path "/usr/local/cuda-8.0/lib64")
     (setenv "PATH"
             (concat
              "/usr/local/cuda-8.0/lib64" ":"
              (getenv "PATH")
              )
             )
     (setenv "LD_LIBRARY_PATH"
             (concat
              "/usr/local/cuda-8.0/lib64" ":"
              (getenv "LD_LIBRARY_PATH")
              )
             )
     #+END_SRC
* how to solve company-fontends nill when eshell start
  I modify [[file:~/.emacs.d/layers/+tools/shell/funcs.el::(defun%20spacemacs/eshell-switch-company-frontend%20()][spacemacs//eshell-switch-compnay]] func  by add
  (require 'company)
  this solution come from github, not refer website here
* The simplest method to install source code pro in macbook
For Step 3 regarding installing Source Code Pro, it might be nice to provide
macOS users a quick incantation to get the font:

~brew tap caskroom/fonts~
~brew cask install font-source-code-pro~
* 配置 JAVA_HOME
1. 永久修改，对所有用户有效
    # vi /etc/profile
    //按键盘[Shift + g], 在 profile 文件最后添加下面的内容:
    export JAVA_HOME = /home/myuser/jdk1.7.0_03
    export PATH = $JAVA_HOME/bin:$PATH
    export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
    [注]：修改文件后如果想马上生效，还要运行 #source /etc/profile

2. 永久修改，对单一用户有效
    //修改用户目录下的.bash_profile 文件
     $ vi /home/myuser/.bash_profile
    //在文件最后添加下面的内容
     export JAVA_HOME = /home/myuser/jdk1.7.0_03
     export PATH = $JAVA_HOME/bin:$PATH
     export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
     [注]：修改文件后如果想马上生效，还要运行 #source /home/myuser/.bash_profile

3. 只对当前 bash /shell 生效
    $ export JAVA_HOME = /home/myuser/jdk1.7.0_03
    $ export PATH = $JAVA_HOME/bin:$PATH
    $ export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
* 2018
** 2018-04 April
*** 2018-04-14 Saturday

**** MESSY
   Source: [2018-04-14 Sat], **** MESSY  [[][]]
      Captured On: [2018-04-14 Sat 19:19]
*** 2018-04-16 Monday

**** MESSY analogous
     means some like adj

**** MESSY how to access and edit binary files in emacs
     There is a special major mode for editing binary files: Hexl mode. To use it, use ~M-x hexl-find-file~ instead of ~C-x C-f~ to visit the file. This command *converts the file's contents to hexadecimal* and lets you edit the translation. When you save the file, it is converted automatically back to binary.

You can also use ~M-x hexl-mode~ to translate an existing buffer into hex. This is useful if you visit a file normally and then discover it is a binary file.
** 2018-08 八月
*** 2018-08-10 星期五
*** 2018-08-30 星期四

* sbt
  ~ensimeConfig~
  ~ensimeConfigProject~
