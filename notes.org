Tips*
1. 這裏的文檔需要美化格式
2. [掛],盡量把自己看過的相關網頁等,都[掛]在自己已經有的 node 下面
3. 把小的信息通過[通過長時間累積的]掛, 來集合成[專題]
4. 當某個節點過大,直接新建 orgfile 存儲,並留下鏈接即可
5. Q&A 盡量歸類,不要獨立成節點
--------------------------
* Quick notes
** Spacemacs Rocks s2 day11-[Ubuntu]
   |   | window always on top | M spc |   |

** 问题查找与解决
*** 如何查找自己需要的 pkg 或 layer 说明?
    通过 SPC-h-R 来查找所有 spacemacs doc 匹配关键字.
*** 如何在 user-config 中定义按键,覆盖 evil-state-map 中的按键.
    #+BEGIN_SRC emacs-lisp

    #+END_SRC
    (defun dotspacemacs/user-init ()
    "Initialization function for user code.
    It is called immediately after `dotspacemacs/init', before layer configuration
    executes.
    This function is mostly useful for variables that need to be set
    before packages are loaded. If you are unsure, you should try in setting them in
    `dotspacemacs/user-config' first."
	(setq configuration-layer--elpa-archives
   	'(("melpa-cn" . "http://elpa.emacs-china.org/melpa/")
    ("org-cn"   . "http://elpa.emacs-china.org/org/")
    ("gnu-cn"   . "http://elpa.emacs-china.org/gnu/")))

    (setq tramp-ssh-controlmaster-options
    "-o ControlMaster=auto -o ControlPath='tramp.%%C' -o ControlPersist=no")
    )

    ;;; 有一个待解决问题, 在.emacs.d/elpa/evil/evil-commands.el 中定义了下滑函数,evil-maps.el 定义了其绑定键 C-e.
    ;;; 期待以后能学到改变方法.
    ;;; DONE 上面这个问题解决了,就是 user-init 主要放置初始化内容.user-config 是启动最后才做的事情.
    ;;;      我的解决方法仅仅是规避原来的 C-e 按键.放在 user-config 中定义.
    (defun dotspacemacs/user-config ()
    "Configuration function for user code.
    This function is called at the very end of Spacemacs initialization after
    layers configuration.
    This is the place where most of your configurations should be done. Unless it is
    explicitly specified that a variable should be set before a package is loaded,
    you should place your code here."
    (setcdr evil-insert-state-map nil) ;; 拷贝自子龙山人视频,不理解
    (define-key evil-insert-state-map [escape] 'evil-normal-state);; 拷贝自子龙山人视频,不理解
    (define-key evil-insert-state-map (kbd "C-e") 'mwim-end-of-code-or-line)
    (define-key evil-motion-state-map (kbd "C-e") 'mwim-end-of-code-or-line)
    )
*** 如何通过命令行修改某些参数的值 
    SPC SPC, counsel-set-variable, 中查询你要修改的变量修改即可
*** 如何创建自己的 layer(从原来的 emacs 配置拷贝) 
**** layer 基本配置
     1. spc spc , configuration-layer/create-layer. 简单配置自己的 layer 的一些元素.(参考 spc h R 中提供的 layer 相关结构文档).
     2. 其中结构中 packages.el(安装的包,以及进行包相关配置).funcs.el 主要定义一些函数*(其实也可以定义在 packages.el 的 user-packages 函数里)funcs.el 中尽量定义全局函数.
     3. 定义 hotkeys 就放在 keybindings.el 里面.
     4. config.el 一些与 layers 相关的配置
     5. layers. 声明额外的 layers.
**** pkg 初始化函数
     1. 每一个安装在 defconst yiddi-packages 函数中的 pkg,都对应一个(defun yiddi/init-<pkgName>())函数来进行一些 hotkey 等的初始化
     2. spacemacs/set-leader-keys 通过这个函数设置 hotkey(除去 SPC 的部分),并绑定对应启动的功能函数
*** 三种方式更改 pkg 参数 
    1. 包安装位置有 packages.el 里面会有部分配置.
    2. 在 init.el 中有 user-config.
    3. 在自定义 layer 的配置文件中,有 config.el,里面也有
*** 如何在某个 minor-mode 的编辑模式下用 evil 的快捷键,kjhl? 
    evilified-state-evilify-map 函数, refer to doc for how to use it.
*** 如何知道目前的编辑模式是 evil 还是 emacs?
    看 mode-line 哪一行,
    - 浅黄色 : 简化版 evilmode
    - 深黄色 : evil-normal
    - 绿色   : evil-insert
    - 灰色   : evil-visual
*** 遇到配置配了,spc feR 也生效了,但是重启后就出 error 
    这种问题一般都是 spacemacs 启动加载顺序造成的.
    1. 重启之前 emacs 中所有符号都已经加载(赋值了)
    2. 重启之后有加载顺序,很有可能你的配置中的某个函数的所属库是在你当前配置之后加载的.
    3. 这时 spacemacs 肯定就启动不了了.
    4. [解决] 理论上 initel -> user-config 函数中的配置是最后加载的.
    5. 所以最懒,最安全,最不美的做法,就是统统放进 user-config 里.
*** 对于 spacemacs 默认安装的包的配置如何做更改? 
    1. 首先在你的 layer->packages.el-><layer-name>/post-init-packages 函数中,添加该包名
    2. 比如 auto-complete layer, company 包,默认给两个字符才会启用自动补全,我希望是 1 个就启动
    3. 这时候我可以在我的自定义 layer 的 package.el 中配置.
    #+BEGIN_SRC emacs-lisp
    (defun yiddi/post-init-company()
      (setq company-minimum-prefix-length 1))
    #+END_SRC
    我们不想直接改 company 的原始配置,因为他在.emacs.d 文件夹里,我们没必要管理 emacs 的 200
    多个包,所以没有 git 整个文件夹,而是 git 了另一个.spacemacs.d 里的自己的配置.
*** 一般的安装和配置包的过程是这样的 
    1. 首先 spc h spc 查看有没有安装这个包,如果有
    2. 不用安装,直接在自己的 layer-> packages.el 中对其进行更改即可
       #+BEGIN_SRC emacs-lisp
       (defun <layer-name>/<post-init-pkgname>()
         (setq <pkg-variable> <value>)
       #+END_SRC
*** 自定义 layer package.el 配置三剑客函数
    1. pre-init-<pkg-name>
    2. init-<pkg-name>
    3. post-init-<pkg-name>
    就是按上面的顺序,在 spacemacs 启动时会调用三个函数.
*** 如何安装自己需要的包
    在 spc fed --> additional package() 直接添加自己需要的包名
*** how to find file you want?
    1. spc f f -- find file from directory
    2. spc f r -- find file from records of files recently opened
    3. spc p l -- choose the git-project root file
    4. spc p f -- find file in git-project
    5. spc s p -- find text of file by helm-ag in current directory
*** how to find keywords you want in a file / from the direcory?
    1. Out of a file, =spc s p= you can find the keywords by =spc s p=, which will traverse all files under root directory, list the keyword you want.
    2. In a file,     =M-s-o=   you can list the words you want in a new window, and can edit it.
*** how to find the hotkey of some package?
    1. find the package setting files from spc h spc
    2. find the package.el, hotekys offen defined in it
*** how to reload a mode without closing the emacs
    spc :  (m-x) input diminish-undo, then input eg. company-mode. it will reload company-mode in current buffer

*** how to get the source code of the package?
    many methods can make it:
    1. =M-x: helm locate library=  load all the library code(includes the .el which not load in current emacs)
    2.
*** how to setup other module of org, like org-protocol?
    =M-x customize-variable= then =org-modules=
*** how to find the built-in help doc of some packages?
    =M-x: describe-package=
    =spc h d p=
*** how to select fly-checker?
    you can choose *Tools* from menu bar at top of emacs window
    *Tools* -> *syntax check* -> *select syntax checker*
    emacs will give you a list of syntax checker in mini-buffer.
    then choose one you want , if it pop a windwo and give a msg "can't use this checker" something like that
    you can google for tips to install it in your OS,
    like *pylint*, you must install it from pip
    =sudo pip install pylint=
*** how to set python enviroment and how to use it?               :org:babel:
    =C-c C-p= in .py file to open a python shell
    =C-c C-c= in .py file to run and send buffer to python shell
    #+BEGIN_SRC python
     import random
     for i in range(10):
         print random.randrange(1, 10)
     def f(x):
         return 2*x
    #+END_SRC
*** how to install virtualenv for python development?
    1. =pip install virtualenv= install virtualenv
    2. =virtualevn <ENV-name>= create a virtual enviroment for python
       - =virtualenv --system-site-packages <ENV-name>= create a virtual enviroment inherient all the system's pkgs
       - =virtualenv --no-site-packages <ENV-name>= create a enviroment without inherient.
       - =virtualenv -p /usr/bin/pythonx.x <ENV-name>= indicate a version of python
    3. =source ./bin/activate= activate the current python env
    4. =./bin/deactivate= deactivate the current python env
    5. =pip list= display all the pkgs installed in current virtual env
    6. =pip freeze= display all dependence in current virtual env
    7. =pip freeze > requirement.txt= can export all the requirements to a file
    8. =pip install -r requirement.txt= install all the dependence automatically
*** how to setup enviroment for exporting org to pdf
    1. install texlive
    2. install texlive cjk extension
    3. install latexpdf
    4. do some setting of ctex
*** how to split a long long line into a paragraph?            :Org:TextEdit:
    =M-q= will work well for that
*** how to set/jump to bookmark?                                      :Emacs:
    emacs: =C-x r m= set
    =C-x r b= jump
    spacemacs: =spc b m s= set
    =spc b m j= jump
*** how to transform 'html' to 'pdf'                            :Ubuntu:tool:
    we can use *wkhtmltopdf* to do this job and use the command:
    =wkhtmltopdf <URL_of_page> <name.pdf>=
    and, this tool has many ARGS which can be used very handy.
    google for wkhtmltopdf
*** how to open debug message in emacs
    =spc t D=

** 一些关于 chap4 <webgl beginer guid> 实验代码结构的理解

   可以发现, 在整个源码结构中工具 js 代码文件以两种形式存在:
   1. 以字典的形式, 整个 js 代码文件就只定义了一个字典结构, 属性和函数都是字典的
      键值对. eg, Floor.js, Axis.js
   2. 以"正常"(这里正常的意思是指与 html 的 js 标签内的代码类似)的 js 代码形式,
      属性使用 var 定义, 函数使用 function 定义. eg, WebGLApp.js

   第一种如下示例
   #+BEGIN_SRC javascript
     // ch4_NissanGTR.html 中调用 FLoor.js 的语句
     Floor.build(2000,100);

     // Floor.js 中只声明了一个复杂的字典
     var Floor = {
         alias       : 'floor',
         wireframe   : true,
         dim         : 50,
         lines       : 50,
         vertices    : [],
         indices     : [],
         diffuse : [0.7,0.7,0.7,1.0],
         build : function(d,e){...}
     }
   #+END_SRC

   第二种如下示例
   #+BEGIN_SRC javascript
     // ch4_NissanGTR.html 中调用 WebGLApp.js 的语句
     app = new WebGLApp("canvas-element-id")

     // WebGLApp 中的代码包括变量声明,函数定义,函数原型属性定义
     var WEBGLAPP_RENDER = undefined;
     var WEBGLAPP_TIMER_ID = -1;
     var WEBGLAPP_RENDER_RATE = 500;

     function WebGLApp(canvas) {...}

     WebGLApp.prototype.run = function(){...}
     WebGLApp.prototype.refresh = function(){...}
   #+END_SRC

  [2019-06-14 五 20:27]

** <clojure for the brave and true - Building, Running, and the REPL> 通过 lein 对 clojure 编译并运行

1. build project

#+BEGIN_SRC shell
lein new app [app-name]
#+END_SRC

this command will build a project under current directory, the structure
looks like this:

#+BEGIN_EXAMPLE
.
├── CHANGELOG.md
├── doc
│   └── intro.md
├── LICENSE
├── project.clj
├── README.md
├── resources
├── src               <--- enter this directory and run
│   └── [app_name]
│       └── core.clj
└── test
    └── [app_name]
        └── core_test.clj
#+END_EXAMPLE

1. coding

   #+BEGIN_SRC clojure
     ; declare name space
          (ns clojure-noob.core
            (:gen-class))

     ; entry point of project
          (defn -main
            "I don't do a whole lot ... yet."
            [& args]
            (println "I'm a little teapot!"))
   #+END_SRC

2. running project

   #+BEGIN_SRC shell
     # cd the ./src/[app_name] directory and execute the following command
     lein run
   #+END_SRC

3. build project into a jar

   if you want to share your work with people who don't have Leiningen installed
   you can create a *stand-alone file* that anyone with java installed can
   execute.

#+BEGIN_SRC shell
lein uberjar
#+END_SRC

This command create the file
~arget/uberjar/clojure-noob-0.1.0-SNAPSHOT-standalone.jar~. You can make Java
execute it by running this:

#+BEGIN_SRC shell
java -jar target/uberjar/clojure-noob-0.1.0-SNAPSHOT-standalone.jar
#+END_SRC


4. repl

Using the following command to start a REPL:

#+BEGIN_SRC shell
lein repl
#+END_SRC

it should give the response as:

#+BEGIN_SRC shell
  clojure-noob.core=>
# \----------/ \--/
#    工程名     src/[app_name]/core.clj
#+END_SRC

then you can input some lisp-like code:

#+BEGIN_SRC clojure
clojure-noob.core=> (+ 1 2 3 4)
10
clojure-noob.core=> (* 1 2 3 4)
24
clojure-noob.core=> (first [1 2 3 4])
1
#+END_SRC


  [2019-06-15 六 23:33]

** <clojure for the brave and true - Building, Running, and the REPL> 通过 lein 对 clojure 编译并运行

   start a clojure repl:

   =M-x cider-jack-in=
 
   ArityException 
    
** 泰勒斯威夫特的歌词,特别好

   #+BEGIN_QUOTE
You held your head like a hero
On a history book page
It was the end of a decade
But the start of an age
—Taylor Swift
   #+END_QUOTE

  [2019-06-17 一 16:31]

* org mode                                                              :ORG:
** org-agenda is your friend
   Never start to do anything before looking at the agenda view. why agenda
   matters? every successful people almost have a secret who will organize your
   time and maximize the value of your time. this is the key to long term
   success. remember how many time you waste on wechat

** what should be in org agenda view?
   1. important and emergency things goes first, they got A priority, along with
      important and not evergency tasks.
   2. a few habits to keep you update to date. good habit always makes you a good person.
   3. Like: health, reading, blogging, family and friendship
** when you start to do a task in the org-agenda view ,dont foget to clock in with pomodoro
   1. this way you could track your time and effect.
   2. all the goodness of the pomodoro technicals

** weekly review and adjust th priority of todo items and weekly archive done items
   you need only one gtd.org file, and many files in org agendafiles.

** keep an eye on what you have spent on each day, each week and each month
   show it in my gtd.org file
** demonstration the usage of org capture
   1. capture a todo with priority and tags.
   2. capture a chrome links for later reading.
   3. capture a task with a source code file
** vinum extension in chrom to select txt                     :Chrome:vimium:
   i know that now, vimer prefer using "/" searching and locating cursor to
   moveing cursor to locate. Likely in vinum extension of chrome, user should
   use "/" to locate and switch to *visual-mode* to select and =y= to copy
** a few tips
   1. embed pdf links to todo items such that you could easily access them.
   2. insert the current chrome tab into place
   3. learn GTD method now!
** org agenda .+1w and +1w
   the big diff between =.+1w= and =+1w= is *when is the next time to do this task*
   - =.+1w= means planning next schedule-time according to the *finished time*
   - =+1w=  means planning next schedule-time according to the *last schedule time*

   - =+1w=  will set the schedule-time to the *same day of a week*.
   - =.+1w= will set the *same time-gap* between two schedule-time.
** add tags to org-agenda
   =C-c C-q= to add tags for current branch of org file
** use follow-mode to see different TODO tasks in different files
   =F= when in *week-agenda-view*, we can dinamically see them in source file by
   press =F= by this method, we can jump directly to that file where current
   task located.
** how to customize the agenda view
   1. =C-c a= enter agenda-view, and press =C= to enter customize-view.
   2. every node has 4 items: value menu, access key, description, component
   3. =value menu= has 3 choose items
      - =single command= means locate a single char in agenda-view and type it will get the results
      - =prefix= means locate a single char in agenda-view and type it will enter another choose-view
        - =access key= must contain the prefix char
      - =command series= means locate a single char in agenda-view and will give many group of results
   4. =access key= hot key for typing to choose this view
   5. =description= a text for describe this view
   6. =component= contains some matching conditions and matching form
** how to set tags/ todo-items/ and drawers for a org file?
   1. =#+SEQ_TODO=
   2. =#+TAGS=
   3. drawers start with a line =:<DRAWERNAME>:= end with next line =:END:=
      1) customize =org-log-into-drawer= to LOGBOOK
      2) =C-c C-z= to add a note in this branch of org file, you can note everything
         when you do this task.
** how to add note to a branch of org file
   =C-c C-z= will add a LOGBOOK drawer in this branch, and you can note anything
   when you do this task.
** how to clutter up your org file, archive?
   1. =#+ARCHIVE: <filename>.org::= set archive file for local file
** how to archive to different org file?
   1. in a branch of org file, =:ARCHIVE: <filename>.org::* <Father-node-name>=
   2. eg
      #+BEGIN_SRC org
      * Books
      :PROPERTIES:
      :ARCHIVE: track-books.org::* Read books
      :END:
      #+END_SRC
   3. =* <Father-node-name>= indicate the father node name in archive file
** STARTED timer in org                                               :TIMER:
   :LOGBOOK:
   CLOCK: [2017-02-28 二 09:05]--[2017-02-28 二 09:30] =>  0:25
   CLOCK: [2017-02-27 一 21:41]--[2017-02-27 一 21:42] =>  0:01
   CLOCK: [2017-02-27 一 21:32]--[2017-02-27 一 21:33] =>  0:01
   :END:
   In spacemacs, many org related commands are lead by hotkey =,=
   includes *timer* *priority* *tag* *archive* *capture* *Drawer* *sparse-tree* *pomodoro*
   1) =,I= record the start time of this org branch
   2) =,O= record the end time of this org branch
   3) =C-c C-x <tab>= record the start time of this org branch
   4) =C-c C-x C-o=   record the end time of this org branch
** automatic logging of status changes                                  :LOG:
*** Goal: get a logbook entry whenever a TODO keyword chenges
    #+BEGIN_SRC org
   #+SEQ_TODO:TODO(t@/!)
   t - hotkey assigned to that TODO keyword
   @ - log a timestamp and note when this is entered
   ! - log a timestamp when you leave that keyword
    #+END_SRC
    the configuration of TODO should be:
    #+BEGIN_QUOTE
    #+SEQ_TODO: NEXT(n/!) TODO(t@/!) WAITING(w@/!) SOMEDAY(s/!) PROJ(p) | DONE(d@) CANCLE(c@)
    #+END_QUOTE
*** Goal: log a "CLOSED" timestamp when something is done
    customize variable =org-log-done=
*** Goal: log a note with a timestamp every time something is rescheduled
    customize variable =org-log-reschedule=
** how to add CLOCKING drawer automatically when clock in/out?        :TIMER:
   add ='(org-clock-into-drawer "CLOCKING")=
** Function: the :PROPERTIES: drawer
   the :PROPERTIES: drawer stores task specific settings and user defined attributes.
   *Important* : the :PROPERTIES: drawer must immediately follow the headline!
*** Goal: you dont want to create a log entry every time a repeating task is done
    recipe: define a :LOGGING: property with value nil
    matching properties in agenda views is possible too.
** how to setup a template for reading books in org file    :PROPERTY:DRAWER:
   #+BEGIN_SRC org
   * SOMEDAY %^{Author} - %^{Title}
   :PROPERTIES:
   :PAGES: %^{Pages}
   :GENRE: %^{Genre}
   :END:

   - Recommended by %^{recommended by}
   :LOGBOOK:
   - Added: %U
   :END:

   #+END_SRC
** [tips] org-agenda view can match TAGS/PROP/TODO
   so, TAGS PROP TODO can be searched as an index.
   you should orgnize your PROP properly.
   you can search PROP like =<PROP-ITEM>=XX=
** Function ordered tasks
*** Goal: task should be completed one after one
    Recipe: define an :ORDERED: property with value 't'
    Toggle the :ORDERED: with =C-c C-x o=
    Customizing variables:
    '(org-enforce-todo-dependencies t)
    '(org-track-ordered-property-with-tag t)
    More customization:
    org-agenda-dim-blocked-tasks
    org-enforce-todo-checkbox-dependencies
** Column view in org
*** Goal: show your org file in columns
*** Recipe : define columns that
    =#+COLUMNS: %7TODO(To Do) %58ITEM(Task)...=
    Column view can set locally with the :COLUMNS: property in a property drawer
    Show column view =C-c C-x C-c=
    Leave view =q=
** Effort estimates                                                  :EFFORT:
*** Goal: Estimate the effort that your task will need
*** Recipe: effort estimates are stored in a property
    setup: add definition to head of org file
    #+COLUMNS: %7TODO(To y Do) %40ITEM(Task) %TAGS(Tags) %6CLOCKSUM(Clock) %8Effort(Effort){:} %7Rating(Rating)
    =#+PROPERTY: Effort_ALL 0:05 0:10 0:15 0:20 0:30 1:00 2:00 4:00 6:00=
    =#+PROPERTY: Rating_ALL + ++ +++ ++++ +++++=
    and then possible values. add this to column view with
    =%8Effort(Effort){:}=
    . The {:} menas sum up times.
    Increase Effort : =Shift ->=
    Decrease Effort : =Shift <-=
** Rating the importance of org TODO items                           :RATING:
   setup: add definition to head of org file
   #+COLUMNS: %7TODO(To y Do) %40ITEM(Task) %TAGS(Tags) %6CLOCKSUM(Clock) %8Effort(Effort){:} %7Rating(Rating)
   #+PROPERTY: Rating_ALL + ++ +++ ++++ +++++
   press =C-c C-x C-c= to enter org column view
   step into the unit-box of "Rating", and press
   =Shift <-= =Shift ->=
   to give the Rating to certain org branch
** Linking to other items in actual file                               :LINK:
   Goal:     Link to other items in the actual file
   Recipe:   A link looks like that
   \[\[ target\]\]
   [[Function ordered tasks]]
   Targets:
   A headline - *link name should identical with head name*
   *Any place* in the document with a =#+NAME: <target name>=
   An item with a =:CUSTOM_ID: <ID>= in =:PROPERTIES:=, with =[[#<ID>]=
   Special:
   Radio targets that look like this <<<target>>> create links ont the fly
   Key combinations:
   Edit links with =C-c C-l=
   Follow link with =C-c C-o=
   Return to previous position =C-c &=
** linking to other items somewhere in the world                       :LINK:
   Goal:     link to other items some where in the world
   Recipe:   \[\[XXXX\]\]
   Target:   protocol:location
   [[file:/home/yiddi/...]
   [[http://www.youtube.com]
   [[bbdb:Susan Jones]
   Special:
   Linking to items with an ID property
   ID is an UUID that you can create with
   =M-x org-id-get-create=
   Customizing:
   copy the code from the video description to
   the end of your ~/.emacs file
   org-id-locations-file stores in what file
   orgmode should look for IDS
** Attachments                                                       :ATTACH:
   - Goal
     Attach some files to your task
   - Recipe
     Call the attachment system with =C-c C-a=
     - s : set a specific directory for task attachment
     - l : inherit the attachment directory to the children of task
     The attachments are usually stored under *./data/* and then a
     structure based on the ID property
     - a : attach file with the method configured in org-attach-method
     - c : attach file by copying
     - m : attach file by moving(deletes original file)
     - l : attach file by creating a hard link
     - y : attach file by creating a symbolic link
     - o : open attachment, if more than one ask for the name
     - O : open attachment in emacs
     - f : open the tasks attachment directory
     - F : open th tasks attachment directory by dired in emacs
     - d : select and delete a single attachment
     - D : delete all attachments
     - n : create a new attachment
     - z : synchronize the task with its attachment directory
** Priority                                                        :PRIORITY:
   :LOGBOOK:
   - State "NEXT"       from "TODO"       [2017-02-28 二 16:06]
   :END:
   set priority of org branch
   org-mode priority are usually ABC
   you can change them by a configuration line:
   #+PRIORITIES: 1 5 3
** Export                                                            :EXPORT:
   Export org files to HTML or PDF
   =C-c C-e=
   customization:
   Setting =org-file-apps= determines the application to open files.
   Add a line with =#+OPTIONS:= to fine tune the output
   d:t    show the contents of drawers
   \n:t   perserve line breaks
   p:t    Export planing information(SCHEDULE/DEADLINE)
   todo:t Include TODO keywords into exprorted text
** Advanced org export                                               :EXPORT:
   by =M-x customize-group= choose =org-export= you can customize many items.
   or
   by add some text head of org file:
   ------------------------------------
   +AUTHOR: name the author of the document
   +TITLE: to define a title
   +SUBTITLE: to define a subtitle
   +DESCRIPTION: produces meta data, no output by default
   +BEAMER_THEME: select a beamer theme, goolge for "latex beamer themes" to get an idea what is avaible
   +BEAMER_FONT_THEME: select a font for the beamer slides
   ------------------------------------
   followed by =#+OPTIONS:=
   | option                     | what does it do?               |
   | toc                        | enable table of contents       |
   | ^                          | enable sub/superscripting      |
   | tags                       | export tags                    |
   | f                          | export footnotes               |
   | \n                         | toggle line break preservation |
   | @@latex:\textbackslash n@@ | toggle line bread preservation |
   ------------------------------------------
   Even if org-mode offers several export backends, your file si ususally defined for one sepcial
   backend.
   The beamer backend is nice for standardized outline slides, but its lacking of desing and images.
   SO there is a good chance that your presentation is boring.
   *Book recommondation: Garr Reynolds - Presentation Zen*
** Publish org to extenal server(like bolg)                          :EXPORT:
   1. Customize your web server
      Enable user directory public_html (eg. On Debian 8 this is done as root user by)
      # cd /etc/apache2/mods_enable
      # ln -sf ../mods_available/userdir.conf userdir.conf
      # ln -sf ../mods_available/userdir.load userdir.load
      # systemctl restart apache2.service
   2. Customize your ~/.emacs file
      #+BEGIN_SRC emacs-lisp
        (setq org-publish-project-alist
              '(("org"
                 :base-directory "~/org/"
                 :publishing-directory "~/public_html"
                 :publishing-function org-html-publish-to-html
                 :section-numbers nil
                 :with-toc nil
                 )))
      #+END_SRC
   3. Try the export function
      - Open your webbrouser and go to http://loacalhost/~joe/
      - Call the export dispatcher with C-c C-e
      - Press "P" for Publish
      - Choose what to publish
   4. Additional information
      OrgMode is keeping timestamps of the exported files in ~/.org-timestamps/
      delete this directory if you delete public_html, otherwise only files
      changed since the last run will be exported
** Reporting clock time in org                            :TIMER:CLOCK_TABLE:
   1. Gereral info on dynamic blocks
      - A dynamic block calls a function to create content dynamically
      - A dynamic block starts with a line =#+BEGIN: name=
        - The name is the name of function to call
      - A dynamic block can have =:parameters=
        - Parameters are written as =:parameter1 value1=
      - A dynamic block ends with a line =#+END:=
      - Some predefined functions are available
        - *clocktable* to build a time accounting table
        - *columnview* do capture a columnview inside a document
   2. Building a clock table
      - We add a clock table to it:
        - position on the headline and press =C-c C-x C-r=
        - adjust =:scope= for the scope : subree,file,file-with-archives ... etc.
        - adjust depth by changing =:maxlevel=
      - Update the table at any time with C-c C-c
        - Cursor needs to be on the line with =#+BEGIN:=
        - You will see the time of the latest update in the caption line
** Advanced clocktable
   Add *some config* at the end of =#+BEGIN: clocktable...=
   - Use =:block thismonth= to show a block of time for a month
     - move forward with type =Shift ->= immediately after =:block thismonth=
     - move backward with =Shift <-= immediately after =:block thismonth=
   - Use =:step week= to show weekly values
   - Use =:tstart= and =:tend= to specify a time range
     - Date specifiers inside double quotes "<2017-2-28>"(you must type in by org-time-stamp)
     - org-time-stamp ususally =,.= or =C-c .=
** Capture column view                                          :COLUMN_VIEW:
   Goal: export column-view (to another file)

   "Since column view is just an overlay over a buffer, it cannot be
   exported or printed directly" (The org menual)

   - But you can create a dynamic block with a column view
   - Place your cursor where you want the block to be and press =C-c C-x i=
   - You will be asked for a value of the parameter =:id=
     - local : uses the tree in which the block is located
     - global : uses all headings in the file
     - "path-to-file" : uses the whole file
     - "ID" : uses the subtree with this :ID: property
** Bulk agenda actions                                               :AGENDA:
   1. Setting marks in agenda view
      | Key | Action                                    |
      | m   | mark entry at point                       |
      | u   | unmakr entry at point                     |
      | *   | makr all entries                          |
      | U   | unmark all entries                        |
      | M-m | toggle mark at point                      |
      | M-* | toggle all marks                          |
      | %   | mark enties base don a regular expression |
   2. Bulk actions in agenda view
      - Call for bulk actions by pressing =B=
        - then choose what action to preform
        - after the action is performed the marks are removed
        - you can toggle persistent marks with *
      - Archiving entries
        - =$= archive all marked entries to their archive files
        - =A= archive entries by moving them to their reprctive siblings
   3. Bulk actions: Change and refile entries
      | Key | Meaning                                                   |
      | t   | change TODO state                                         |
      | +   | Add a tag to all selected entries                         |
      | -   | remove a tag from all selected entries                    |
      | f   | apply a function to marked entries.see menual for details |
      | r   | prompt for a single refile target and move all entries    |
      |     |                                                           |
** Tacking Habit                                               :AGENDA:HABIT:
   1. what is a habit?
      Habits are recurring tasks that you do frequently. Examples:
      - Brush your teeth everyday
      - Water your plants in the house every second day
      - Go to gym every week
   2. Once habit are really *installed* in your brain you dont need
      a remainder to do them
   3. Prerequisites to track habits
      - You need to enable the *habits module* in org-modules
        - =M-x customize-variable= then =org-modules=
      - Your habit is a recurring item with a TODO keyword representing an "open" state
      - You need to define a property *STYLE: habit*
      - The syntax for repetitions is a bit different:
        *'.2d/3d' means you do the task at least every three days, at most every days*
      - Important: Logging of changes to DONE needs do be enbaled
        - *when you mark the current occurence done dont kill the log entry with C-c C-k!*
   4. Real life example
      - Play the bass for 10min everyday
        - recurring task with repetition interval '.+1d'
        - Style "habit" defined as a property
      - Play guitar every 3rd day at least, better every 2nd day
        - recurring task with repetition interval '.+2d/3d'
        - Style "habit" defined as a property
   5. How does a habit look in an angenda view?
      - looks like a scheduled task, but with a block graph at the end.
        - The "!" marks the actual date
        - Every "*" marks a completed task on that day
        - Background color meanning:
          - Blue: task was to be done yet on that day
          - Green: task could have been done on that day
          - Yellow: task will be overdue the next day
          - Red: task is overdue on that day
   6. Additional tips
      1. customize =org-habit-show-habits-only-for-today= if you want to
         see habits that are not due today
      2. Habit tracking tracks just the successful completion of your habit
         so, if you use it like we did in our example define another task
         to track your progress
      3. Once a habit is successfully installed(usually around 3 weeks)
         you could also delete the habit tracking task
** Tables in org                                                      :TABLE:
*** Organize reference material in tables
    - Separate columns with "|"
    - Start rows with "|-" and press =tab=
    - Move columns with =Alt <-= or =Alt ->=
      - spacemacs: =Alt h/j/k/l= move column/row up/down/left/right
    - Delete/insert column with =Alt shift <-=  =Alt shift ->=
      - spacemacs: =Alt shift h/j/k/l= insert/delete column/row
    - Insert a horizontal line with =Ctrl c -=
    - Define constants with =#+CONSTANTS:=
    - Define forumulas =#+TBLFM:=
      + Columns referenced by =$= column-num
      + Rows referenced by =@= row-num
    - eg.

    #+CONSTANTS: skbios=string("1.15.0")
    |       |        |     | curr | new    |        |
    | Board | System | CPU | BIOS | BIOS   | action |
    |-------+--------+-----+------+--------+--------|
    |       |        |     |      | 1.15.0 | update |
    #+TBLFM: $5=$skbios; :: $6=if("$5" == "$4", string(""), update);
** Code Snippets in OrgMode                                            :CODE:
   Programming in org SRC block,
   - we can use =<s <tab>= to create this block automatically.
   - when code in that block, we can use =,'= to enter a *special-edit-window* and
     use =,c= to commit it.
   - we also can add *line-num* and *reference* to that block, by just add =-n= and
     =-r= to end of the =#+BEGIN_SRC= line.
   - we can ref to certain line by add =(ref: <ref-name>)= to end of that line.
     and =C-c C-l= to link to that =<ref-name>=
   - eg.
     #+BEGIN_SRC python -n -r
   @bottle.route('/'):
   def blog_index():
      cookie = bottle.request.get_cookie("session")
      username = sessions.get_username(cookie)               (ref:username)
      if not username:
          username = "Unknown"
      # snip
      return bottle.template('blog_template', dict(username=username))
     #+END_SRC
** Table of contents in org         :Export:Table of Content:
   TOC is normally inserted directly *before the headline of the file*.
*** choose the depth of TOC
    #+BEGIN_SRC
    ---------------------
    #+OPTIONS: toc:2
    #+OPTIONS: toc:nil  (no TOC)
    ---------------------
    #+END_SRC
*** choose the location of TOC
    #+BEGIN_SRC
    ---------------------
    #+OPTIONS: toc:nil  (no default TOC)
    #+TOC: headlines 2  (insert TOC here, with two headline levels)
    ---------------------
    #+END_SRC
*** generate a list of tables or listing
    you can also add a TOC to all the *tables* created in your org files
    #+BEGIN_SRC
    ---------------------
    #+TOC: listings     (build a list of listing)
    #+TOC: tables       (build a list of tables)
    ---------------------
    #+END_SRC
** Org-babel with programming                                     :org:babel:
*** Calculation using a formula

      :URL:
      [[http://home.fnal.gov/~neilsen/notebook/orgExamples/org-examples.html#sec-15][Emacs org-mode example and cookbook]]
      :END:

      =:exports= will export the source-code and result
      #+BEGIN_SRC python :results output :exports both
      def times_two(x):
          y = x*2
          return y
      print times_two(5)
      #+END_SRC

      #+RESULTS:
      -------------------------------------
      #+HEADERS: :classname HelloWorld :cmdline "-cp ."
      #+BEGIN_SRC java :results output :exports both
              public class HelloWorld {
                  public static void main(String[] args) {
                      System.out.println("hello,world");
                  }
              }
      #+END_SRC

      #+RESULTS:
      : hello,world
      -------------------------------------
      #+tblname: delsee
      | airmass | zenith_seeing | delivered_seeing |
      |---------+---------------+------------------|
      |     1.3 |          0.95 |        1.1119612 |
      |     1.3 |           1.0 |        1.1704854 |
      |     1.3 |           1.1 |        1.2875340 |
      |     1.3 |           1.2 |        1.4045825 |
      #+TBLFM: $3=$2*($1**0.6)

      #+BEGIN_SRC python :var delsee=delsee :results output
        print delsee
      #+END_SRC

      #+RESULTS:
      : [[1.3, 0.95, 1.1119612], [1.3, 1.0, 1.1704854], [1.3, 1.1, 1.287534], [1.3, 1.2, 1.4045825]]
      #+BEGIN_SRC python :var fname="delseepy.png" :var delsee=delsee :results file
        import matplotlib.pyplot as plt
        x, y, z = zip(*delsee)
        fig = plt.figure()
        axes = fig.add_subplot(1,1,1)
        axes.plot(y, z, marker='o')
        fig.savefig(fname)
        return fname
      #+END_SRC

      #+RESULTS:
      [[file:]]

*** python in org-babel
    [[file:~/Documents/org-notes/Python/python-x.org]]
*** Interactive with python

      Contents:
      23.1 Using an org-mode table in python
      23.2 Plotting with python
      --------------------------------------
      23.1 Using an org-mode table in python

      #+tblname: delsee
      | airmass | zenith_seeing | delivered_seeing |
      |---------+---------------+------------------|
      |     1.3 |          0.95 |        1.1119612 |
      |     1.3 |           1.0 |        1.1704854 |
      |     1.3 |           1.1 |        1.2875340 |
      |     1.3 |           1.2 |        1.4045825 |
      #+TBLFM: $3=$2*($1**0.6)

      #+BEGIN_SRC python :var delsee=delsee :results output
print delsee
      #+END_SRC

      #+RESULTS:
      : [[1.3, 0.95, 1.1119612], [1.3, 1.0, 1.1704854], [1.3, 1.1, 1.287534], [1.3, 1.2, 1.4045825]]

      23.2 Plotting with python

      This:

      #+tblname: delsee
      | airmass | zenith_seeing | delivered_seeing |
      |---------+---------------+------------------|
      |     1.3 |          0.95 |        1.1119612 |
      |     1.3 |           1.0 |        1.1704854 |
      |     1.3 |           1.1 |        1.2875340 |
      |     1.3 |           1.2 |        1.4045825 |
      #+TBLFM: $3=$2*($1**0.6)

      #+BEGIN_SRC python :var fname="delseepy.png" :var delsee=delsee :results file

import matplotlib.pyplot as plt
x, y, z = zip(*delsee)
fig = plt.figure()
axes = fig.add_subplot(1,1,1)
axes.plot(y, z, marker='o')
fig.savefig(fname)
return fname

      #+END_SRC

      #+RESULTS:
      [[file:delseepy.png]]
*** Running Test
      You can run the doctests from with org-mode with this bash code snippet:

      #+NAME: bashrun-helloworld-doctest
      #+BEGIN_SRC sh :results output :exports both
python -m doctest test_HelloWorld.txt 2>&1
true
      #+END_SRC

      If the test succeeds, it will produce no output

*** Defining unittest tests
    Define the unit test like any other piece of python code:

    #+NAME: unittest-foo
    #+BEGIN_SRC python
 class TestFoo(unittest.TestCase):
     def test_foo(self):
         greeter = HelloWorld('foo')
         self.assertEqual(greeter.who, 'foo')
    #+END_SRC
*** Making TestHelloWorld.py
    Define the main testing module like this:

    #+BEGIN_SRC python :noweb yes :tangle TestHelloWorld.py :exports none
 import sys
 import unittest
 from doctest import DocFileSuite
 from HelloWorld import *

 <<unittest-foo>>

 def main():
     suite = unittest.TestSuite()
     suite.addTests( DocFileSuite('test_HelloWorld.txt') )
     suite.addTests(
         unittest.defaultTestLoader.loadTestsFromModule(sys.modules[__name__]))
     unittest.TextTestRunner(verbosity=2).run(suite)
     return 0

 if __name__ == '__main__':
     status = main()
     sys.exit(status)
    #+END_SRC

*** Running all tests
     Use this bash source block to run all tests:

     #+NAME: bashrun-helloworld-alltest
     #+BEGIN_SRC sh :results output :exports both
python -m doctest test_HelloWorld.py 2>&1
     #+END_SRC
     The output looks like this:

     python TestHelloWorld.py 2>&1
     test_HelloWorld.txt
     Doctest: test_HelloWorld.txt ... ok
     test_foo (__main__.TestFoo) ... ok

     ----------------------------------------------------------------------
     Ran 2 tests in 0.004s

     OK

*** Add reference link in source block
    官方名字: code line label:
    #+BEGIN_SRC emacs-lisp -n -r
      (defun yiddi/test ()
        (message "tst"))      (ref:hello)

    #+END_SRC
    [[(hello)]]
* by now, The KENG in spacemacs
** how to solve cannot run code in SRC block
   [[http://emacs.stackexchange.com/questions/28441/org-mode-9-unable-to-eval-code-blocks][Org-mode 9: unable to eval code-blocks]]
   I solved it in spacemacs, just by removing all the .elc files
   in org-plus-contrib, and restart spacemacs
** helm-ag failed
   need to install =silver-seracher= in your os,(as for me it's ubuntu 16.10)
   https://github.com/ggreer/the_silver_searcher
** Fail to run sh in org src block
   [[https://lists.gnu.org/archive/html/emacs-orgmode/2016-04/msg00298.html][fail to run sh command in src block]]
   in =~/.spacemacs.d/layer/zilongshanren-org/packages.el=
   #+BEGIN_SRC emacs-lisp
      ;; https://lists.gnu.org/archive/html/emacs-orgmode/2016-04/msg00298.html
      ;; DONE solve shell <- sh
      (org-babel-do-load-languages
       'org-babel-load-languages
       '((perl . t)
         (ruby . t)
         ;; yiddi:comment
         ;; (sh . t)
         ;; yiddi:add
         (shell . t)
         (dot . t)
         (js . t)
         (latex .t)
         (python . t)
         (emacs-lisp . t)
         (plantuml . t)
         (C . t)
         (ditaa . t)
         ;; yiddi:add
         (calc . t)))
   #+END_SRC
** zshell not runnint in dired-mode
   when type =`= in dired mode , it will invoke zsh in another buffer, but
   *you must install zsh in your OS*
   =apt install zsh=
** elfeed : emacs without libxml2
   when i install emacs from source code ,the procedure is fluent.
   but , i ignore the =config.log= after run =./configure=
   there is a log in it: *libxml2 can not locate by emacs.*

   must install *libxml2-dev* in ubuntu

   then re-config, and re-build emacs
**  fix a requirements of helm-ag                       :ErrorFix:
   need a requirement: silver-searcher
   [[https://github.com/ggreer/the_silver_searcher][silver-searcher]]
* by now, The KENG in ubuntu 16.10 and Elementary OS
** emacs 25.1
** sub-wifi : Ralink 2870
** agent-pc sufer net by sharing the server-laptop's wirless netcard :Ubuntu:net:
   one pc without wireless net-card, one laptop with two net-cards: wired and
   wireless. so i want to make pc surfer net by sharing laptop's wireless
   net-card, using the NAT tech. step-by-step, as follow note:
*** Configuration
**** setting share in inner netcard
     最简单的办法解决问题（此方法简单容易，非常类似于 windows 下的“共享”，只是 windows
     下是在外网网卡上点击“共享”，而 ubuntu 是在内网网卡上选择“与其他计算机共享”）：
     打开 系统设置->网络设置->选中内网网卡(这里是 eth1)->点击“选项”->点击 ipv4 设
     置->在“方法”的下拉框中选中“与其他计算机共享”->保存，立即 OK！
**** setting NAT
     　　本文介绍如何使用 iptables 来实现 NAT 转发，事实上就是将一台机器作为网关（gateway）
     来使用。我们假设充当网关的机器至少有网卡 eth0 和 eth1，使用 eth0 表示连接到外网的网卡，
     使用 eth1 表示连接到内网交换机上的网卡，内部子网为 10.0.0.0，通过 NAT 机制，内网中的
     机器可以通过网关机器访问 Internet，而不需要额外的公网 IP。

     　　本文中的配置值需要根据具体环境适当更改。
***** Gateway 端

      　　1. 给内网网卡配置静态 IP（此前确保另一张外网网卡 eth0 已经能够正常访问 Internet。
      已经为 eth1 配置过内网静态 IP 的可以跳过本步）
      sudo ip addr add 10.0.0.11/24 dev eth1
      　　这里假设 eth1 的 IP 为 10.0.0.11,。
      　　2. 配置 NAT 规则
      sudo iptables -A FORWARD -o eth0 -i eth1 -s 10.0.0.0/24 -m conntrack --ctstate NEW -j ACCEPT
      sudo iptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
      sudo iptables -t nat -F POSTROUTING
      sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
      　　第一条规则允许转发初始网络包，第二条规则允许转发已经建立连接后的网络包，第三
      条则设置 NAT。
      　　接下来需要保存 iptables 规则，确保每次重启时能够加载 NAT 规则：

      　　2.1 保存 iptables 规则
      sudo iptables-save | sudo tee /etc/iptables.sav
      　　2.2 编辑/etc/rc.local 文件，将下面的一行添加到“exit 0”之前：
      iptables-restore < /etc/iptables.sav
      　　这样以后每次重启机器时都会自动加载 NAT 相关的 iptables 规则。　　

      　　3 启用路由转发，编辑/etc/sysctl.conf 文件，删除起始的“#”，解除
      #net.ipv4.ip_forward=1
      　　的注释。然后使其生效：
      sudo sysctl -p
      　　这样我们就完成了网关一端的设置。

***** Client 端

      　　一旦网关机器设置完成，任何 OS 的客户端都能够通过连接到网关而访问外部网络。这里以 Ubuntu Server 作为 client 为例，假设 client 的 eth0 连接到网关 eth1 所在的内网 10.0.0.0 上，
      　　1. 为 eth0 指派静态 IP（需与 server 端的 eth1 在同一网段，如果已经配置过则可以跳过本步），编辑/etc/network/interfaces 文件：
      auto eth0
      iface eth0 inet static
      address 10.0.0.31
      netmask 255.255.255.0
      gateway 10.0.0.11
      dns-nameservers YourDNSServer
      　　因为我们的网关服务端并没有充当 DNS 服务器，此处需要额外指定 client 的 DNS 服务器，
      通常从网络服务提供商（ISP）那里获得。
      　　2. 接下来配置路由网关
      sudo route add default gw 10.0.0.11 dev eth0
      　　使网关配置生效，如果以前已经生成过/etc/resolv.conf 文件中的 nameserver 字段，那么这时 client 应该已经能够访问外部网络了，否则需要编辑/etc/resolv.conf，添加字段：
      nameserver YourDNSServer
      　　由于在/etc/network/interfaces 文件中已经配置过 dns-nameservers，所以重新启动 client 机器时不会影响 DNS 配置。
      　　此时 client 已经能够通过网关机器访问外网，如果不知道 ISP 的 DNS 服务器地址，可以使用 OpenDNS 作为替代。
****  高级 Gateway 配置

     　　可以为 gateway 机器配置 DHCP 和 DNS 服务器功能，从而简化客户端机器的联网配置，同时
     省却为 client 配置 DNS 的过程；

     　　1. 安装 dnsmasq
     sudo aptitude install dnsmasq
     　　2. 备份 dnsmasq 的配置文件以备参考
     sudo cp /etc/dnsmasq.conf /etc/dnsmasq.conf-backup
     　　3. 编辑 dnsmasq 的配置文件/etc/dnsmasq.conf，添加下面两行：
     interface=eth1
     dhcp-range=10.0.0.100,10.0.0.250,72h
     　　注意这是为 gateway 机器配置 DHCP/DNS，interface 字段需要设为该机器连接到内网的那个网卡，同时 DHCP 的 IP 池应该在我们之前配置的那个网段中。
     　　4. 重启 dnsmasq 服务
     sudo /etc/init.d/dnsmasq restart
     　　这样 client 端就能够获取动态 IP 和自动解析域名了。
     #+BEGIN_SRC shell
sudo iptables -AFORWARD -o wlp8s0 -i enp7s0 -s 10.42.0.1/24 -m conntrack --ctstate NEW -j ACCEPT
sudo iptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
sudo iptables -t nat -F POSTROUTING
sudo iptables -t nat -A POSTROUTING -o wlp8s0 -j MASQUERADE
     #+END_SRC
*** URLS
    http://qujunorz.blog.51cto.com/6378776/1868602
    https://bbs.archlinux.org/viewtopic.php?id=147790
    https://www.linuxbabe.com/linux-server/how-to-enable-etcrc-local-with-systemd
*** about systemd
    换了一台新笔记本，于是装上了最新的 Ubuntu 1610,结果从旧机器导文件过来的时候发
    现系统里没有 rc.local，一下感觉醉醉的。google 查了下，原来是 1610 把 rc.local 服务
    化了，看来 systemd 已经决心独立了。。话说这个 sysvinit 流传的下来的东东生命力确实顽
    强，而且真的很好用啊。解决方法： 首先创建 systemd 的服务脚本
*** How to write systemd script
    1. create systemd-script in =/etc/systemd/system/=
    2. vim this script, add some items like below
       #+BEGIN_SRC systemd-script
       [Unit]
       Description=/etc/rc.local Compatibility
       ConditionPathExists=/etc/rc.local
       [Service]
       Type=forking
       ExecStart=/etc/rc.local start
       TimeoutSec=0
       StandardOutput=tty
       RemainAfterExit=yes
       SysVStartPriority=99
       [Install]
       WantedBy=multi-user.target
       #+END_SRC
    3. create the sh-commands-file in a file which sytemd-script point

*** when enable rc-local.service in /etc/systemd/system/, failed
    If you are running a Linux distro that use Systemd, then you may find that your
    command in /etc/rc.local file would not run on system boot. This guide explains
    how to enable /etc/rc.local script to run on system start.

    The problem

    If you type the following command in terminal:

    sudo systemctl status rc-local
    You may get this output:

    ● rc-local.service - /etc/rc.local Compatibility
    Loaded: loaded (/lib/systemd/system/rc-local.service; static; vendor preset: enabled)
    Active: failed (Result: exit-code) since Thu 2015-11-26 23:54:58 CST; 59s ago
    Process: 1001 ExecStart=/etc/rc.local start (code=exited, status=1/FAILURE)
    Nov 26 23:54:57 vivid rc.local[1001]: File "/usr/lib/python2.7/dist-packages/pkg_resources/__init__.py", line 920, in require
    Nov 26 23:54:57 vivid rc.local[1001]: needed = self.resolve(parse_requirements(requirements))
    Nov 26 23:54:57 vivid rc.local[1001]: File "/usr/lib/python2.7/dist-packages/pkg_resources/__init__.py", line 807, in resolve
    Nov 26 23:54:57 vivid rc.local[1001]: raise DistributionNotFound(req)
    Nov 26 23:54:57 vivid rc.local[1001]: pkg_resources.DistributionNotFound: shadowsocks==2.8.2
    Nov 26 23:54:58 vivid sudo[1008]: pam_unix(sudo:session): session closed for user root
    Nov 26 23:54:58 vivid systemd[1]: rc-local.service: control process exited, code=exited status=1
    Nov 26 23:54:58 vivid systemd[1]: Failed to start /etc/rc.local Compatibility.
    Nov 26 23:54:58 vivid systemd[1]: Unit rc-local.service entered failed state.
    Nov 26 23:54:58 vivid systemd[1]: rc-local.service failed.
    And if you try to enable /etc/rc.local to run on system boot with the command:

    sudo systemctl enable rc-local
    You may get:

    The unit files have no [Install] section. They are not meant to be enabled
    using systemctl.
    Possible reasons for having this kind of units are:
    1) A unit may be statically enabled by being symlinked from another unit's
    .wants/ or .requires/ directory.
    2) A unit's purpose may be to act as a helper for some other unit which has
    a requirement dependency on it.
    3) A unit may be started when needed via activation (socket, path, timer,
    D-Bus, udev, scripted systemctl call, ...).
    The solution

    As you can see from above, The unit file have no [Install] section. As such
    Systemd can not enable it. First we need to create a file:

    sudo vi /etc/systemd/system/rc-local.service
    Then add the following content to it.
    #+BEGIN_SRC systemd-script
[Unit]
Description=/etc/rc.local Compatibility
ConditionPathExists=/etc/rc.local
[Service]
Type=forking
ExecStart=/etc/rc.local start
TimeoutSec=0
StandardOutput=tty
RemainAfterExit=yes
SysVStartPriority=99
[Install]
WantedBy=multi-user.target
    #+END_SRC

    Save and close the file. Make sure /etc/rc.local file is executable.

    =sudo chmod +x /etc/rc.local=
    After that, enable the service on system boot:

    =sudo systemctl enable rc-local=
    Output:

    Created symlink from
    /etc/systemd/system/multi-user.target.wants/rc-local.service to
    /etc/systemd/system/rc-local.service. Now start the service and check its
    status:

    sudo systemctl start rc-local.service
    sudo systemctl status rc-local.service
    Output:

    ● rc-local.service - /etc/rc.local Compatibility
    Loaded: loaded (/etc/systemd/system/rc-local.service; enabled; vendor preset: enabled)
    Active: active (running) since Fri 2015-11-27 00:32:56 CST; 14min ago
    Process: 879 ExecStart=/etc/rc.local start (code=exited, status=0/SUCCESS)
    Main PID: 880 (watch)
    CGroup: /system.slice/rc-local.service
    Cron @reboot

    If the above method does not work for you, or you just want some simple commands
    to be executed on system boot, then you can also use the @reboot feature in cron
    to automatically execute command on system boot. For example, I want
    my shadowsocks client to auto start, so I open the root user’s cron file:

    sudo crontab -e
    And put the following line at the end of it.

    @reboot /usr/bin/sslocal -c /etc/shadowsocks.json -d start
    Save and close the file.

    In some Linux distributions such as archlinux, the cron daemon is not enabled by
    default. So you have to manually enable it. To enable it on archlinux, enter the
    following command in the terminal.

    sudo systemctl enable cronie Shadowsocks is a socks5 proxy that can be used to
    bypass Internet firewalls, If you are interested, click the link below to learn
    how to setup your own shadowsocks server.
** how to run start-up script in ubuntu                     :Ubuntu:auto:run:
*** ubuntu16.10
**** make a systemd script in /etc/systemd/sytem/xxx.service, link to /etc/rc.local
     #+BEGIN_SRC systemd-script
       [Unit]
       Description=/etc/rc.local Compatibility
       ConditionPathExists=/etc/rc.local
       [Service]
       Type=forking
       ExecStart=/etc/rc.local start
       TimeoutSec=0
       StandardOutput=tty
       RemainAfterExit=yes
       SysVStartPriority=99
       [Install]
       WantedBy=multi-user.target
     #+END_SRC
**** add some sh commands in /etc/rc.local
     1. make your sh file executable(sudo chmod 755 <file-path>)
     2. then , add some sh commands in it,like this
     #+BEGIN_SRC shell
     #!/bin/sh          (ensure first line like this)
     iptables-restore < /etc/iptables.sav
     #+END_SRC


** can not startup elementary os, after update

   :TIME:
   <2017-03-30 Thu 10:16>
   :END:
   :SYMPTOM:
   1. have an update before restart ele-os
   2. when restart ,black screen and invalid keyboard.
   3. can not enter tty, by ~ctrl alt f1/f2~
   4. can not enter GRUB, when press ~shift~
   :END:
   :SOLVE:
   1. specify why crash
      1) i make a livecd by burn elementary-os iso file in my usb-drive
      2) restart, change the start device to this usb-drive
      3) ~fdisk -l~ to see the specification of my disk, find the root drive of my ele-os
      4) ~mkdir /mnt/sdb1~ to make a file for mounting
      5) ~mount /dev/sdb1 /mnt/sdb1~ mount root drive to /mnt/sdb1
      6) ~vim /mnt/sdb1/var/log/system~ to see the log when start ele-os
      7) i find error message about "gpu-manager", says like that "can not enter /lib/modules/4.4.0-70xxxxxxxxx/updates/dkms"
      8) i guess that this update is a kernel update, from 4.4.0-66 to 4.4.0-70
      9) i guess this kernel update make my nvidia driver failed.
      10) ~ls /mnt/sdb1/boot~ find that, only 4.4.0-66 has a .img file ,4.4.0-70 dont has this file with .img
      11) i now specify the problem is *i make a new initramfs file of 4.4.0-66 include in it. but this update's crash give me no time to do same thing to 4.4.0-70.*
   2. now problem is how to enter tty.
      1) ~vim /mnt/sdb1/etc/default/grub~ to modify the =GRUB_CMDLINE_LINUX_DEFAULT= item from xxx to *nomodeset*
      2) then reboot, grub work.
      3) enter grub recover-mode, and enter *4.4.0-70*->upstart mode, and after a while of message, enter tty directly.
      4) ~lsmod | grep nouveau~ , YES! 4.4.0-70 use nouveau as its default graphical driver.
      5) ~dracut --omit-drivers nouveau~ and make a new initramfs.
      6) reboot, DONE
   :END:

* ubuntu
** how to install source-code-pro font
   Ubuntu 14.04:

   [ -d /usr/share/fonts/opentype ] || sudo mkdir /usr/share/fonts/opentype
   sudo git clone https://github.com/adobe-fonts/source-code-pro.git /usr/share/fonts/opentype/scp
   sudo fc-cache -f -v

** how to find file in ubuntu?
   [[http://www.tecmint.com/35-practical-examples-of-linux-find-command/][find command tutorial]]
   find is very helpfu in searching file in linux.
   eg. i want to use etags to =TAG= all .java file in a directory with different depth.
   =find . -type f -name "*.java"=
   + '-type' can followed
     'f' for file
     'd' for directory
   + '-name' must followed double quote wrapping the file name
     ""

** how to install nvidia-driver in linux
   Linux secure boot(安全启动)时添加 Nvidia 显卡驱动
   开启 Secure boot 情况下，在 Fedora 21 下安装 Nvidia 显卡驱动的方法。
   Nvidia 显卡驱动可以从官网上下载最新版>> 点击进入
   下载后添加可执行权限：
   #chmod +x NVIDIA-Linux*.run
   注意，安装 Nvidia 显卡需要满足的两个条件是
   1. nouveau（默认的显卡驱动）驱动程序必须禁用
   2. Xserver（图形界面） 要停止运行
   以上两个问题的解决方法如下：

   首先按 Ctrl + Alt + F2 进入终端
   输入 root 的帐号和密码后执行以下操作

   1. 禁用 nouveau 显卡驱动
   #sudo dracut --omit-drivers nouveau /boot/initramfs-$(uname -r).img $(uname -r) --force

   2. 停止 Xserver
   #service gdm stop
   #service lightgdm stop
   3. 安装编译所需的程序
   #yum install gcc kernel-devel

   然后进入放 NVIDIA-linux*.run 的目录，执行该文件，按照提示进行操作。
   由于我这台机器已经安装好了驱动程序，就不再执行了（所以截图也就没有了）。
   注意在执行过程中，会出现提示是否使用 dkms，由于在 secure boot 下使用 dkms 会导致无法开机，这里选择 NO(否)。
   经过编译后会提示是否 sign the kernel module（为内核模块签名），这里要选择是。接下来会继续问使用已有的密钥给模块签名还是重新生成。
   这里选在重新生成密钥。继续下去之后，密钥会在/usr/share/nvidia/下生成一个 nvidia*.der（私钥）文件和 nvidia*.key（公钥）文件，当提示是否删除已生成的密钥文件时，选择否，
   因为之后要用到这两个文件。继续安装程序到最后会提示无法启动模块。这是因为生成的密钥还没有添加到内核的信任库中。
   添加密钥到内核的信任列表中：

   #sudo mokutil --import /usr/share/nvidia/nvida*.der

   接下来会提示输入密码，两次输入密码后重启系统。
   #reboot

   重启进入 bootloader 之后，由于进行了添加密钥操作，会触发 shim，shim 会要求输入上一步输入的密码来导入密钥。按步骤操作。

   导入密钥之后，启动时内核就可以成功加载编译过的 Nvidia 显卡驱动了。
* git
** Git:[[http://learngitbranching.js.org/][An interesting web for git-study]]
*** git checkout 的本质就是移动 HEAD
*** git status -s
    这个命令会只获取 stage 中改变的部分
*** git commits :delta
    Git Commits

    Git 仓库中的一次提交（commit）记录目录下所有文件的快照。感觉像是大量的复制和粘贴，但 Git 做的不只这么简单！

    Git 希望提交记录尽可能地轻量，所以每次进行提交时，它不会简单地复制整个目录。条件允许的情况下，Git 会把提交压缩成从代码库的一个版本到下一个版本的变化合集，也叫“增量（delta）”。

    Git 还维护了“提交的创建时间”的历史记录，因此，大部分提交都有祖先 -- 我们会在图示中用箭头来表示这种关系。对于项目的成员来说，这份提交历史对大家都有好处。
*** git branch:  another pointer
    Git Branches

    Git 的分支非常轻量。它们只是简单地指向某个提交纪录——仅此而已.

*** commit 是前移 pointer, branch 是创建 pointer
*** git merge : 隐式的 delta+pointer
    git merge xxx (to me)

*** git rebase: 一次搬好几个
    Rebasing 就是取出一系列的提交记录，"复制"它们，然后在别的某个地方放下来。
    git rebase (me to) xxx
    更快捷的方式是:
    git rebase <to> <from>, 之后分支在 source 上.
    Git Rebase

*** 分离 HEAD
    git checkout (Head to) <commit>
    HEAD 就是指针的指针,原来指向的是 分支名指针,分离 head,就是把二级指针降级为一级指针
    一般情况: HEAD -> <分支名> -> <commit> :分离 HEAD: HEAD -> commit <- master
    HEAD 通常指向分支名（比如 bugFix）。你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。

*** git log: 查看 commit hash 值

*** 相对引用

    使用 ^ ,HEAD 向上移动 1 个位置:
    master^ 相当于 "master 的父提交"
    master^^ 是 master 的父父提交（上上代祖先）
    使用 ~<num> 向上移动多个位置:
    git checkout HEAD~4
    git branch -f master C4 (强行移动 master 分支到 C4 commit)

*** 撤销 Git 里面的变动: revert(远端) reset(本地)

    在 Git 里撤销修改的方法很多。和 commit 一样，在 Git 里撤销变动同时具有底层部分（暂存一些独立的文件或者片段）和高层部分（具体到变动是究竟怎么被撤销的）。我们这个应用主要关注后者。

    在 Git 里主要用两种方法来撤销变动 —— 一种是 git reset，另外一种是 git revert。让我们在下一个窗口逐一了解它们。
    git reset 把分支记录回退到上一个提交记录来实现撤销改动。
    git reset HEAD~1
    回退代表什么,代表原来的 delta(变化部分)没有了,所以代码库还是没改之前的.
    为了撤销更改并传播给别人，我们需要使用 git revert。举个例子
    git revert HEAD (通过提交来传播撤销)

    因为 HEAD 是二级指针,指向当前 branch, 所以只要不分离 HEAD,移动当前分支就是移动 HEAD.

*** cherry-pick: 转移工作区: 拉新排序
    本系列的第一个命令是 git cherry-pick, 命令形式为:

    git cherry-pick <Commit1,2,3...> (to my branch)
    我们会在下一个概念中涉及'转移工作区', 换句话说, 这是开发者表达 --- 我想要把这个工作放这里, 那个工作也放这里

    现在有一个仓库, 我们想将 side 分支下的工作复制到 master 分支, 我们可以通过 rebase 完成这一点(已经学过了哈), 但是这里我们想通过 cherry-pick 来完成.

*** Git Interactive Rebase: 拉新排序
    注意每次 rebase,都会从更高的父节点创建新分支,所以不用担心原节点的树结构被打破
    git rebase -i (my)<HEAD~n>(to)XXX
    如果你知道你所需要的提交对象(相应的 hash), 那用 Git cherry-pick 就非常方便了 -- 很难有简单的方式了
    但是如果你不清楚你想要的提交对象的 hash 呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互 rebase -- 如果你想衍合一系列的提交, 这就是最方便的方法了
    git rebase -i HEAD~4 //from current HEAD(default point to branch) interactively rebase 4 commits before.

*** 本地栈式提交 (Locally stacked commits)

    设想一下一个经常发生的场景：[0/0]我在追踪一个有点棘手的 bug，为了更好地排查，我添加了一些调试命令和打印语句。

    所有的这些调试和打印语句都只在它们自己的分支里。最终我终于找到这个 bug，揪出来 fix 掉，然后撒花庆祝！

    现在唯一的问题就是要把我在 bugFix 分支里的工作合并回 master 分支。我可以简单地把 master 分支快进（fast-forward），但这样的话 master 分支就会包含我这些调试语句了。

*** 为了保证 printf_to_debug 语句彻底独立,应该新建 branch

*** 提交变换戏法

    下面这种情况也是经常出现的。例如你之前已经在 newImage 分支上做了一些提交，然后又在 caption 分支上做了一些相关的提交，因此它们看起来是一个连一个的（stacked on top of each other in your repository）。

    有点棘手的就是有时候你又想往先前的提交里做些小改动。呐，现在就是设计师想要我们去轻微改变下 newImage 的内容（change the dimensions slightly），尽管那个提交是很久很久以前的了。
    为了实现他的愿望，我们可以按照下面的方法来做：[0/0]

    先用 git rebase -i 将提交重新排序，然后把我们想要修改的提交挪到最前
    然后用 commit --amend 来进行一些小修改 , git commit --amend 用来修改提交,而不在提交树上继续生成.
    接着再用 git rebase -i 来将他们按最开始的顺序重新排好
    最后我们把 master 移到修改的最前端（用你自己喜欢的方法），就大功告成啦！
    当然还有许多方法可以完成这个任务（我知道你在看 cherry-pick 啦），之后我们会多点关注这些技巧啦，但现在暂时只专注上面这种方法。

    啊最后还要提醒你一下最终的形式 —— 因为我们把这个提交移动了两次，所以会分别产生一个省略提交（both get an apostrophe appended）。还有一个省略提交是因为我们为了实现最终效果去修改提交而添加的。

*** 提交变换戏法 #2

    如你在上一关所见，我们使用 rebase -i 来重排那些提交。只要把我们想要的提交挪到最顶端，我们就可以很容易地改变它，然后把它们重新排成我们想要的顺序。

    但唯一的问题就是这样做就要排很多次，有可能造成衍合冲突（rebase conflicts）。下面就看看用另外一种方法 git cherry-pick 是怎么做的吧。

*** git tag : 永远固定的标签
    git tag <tag-name> <commit>

    就像你之前学到的一样，branch 很容易被移动，而且当有新的 commit 时，又会再移动，branch 经常指向不同的 commit，branch 很容易改变。

    你可能会有疑问，有没有什么方法可以永远有一个指向 commit 的记号，例如，表示重大的软体释出，或者是修正很大的 bug，有没有其它比 branch 更好的方法，可以永远地指向这些 commit？

    你说对了！git tag 可以解决这个问题，它们可以永远地指向某个特定的 commit，就像是表示一个"里程碑"一样。

    更重要的是，当有新的 commit 时，它们也不会移动，你不可以 "checkout" 到 tag 上面 commit，tag 的存在就像是一个在 commit tree 上的表示特定讯息的一个锚。

    让我们来实际看一下 tag 长什么样子...

*** git describe

    因为 tag 在 commit tree 上表示的是一个锚点，Git 有一个指令可以用来显示离你最近的锚点（也就是 tag），而且这个指令叫做 git describe！

    当你已经完成了一个 git bisect（一个找寻有 bug 的 commit 的指令），或者是当你使用的是你跑去度假的同事的电脑时，git describe 可以帮助你了解你离最近的 tag 差了多少个 commit。
    git describe 的​​使用方式：[0/0]

    git describe <ref>

    <ref> 是任何一个可以被 Git 解读成 commit 的位置，如果你没有指定的话，Git 会以你目前所在的位置为准（HEAD）。

    指令的输出就像这样：[0/0]

    <tag>_<numCommits>_g<hash>

    <tag> 表示的是离 <ref> 最近的 tag，numCommits 是表示这个 tag 离 <ref> 有多少个 commit， <hash> 表示的是你所给定的 <ref> 所表示的 commit 的前七个 id。

*** 多分支 rebase

    呐，现在我们有很多分支啦！让我们 rebase 这些分支的工作到 master 分支上吧。

    但是你的头头找了点麻烦 —— 他们希望得到有序的提交历史，也就是我们最终的结果是 C7' 在最底部，C6' 在它上面，以此类推。

    假如你搞砸了，没所谓的（虽然我不会告诉你用 reset 可以重新开始）。记得看看我们提供的答案，看你能否使用更少的命令完成任务！

*** 选择父提交
    ~n 垂直;
    ^n 水平;
    git checkout HEAD~^2~2

    和 ~ 修改符一样，^ 修改符之后也可以跟一个（可选的）数字。

    这不是用来指定向上返回几代（~ 的作用），^ 后的数字指定跟随合并提交记录的哪一个父提交。还记得一个合并提交有多个父提交吧，所有选择哪条路径不是那么清晰。

    Git 默认选择跟随合并提交的"第一个"父提交，使用 ^ 后跟一个数字来改变这一默认行为。

    废话不多说，举个例子。

*** Branch Spaghetti

    哇塞大神！这关我们要来点不同的！

    现在我们的 master 分支是比 one two 和 three 要多几个提交。出于某种原因，我们需要把其他三个分支更新到 master 分支上新近的几个不同提交上。（update these three other brances with modified versions of the last few commits on master）

    分支 one 需要重新排序和撤销，two 需要完全重排，而 three 只需要提交一次。

    慢慢摸索会找到答案的 —— 你完事记得用 show solution 看看我们的答案哦。

*** Git 远端分支

    现在你看过 git clone 的执行了, 让我们深入下去看看发生了什么?

    第一件事, 你应该注意到在我们的本地仓库出现了一个新的分支 o/master , 这种类型的分支叫 remote branch (就叫远端分支好了), 远端分支拥有一些用于特别目的的特殊属性.

    远程分支反映了远端仓库的状态(你上次和远端仓库通信的时刻). 这会帮助你理解本地工作与公共工作的不同 -- 这是你与别人分享工作前很重要的一步.

    检出远端分支时, 有一个特别的属性 -- 你会被置于一个分离式的 HEAD. 因为你不能在这些分支上直接操作, 你必须在别的地方完成你的工作, 再与远端分享你的工作.

**** 什么是 o/？

     你可能想知道这些远端分支的头 o/ 意味着什么. 好吧, 远端分支有一个全名规范 -- 它们以这样的格式显示:

     <remote name>/<branch name>
     提示, 如果你看到一个分支命名为 o/master, 那分支名就是 master, 远端的名就是 o.

     大多数的开发者会将它们的远端命名为 origin, 而非 o. 这是如此的普遍, 以致于当你用 git clone 时,得到的仓库名就是 origin

     不幸的是, 我们的 UI 不适用 origin, 我们使用缩写 o, :) 记住, 当你使用真正的 Git 时, 你的远程仓库很可能被命名为 origin!


**** 如果检出 remote(o/master) 分支, 会发生什么呢?
     如果检出本地的 master,就是把 HEAD 指向 master 分支.
     如果检出远端的 master,HEAD 就不会指向 o/master,而是指向 o/master 所指的 commit
     git checkout o/master; git commit

     正如你所见, Git 处于了分离 HEAD, 当添加新的提交时, o/master 不被更新, 这是因为 o/master 仅伴随远端更新而更新.

*** Git Fetch: 拉新,更新,不管本地

    git remote 可以归结为向其它仓库推送/拉取数据. 只要我们能回溯或前推提交, 我们就可以分享任何类型的被 Git 跟踪的更新(工作, 新想法, 情书等等)

    本节课我们将学习 如何从远端仓库获取数据 -- 这个命令叫 git fetch

    你会注意到当我们更新远端的仓库时, 我们的远端分支也会更新 并映射到最新的远端仓库.
    What fetch does

****    git fetch 完成了两步:

     下载本地仓库未包含的提交对象
     更新我们的远端分支点(如, o/master)
     git fetch 实际上将本地对远端的映射 做了同步更新

     如果你还记得之前的课程, 我们说过远端分支映射了远端仓库的状态(你最后与远端通信的那一刻), git fetch 是你与远端交流的方式!

     git fetch 通常通过互联网(像 http:// or git://) 与远端仓库通信.

**** fetch 不能做的事

     git fetch, 不能改变你的本地状态. 你不会更新你的 master 或者 任何与文件系统相关的东西.

     所以, 你可以将 git fetch 的执行 视为下载

*** Git Pull :拉远合近 = fetch and merge

    git fetch 是不管你当前在哪个分支的(HEAD 指向),它就只看 o/master 在哪,然后拉一个新分支出来
    但是 git pull/push 都是要看 HEAD 指向的. 换言之,
    git pull --rebase  = 从远端 master fetch and rebase me to o/master

    现在我们已经知道了如何用 git fetch 获取远端的变化, 现在我们学习如果将这些变化更新到我们的工作.

    其实有很多方法的 -- 只要我在本地有新的提交, 你可以像合并其它分支那样合并远端分支. 具体说就是你可以执行以下命令:

    git cherry-pick o/master
    git rebase o/master
    git merge o/master
    etc, etc
    实际上, fetch / merge 变更是这样的普通, 以至于 git 提供了一个实现你两个功能的命令 -- git pull.

*** Simulating collaboration
    git fakeTeamwork
    So here is the tricky thing -- for some of these upcoming lessons, we need to teach you how to pull down changes that were introduced in the remote.

    That means we need to essentially "pretend" that the remote was updated by one of your coworkers / friends / collaborators, sometimes on a specific branch or a certain number of commits.

    In order to do this, we introduced the aptly-named command git fakeTeamwork! It's pretty self explanatory, let's see a demo...

*** Git Push

    Ok, so I've fetched changes from remote and incorporated them into my work locally. That's great and all... but how do I share my awesome work with everyone else?

    Well, the way to upload shared work is the opposite of downloading shared work. And what's the opposite of git pull? git push!

    git push is responsible for uploading your changes to a specified remote and updating that remote to incorporate your new commits. Once git push completes, all your friends can then download your work from the remote.

    You can think of git push as a command to "publish" your work. It has a bunch of subtleties that we will get into shortly, but let's start with baby steps...

    note -- the behavior of git push with no arguments varies depending on one of git's settings called push.default. The default value for this setting depends on the version of git you're using, but we are going to use the upstream value in our lessons. This isn't a huge deal, but it's worth checking your settings before pushing in your own projects.

*** Diverged Work

    So far we've seen how to pull down commits from others and how to push up our own changes. It seems pretty simple, so how can people get so confused?

    The difficulty comes in when the history of the repository diverges. Before discussing the details of this, let's see an example...

**** How do you resolve this situation?

     It's easy, all you need to do is base your work off of the most recent version of the remote branch.

     There are a few ways to do this, but the most straightforward is to *move your work via rebasing*.

     Let's go ahead and see what that looks like.

***** git fetch; git rebase o/master; git push

      Boom! We updated our local representation of the remote with git fetch, rebased our work to reflect the new changes in the remote, and then pushed them with git push
***** git fetch; git merge o/master; git pushBoom!
      We updated our local representation of the remote with git fetch, merged the new work into our work (to reflect the new changes in the remote), and then pushed them with git push
***** git pull --rebase
      is shorthand for a fetch and a rebase!
*** Merging feature branches

    Now that you're comfortable with fetching, pulling, and pushing, lets put these skills to the test with a new workflow.

    It's common for developers on big projects to do all their work on *feature branches* (off of master) and then integrate that work only once it's ready. This is similar to the previous lesson (where side branches get pushed to the remote), but here we introduce one more step.

    Some developers only push and pull when on the master branch -- that way master always stays updated to what is on the remote (o/master).

    So for this workflow we combine two things:

    integrating feature branch work onto master, and
    pushing and pulling from the remote

    1. 先 fetch 一个新的远端分支出来
    2. 而后将本地 feature 分支逐一,rebase 上去(rebase <from> <to>)
*** Why not merge?


    In order to push new updates to the remote, all you need to do is incorporate the latest changes from the remote. That means you can either rebase or merge in the remote branch (e.g. o/master).
    So if you can do either method, why have the lessons focused on rebasing so far? Why is there no love for merge when working with remotes?

    There's a lot of debate about the tradeoffs between merging and rebasing in the development community. Here are the general pros / cons of rebasing:

    Pros:

    Rebasing makes your commit tree look very clean since everything is in a straight line
    Cons:

    Rebasing modifies the (apparent) history of the commit tree.
    For example, commit C1 can be rebased past C3. It then appears that the work for C1' came after C3 when in reality it was completed beforehand.

    Some developers love to preserve history and thus prefer merging. Others (like myself) prefer having a clean commit tree and prefer rebasing. It all comes down to preferences :D
*** Remote-Tracking branches

    One thing that might have seemed "magical" about the last few lessons is that git knew the master branch was related to o/master. Sure these branches have similar names and it might make logical sense to connect the master branch on the remote to the local master branch, but this connection is demonstrated clearly in two scenarios:

    During a pull operation, commits are downloaded onto o/master and then merged into the master branch. The implied target of the merge is determined from this connection.
    During a push operation, work from the master branch was pushed onto the remote's master branch (which was then represented by o/master locally). The destination of the push is determined from the connection between master and o/master.
    Remote tracking

    Long story short, *this connection between master and o/master is explained simply by the "remote tracking"* property of branches. The master branch is set to track o/master -- this means there is an implied merge target and implied push destination for the master branch.

    You may be wondering how this property got set on the master branch when you didn't run any commands to specify it. Well, when you clone a repository with git, this property is actually set for you automatically.

    During a clone, git creates a remote branch for every branch on the remote (aka branches like o/master). It then creates a local branch that tracks the currently active branch on the remote, which is master in most cases.

    Once git clone is complete, you only have one local branch (so you aren't overwhelmed) but you can see all the different branches on the remote (if you happen to be very curious). It's the best of both worlds!

    This also explains why you may see the following command output when cloning:

    local branch "master" set to track remote branch "o/master"
**** Can I specify this myself?

     Yes you can! You can make any arbitrary branch track o/master, and if you do so, that branch will have the same implied push destination and merge target as master. This means you can run git push on a branch named totallyNotMaster and have your work pushed to the master branch on the remote!

     There are two ways to set this property. The first is to checkout a new branch by using a remote branch as the specified ref. Running
***** way#1
      *git checkout -b totallyNotMaster o/master*

      Creates a new branch named totallyNotMaster and sets it to track o/master.
***** Way #2

      Another way to set remote tracking on a branch is to simply use the git branch -u option. Running

      *git branch -u o/master foo*

      will set the foo branch to track o/master. If foo is currently checked out you can even leave it off:

      *git branch -u o/master*
*** 从本地分支 push,在远端会新建一个这样的分支
**** 有个本地分支,一直在开发,然后想 push 到远程上也作为分支,怎么做?
     直接在本地建好分支一直开发,不用 track,然后直接 push
*** Push arguments

    Great! Now that you know about remote tracking branches we can start to uncover some of the mystery behind how git push, fetch, and pull work. We're going to tackle one command at a time but the concepts between them are very similar.

    First we'll look at git push. You learned in the remote tracking lesson that git figured out the remote and the branch to push to by looking at the properties of the currently checked out branch (the remote that it "tracks"). This is the behavior with no arguments specified, but git push can optionally take arguments in the form of:

    *git push <repo> <branch:from>*
    这个命令的好处是,直接推送到远端 repo 中的相关联分支中,如果远端没有这个分支,那么会在远端建立并直接关联.
**** what is a <place> parameter you say?
     好用就好用在,即便现在是另一个分支上,也可以通过指明从谁那 push 来做到推送内容,而不用一直切来切去,跟 rebase <to><from> 一样
     We'll dive into the specifics soon, but first an example. Issuing the command:

     *git push origin master*

     translates to this in English:

     Go to the branch named "master" in my repository, grab all the commits, and then go to the branch "master" on the remote named "origin." Place whatever commits are missing on that branch and then tell me when you're done.

     By specifying master as the "place" argument, we told git where the commits will come from and where the commits will go. It's essentially the "place" or "location" to synchronize between the two repositories.

     Keep in mind that since we told git everything it needs to know (by specifying both arguments), it totally ignores where we are checked out!
*** <place> argument details

    上一节是说,要推送的关联(remote track)的分支上.
    而这一节更加灵活可以指定位置推送,不仅仅可以指定远端分支位置,还可以指定本地分支位置.通过相对定位符来指定位置.

    也就是说,push origin 语句,如果不加参数默认是找关联(git push origin master),如果加参数那就直接找参数(git push origin master:foo)

    还记得之前课程说的吧, 当为 git push 指定 master 为 place 时, 我们可以设置 要提交的来源 和 提交到目的地.

    你可能想知道 -- 如果来源和目的地不一样呢?

    好吧, 很不幸 Git 不可能做到... 只是个玩笑! 当然是可能的啦 :) ... Git 拥有超强的灵活性(几乎不能再多了)

    我们看看下一个幻灯片...要为 <place> 指定 source 和 destination, 只需要用冒号 : 将二者联结.

    git push origin <source>:<destination>

    这通常被称为 <colon refspec>, refspec 是一个奇特的名 -- 用于 Git 能识别的位置(比如分支 foo 或者 HEAD~1)

    一旦你指定了独立的来源和目的地, 你就可以得到花哨而精确的远程命令, 让我们看看演示!
    记住, source 是 Git 能理解的任何位置:

    git push origin foo^:master

    这是个很迷幻的命令, 但它是合理的 -- Git 将 foo^ 解析为一个位置, 上传新提交到远端的目的地.
*** Git fetch arguments : 跟 push 参数命令方向相反

    我们刚学习了 git push 的参数, 特别是 <place> 参数, 更特别的冒号分隔(<source>:<destination>). 这些参数可以用于 git fetch 吗?

    你猜中了! git fetch 的参数和 git push 相当相似. 都是相同的概念, 但是方向相反(因为现在你是下载 而非上传)

    让我们逐个讨论下这些概念..
    <place> 参数

    你可以像如下命令这样为 git fetch 设置 <place>

    git fetch origin foo

    Git 会来到远端的 foo 分支, 然后抓取所有不在本地的新提交, 放到本地的分支 o/foo

    我们看看这个动作(这像是更新器)
    git fetch origin foo~1:bar

    哇! 看见了吧, Git 将 foo~1 解析成一个 origin 的位置, 然后下载到了本地 bar. 注意 foo 和 o/foo 都没有得到更新 (因为我们指定了 destination).
    没有参数呢?

    如果 git fetch 没有参数, 它会下载所有远端分支..

    git fetch

    相当简单, 但是仅需更新一次，很值!
*** 奇葩的 <source>

    有两种罕见的情况, Git 不需要 <source>. 这基于这样一个事实 -- 技术上说就是你不指定 <source>. 这是通过空参数实现的

    git push origin :side
    git fetch origin :bugFix
    我们看看这是怎么进行的..
    如果给 push 传一个空参数会如何呢? 远端会删除分支!

    git push origin :foo
    就是这样子, 我们通过给 push 传空值 source, 成功删除了远端的 foo 分支, 这真有意思..

    如果给 fetch 传空 <source>, 那本地会创建一个新分支.

    git fetch origin :bar

*** Git pull 参数

    现在你知道关于 fetch/push 几乎所有的东西了, 不过 pull 也有一个 "nothing" 呢! :)

    因为 git pull 就是 fetch 后跟 merge 的缩写. 我可以认为执行 git fetch 用了相同的参数, 然后再 merge 你所 fetch 的提交 (commit)

    这可以和其它更复杂的参数一起使用, 看看例子
    以下命令在 Git 中是等价的:

    git pull origin foo 相当于：[0/0]

    git fetch origin foo; git merge o/foo

    还有...

    git pull origin bar~1:bugFix 相当于：[0/0]

    git fetch origin bar~1:bugFix; git merge bugFix

    看到了? git pull 实际上就是 fetch + merge 的缩写, git pull 在乎的是提交在哪里结束(也就是 git fetch 所确定的 destination)

    一起来看个例子吧：[0/0]
    git pull origin master

    看! 通过指定 master 我们更新了 o/master. 然后我们 merge o/master 到我们的检出分支(当前检出的任意分支).
    :: 这里要注意,是当前分支,就是你执行命令的分支,所以这个命令执行要小心当前分支
    git pull origin master:foo

    哇, 这就一个命令. 我们在本地创建了一个叫 foo 的分支, 远端的 master 分支, 被下载到了本地 foo 分支. 然后再 merge 到我们的当前分支. 终于完啦! 9000!!!
*** oh-my-zsh 配置别名
    cat ~/.oh-my-zsh/plugins/git/git.plugin.zsh
    发现是一堆 alias

    alias g='git'

    alias ga='git add'
    alias gaa='git add --all'
    alias gapa='git add --patch'

    alias gb='git branch'
    alias gba='git branch -a'
    alias gbda='git branch --merged | command grep -vE "^(\*|\s*master\s*$)" | command xargs -n 1 git branch -d'
    alias gbl='git blame -b -w'
    alias gbnm='git branch --no-merged'
    alias gbr='git branch --remote'
    alias gbs='git bisect'
    alias gbsb='git bisect bad'
    alias gbsg='git bisect good'
    alias gbsr='git bisect reset'
    alias gbss='git bisect start'
** Git 学习
   1. 默认从远程仓库 clone 下来的 repo,具有默认的仓库代号 origin,这个名字就代表其作者所创建的 repo
   2. 当你从 spasemacs 官方 git clone 下来一个版本后,你加入了自己的修改,想保存在自己的 git 上
      你就可以,添加一个仓库(repo) git remote add, 顺便添加自己给取的一个代号(eg. yid).
   3. git remote -v 看到的就是: repo 在你本地的代号 和 具体的 git repo 网址
** Git 学习
   1. 我在使用 spacemacs 的官方版本,但是出现问题了.这个问题被提出在 issue 中,并且被另一个人修复且提 request 了.
   2. 这时,我还想使用 spacemacs 的这功能,怎么办?
   3. 直接 fetch 这个问题解决人的 repo 的这个分支(分支名称可以在 pull request 页面查询到)
   4. teminal 会这么显示: : *branch spacemacs-sover -> FETCH_HEAD : 其中 fetch_head 是 git 自动给的名字
   5. 这个时候 checkout 出来一个分支,用来保护 master 分支代码 : git checkout -branch <取个分支名:eg fixUpStream> FETCH_HEAD

* magit
  Normally, =M-x: magit-init= to init git control in current directory
  then,     =spc g s=         to enter the git-view of stage state.
  then,     =h=               to see *any hotkey* you want
** magit init, commit and commit messages
   1. =spc g i= magit init
   2. =spc g s= magit-status
   3. =s-1=     goto unstaged section
   4. =tab=     to view diffs(code review)
   5. =s=       stage all changes
   6. =c= *2    commit
** commits in action
   1. =c a= ammend, stage all modification to one commit
   2. write good commit messages
      1) 1st line, commit summary
      2) ----blank line----
      3) the modification in detail
         1. ----
         2. ----
         3. ----
   3. =l l= to see the commit log
   4. =M a= to add remote git server
   5. =p=   to push
   6. squash unpushed commits
      when you want to combine two or more commits to one commit
      you can *squash unpushed commits*
      1. Actually, its a kind of rebase, use command: =rebase -i=
   7. reset commits
      =O=
      - reset hard,   local-repo/stage/file  undo the modification, means nothing happen
      - reset mixed,  local-repo/stage       undo the modification, means modification unstage now
      - reset soft,   local-repo             undo the modification, means modification uncommit now
      - reset index,  stage                  undo the modification, means can use =x= to clear stage
   8. how to discard the stage area(clear stage,and undo the modification in file)
      =x= discard the stage area
   9. *selecct a few line to commits*
   10. discard changes, file wide or line wide
       =v/V/<table>/s= when in magit-view, =<table>= to open the detail of modification,
       =v/V= to switch evil-state to VISUAL-MODE, and select the content,and press =s=.
       then you can store selected content in stage-area
   11. revert commits
       =_= =O= revert a commit, will make a new commit automatically (which means revert will keep the older commit)

** branching basics
   1. b B to create branch
   2. m m to merge
   3. b b to switch branch
** rebase
** pull push and send pull request
   1. p p to push to remote(eg. github)
** Misc
* spacemacs
** definition
*** hooks
    hook is a *collection of funcions* will execute after certain mode start.
    #+BEGIN_SRC lisp
    (add-hook 'org-mode-hook '())
    #+END_SRC
    *WARNING : I enter the edit table of org mode by press =C-c `=, but failed to enter*
    *the major-mode related to the type of source code.*
** hotkeys
*** dired
   |   | <spe:dired>open dired-mode in current file                | SPC f j   | file-jump    |
   |   | <spe:dired>open spacemacs configuration file              | SPC f e d | open init.el |
   |   | <spe:dired>enter zshell in dired-mode(need zsh installed) | `         |              |
   |   | <spe:dired> dired-mode hide tetail                        | )         |              |
   |   | <spe:dired>dired-mode omit-mode                           | (         |              |
   |   | <spe:dired> preview a file with cursor locate in          | o         |              |
   |   | <spe:dired> preview a file, cursor stay                   | C-o       |              |
   |   | <spe:dired> edit mode, modify file name directly in dired | C-x C-q   |              |

*** global
   |   | <spe>discover major-mode key bindings | Spc ?             |                                        |
   |   | <spe>save and apply new configuration | SPC f e r         | file-refresh                           |
   |   | <spe>search in document               | SPC s j           | search jump                            |
   |   | <spe>open/closed debug info buffer    | spc t D           |                                        |
   |   | <spe>list all the layers installed    | SPC h SPC         | pkgs of this layer                     |
   |   | <spe>reload a mode by diminish-undo   | (M-x:)dimish-undo |                                        |
   |   | <spe>kill-ring paste                  | C-n/p             | copy next/previous                     |
   |   | <spe>switch input-method              | C-\               |                                        |
   |   | <spe>toggle rainbow-mode              | spc t C c         | display color instead of color unicode |
   |   |                                       |                   |                                        |
*** helm
   |   | <helm> helm-find-files                                           | spc-f-f                 |                    |
   |   | <helm> helm-ag search all func-name variable in proj             | spc-s-p                 |                    |
*** evil & vim
   |   | <evil>move backward/forward a word                               | " " e/b             |   |
   |   | <evil>move backward/forward a word with dash                     | " " E/B             |   |
   |   | <evil>move line up/down                                          | (vim-c):m +/- num   |   |
   |   | <evil>paste after/before selected char                           | (vim-n) p/P         |   |
   |   | <evil>narrow a function                                          | (vim-n)z-a          |   |
   |   | <evil>narrow all functions                                       | (vim-n)z-m          |   |
   |   | <evil>modify a char                                              | (vim-n)r            |   |
   |   | <evil>mark the current line as <num>th mark                      | (vim-n)m <num>      |   |
   |   | <evil>goto <num>th mark                                          | (vim-n)` <num>      |   |
   |   | <evil>evil-find-char: find next occurance of typed char          | (vim-n) f           |   |
   |   | <evil>goto the location last modified                            | (vim-n)g;           |   |
   |   | <evil:format> let rest chars of a line to next line              | C j                 |   |
   |   | <evil:format>let rest chars of next line to current line         | shift j             |   |
   |   | <evil:format>scroll window to make current line middle of window | z z                 |   |
   |   | <evil:elisp> find the doc of current function                    | K                   |   |
   |   | <vim>delete all the blank line                                   | :g/^$/d             |   |
   |   | <vim>delete all the line with only blank space in it             | :g/^\s*$/d          |   |
   |   | <vim>wrap a selected(by ~v~) word by a character                 | <selected> s <char> |   |
*** org
   |   | <spe:org>capture org tempalte                                  | spc C c                 |   |
   |   | <spe:org>some org-mode handler                                 | ,                       |   |
   |   | <spe:org>org-mode clock in                                     | , I                     |   |
   |   | <spe:org>org-mode clock out                                    | , O                     |   |
   |   | <spe:org>org-mode switch index  1) + - 1.                      | -                       |   |
   |   | <spe:org>org-mode add TODO tag                                 | t                       |   |
   |   | <spe:org> quick insert todo items                              | F9                      |   |
   |   | <spe:org>indent ONE line text to proper number of lines        | M-q                     |   |
   |   | <spe:org>narrow a branch of org file                           | , n                     |   |
   |   | <spe:org>widden a branch of org file                           | , N                     |   |
   |   | <spe:org>move org branch up/down                               | M-j/k                   |   |
   |   | <em:org>toggle org todo dependency                             | C-c C-x o               |   |
   |   | <em:org> jump to clocked task (can jump out from current file) | C-C C-x C-j             |   |
   |   | <em:org>org column view                                        | C-c C-x C-c             |   |
   |   | <em:org>org attachment                                         | C-c C-a                 |   |
   |   | <em:org>org clock reporting(position on headline)              | C-c C-x C-r             |   |
   |   | <em:org>Org make id                                            | (M-x:)org-id-get-create |   |
   |   | <em:org>Org attanch file                                       | C-c C-a                 |   |
   |   | <em:org>org change state of a task                             | C-c C-t                 |   |
   |   | <em:org>org take note in LOGBOOK                               | C-c C-z                 |   |
   |   | <em:org>toggle a org entry and set archive tag                 | C-c C-x a               |   |
   |   | <em:org>archive this branch file to achive org file            | C-c C-x C-a             |   |
   |   | <spe:org> add a footnote ref                                   | , i f                   |   |
   |   | <org> display latex formula directly in org file               | C-c C-x C-l             |   |
   |   | <org> screenshot by org-download                               | C-c g                   |   |
*** avy
   |   | <spe:avy:format>avy-goto-char, a very handy way to locate cursor | spc j j                 |                    |
   |   | <spe:avy:format>avy-goto-line,                                   | spc j l                 |                    |
*** misc
   |   | <spe:misc> YouDao dict                                           | Spc o y                 |                    |
   |---+------------------------------------------------------------------+-------------------------+--------------------|
*** file
   | =spc f f=     | find file from current directory(C-h to gu up-level of directory)        |
   | =spc p f=     | 在当前项目中查找文件 三种主要 pkg counsel-git / projectile/ ido-find-file |
   | =spc f L=     | counsel-locate :find file across the whole ubuntu system                |
   | =spc f l=     | find file literally (对编码格式不是本系统的有用)                         |
   | =spc f h=     | find file in hex mode                                                    |
   | =spc f o=     | 使用外部文件打开,必须先用 spacemacs 打开之后方可使用                       |
   | =spc f E=     | sudo edit                                                                |
   | =spc f D=     | delete current file and buffer                                           |
   | =spc f j=     | file jump the current file                                               |
   | =spc f r=     | recent files                                                             |
   | =spc f R=     | rename file                                                              |
   | =spc f v=     | add local variable                                                       |
   | =spc f y=     | yank current buffer's full path                                          |
   | =spc f a d=   | find the current visited directory with fasd(from chenbin)               |
   | =spc f C d/u= | conver file between unix and dos                                         |
   | =spc f e d=   | find the .spacemacs/init.el                                              |
   | =spc f e i=   | find .emacs.d/init.el                                                    |
   | =spc f e l=   | helm locate library file(all .el file)                                   |
   | =spc f c=     | copy file                                                                |
   | =spc f b=     | show bookmarsk                                                           |
   | =spc f s=     | save/create buffers                                                      |
   |               |                                                                          |
*** buffer
    1. =spc b .= buffer micro state, allways active until enter(supported by hydra)
    2. =spc b b= switch buffers
    3. =spc b d= kill buffer
    4. =spc b f= find buffer file in finder(only for MAC)
    5. =spc b B/i= I bind it to ibuffer
    6. =spc b k= kill matching buffers
    7. =spc b N= new empty buffer
    8. =spc b m= kill others
    9. =spc b h= go to home
    10. =spc b R= safe revert buffer
    11. =spc b s= switch to scratch buffer
    12. =spc b w= toggle buffer readonly
    13. =spc b Y= copy the whole buffer to clipboard
    14. =spc b p= paste to the whole buffer
    15. =spc <tab>= switch between the current buffer and the last opened buffer
*** layout
    WORKFLOW:
    1) use =spc l L= to choose a layout file from directory, in which store a num of layout, then you will load all the layout(include all the buffer) in emacs.
    2) use =spc l l= to choose a layout by name from the layous in the layout file
    3) use =spc l n/p= to switch the layout between all the layout in the layout file
    4) use =spc l r= to remove a buffer from a layout
    5) use =spc l d= to delete current layout from layout file
    6) use =spc l D= to delete a layout by name from the layout file
    7) use =spc l R= to rename a layout
    8) use =spc l s= to save all the modification of all the layouts of current layout file
    ATTENTION: your layout file will be saved in .emacs.d/.cache/layouts/
    Most important facility is: you can save and switch freely between your different layouts.
    1. =spc l L= load layout file
    2. =spc l l= to switch between layouts
    3. =spc l s= to save layout to file
    4. =spc l <tab>= switch between the last layout and the current one
    5. =spc l o= custom layout
    6. =spc l R= rename layout
    7. =spc l ?= to open the help window, learn more operations about layout
*** window
    1. =spc w -= split window below
    2. =spc w /= split window right
    3. =spc w .= window micro state
    4. =spc w 2/3 = use predefined window layout
    5. =spc w == balance window
    6. =spc w b= switch to minibuffer
    7. =spc w d= delete current buffer
    8. =spc w m= maximize window
    9. =spc w u/U= window undo/redo
    10. =spc w h/j/k/l= move to window
    11. =spc w H/J/K/L= move window to position left/down/up/right
    12. =spc w F= make a new frame
    13. =spc w o= switch to other frame
    14. =spc w 1/2/3/4= goto window with num
    15. =spc w w= goto other window one by one
    16. =spc w W= ace window
    17. =spc t g= toggle golden ratio
    18. =spc t -= make current always the center of this window
*** project
    1. =spc p f= visit files in project
    2. =spc p b= visit buffers in project
    3. =spc p p= switch to project
    4. =spc p l= switch to project and create a new layout
    5. find-file-in-project is a really handy package
*** elisp-function
    | compress current function          | z-c |
    | open function                      | z-o |
    | ONLY open current, compress others | z-s |
    |                                    |     |
*** book mark
    | set bookmark          | Spc-b-m-s |
    | display all bookmarks | Spc-b-m-j |
*** calc
    | 'ln' -- natural logarithm of num on top of stack     | shift-l         |
    | 'exp' -- exponential of num on the stack             | shift-e         |
    | 'log10' -- base-10 logarithm of num on top of stack  | shift-h shift-l |
    | 'log' -- base-<num> logarithm of num on top of stack | <num> shift-B   |
    |                                                      |                 |
** package
*** org
*** yasnippet
*** pandoc
*** TODO org-download
    URL: https://github.com/abo-abo/org-download
    setting file: [[file:~/.emacs.d/layers/+emacs/org/packages.el::(defun%20org/init-org-download%20()][org-download 在配置文件中的位置]]
    drag picture directly to your org file

*** lispy
**** Introduction to lispy
     1. lispy: vi-like paredit
     2. it even has some IDE features
        1. jump-to-def
        2. debug
     3. how to install
**** Basic usage of lispy
     1. barf and slurp
        move bracket () very smartly,
        1) by =d= switch between '(' and ')'
        2) by =[= =]= you can move '(' ')'
     2. raise sexp
        1) =r= make left-bracket of sexp you want to raise heightlight selected,press 'r',then amazing happen.
        2) =u= lisp undo
     3. kill/copy/yank
        1) =C-k= redefined in lispy-mode ,only will kill the pair-bracket content after cursor
        2) =m= to select and highlight the content in pair-bracket
        3) =C-w= to kill the selected content and the matched pair-backet, use =C-y= to yank
        4) =c= locate the right bracket, and press =c=, it will copy pair-bracket and content in it to a new line
     4. ace, like vi-extension in chrome
        1) =a= use =d= to locate the right bracket, and press =a=, and press the char he mark,you can go there directly.
        2) if only one pair of bracket, =a= means select
        3) =i= press to select content or content with brackets where amazing happens.
     5. swipe
        1) =w= =s= can switch the position between same level sexp. like (let ((sexp1)(sexp2)) when cursor
     6. navigate: h/j/k/l/ f/b :move cursor between brakets
        1) =f/b= will go further and backward to the same half of bracket,like a flow of right-half or left-half: 1st ( -f-> ( -f-> (
        2) =j/k= will go up and down between the same level brackets
        3) =h/l= will go left and right of brakctes, the largest range is -- function range
     7. doc: display the documment of this function
        1) =C-1= display doc
        2) =C-2= display base structure
     8. split
        1) =M-j= locate cursor head of sexp, can split inner-sexp from outter-sexp
        2) =s-j= can delete the brackets of inner-sexp
     9. wrap
        1) =s-(= locate cursor head of a word, can wrap the whole word by brackts,both sides
     10. format
         1. =M= format func to muli-line
         2. =O= format func to one-line
     11. sexp goto
         1. =t= triger a map, which mark many places, you can cut the sexp nearest the cursor to anywhere
     12. jump to def
         1. =F= jump to the definition
         2. =C-o= jump back
     13. [ ] jump to tag  *need study*
         1. =G= jump to the tags file
     14. debug
         1. =F= locate cursor to one bracket of the sexp(which will call a func), press =F= to jump to its definition.
         2. =xe= locate cursor to the one of bracket of the function, and press =xe=
         3. =C-o= esc to normal-state, and press =C-o= to jump back to the sexp(which will call a func).
         4. =e= press =e=, enter debug window.
         5. =n= press =n= to go next

*** restclient
    This is a tool to manually explore and test HTTP REST webservices.
    Runs queries from a plain-text query sheet, displays results as a pretty-printed XML, JSON and even images.
**** video introduction
     [[http://emacsrocks.com/e05.html][Rocks Emacs - restclient]]
*** ctags and etags
**** why use ctags auto completion?

***** how to make ctags available for some source file?
      =$ ctags -e a.js= ctags for a file of emacs
      =$ ctags -eR filename= ctags for a directory of emacs
      etags has no =-R= argument for recursive search directory.
      so we can handle it ,with 3 methods:
      [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Etags-Regexps.html#Etags-Regexps][use regex file as etags' argument]]
      [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Create-Tags-Table.html][use find command to pipline to etags]]
      1. add =--regex="<regex>"= directly after =etags= command
      2. add regex to a file, and add this file as argument of =etags= command
      3. use =find= to find the targets and pipline to =find XXX -print | etags=
***** how to know where is the tags list file the current buffer used?
      1. by =spc h d v= , find the variable description of =tags-table-list=, it will show you the path of the tags file.
      2. =spc o (= you can enter a ELisp ELPA
      3. by elisp ELPA (steq-default tags-table-list "some-path"), you can set your own ctags file temporary.
***** what's the defect of tags in emacs?
***** how set the tags file for current buffer?
      =tags-table-list= don't make a tags file respectively for different language. so you must set it by your own.
      =M-x visit-tags-table= can let you do it.
      but there is some annoying error when build TAGS in terminal
      [[http://stackoverflow.com/questions/2580313/ctags-doesnt-undestand-e-option-no-exuberant-tags-option][About error when input: ctags -e]]
      #+BEGIN_QUOTE
      etags is short for "Emacs tags", not "exuberant ctags". It sounds like you have Emacs' etags command installed, not exuberant-ctags'.
      #+END_QUOTE
      its better to try =etags file= to build TAGS file instead of =ctags -e=
***** when open a source code file ,emacs will find TAGS file automatically from current file-path to root.

**** how to configure ctags and auto completion?
     1. project wide configurations for auto generating the Tags file.
     2. Configure the ctags rules for generate more tags
     3. use etags-select to quickly navigate a large code base

        it's inconvinent for everytime you update/modify your code, you must build Tags file again.
        here is a tricks from CHEN BIN.
     5. ~/.spacemacs.d/layers/zilongshanren-programming/funcs.el
        in which defined a lot of functions to automatically rebuild TAGS files
**** how to jump-to-definition place in zilong'configurations?
     =g ]= -> etags-select-find-tag-at-point
**** how to enable etags or ctags of other major-mode?
     the source code of company : =company-etags.el= defined a variable : company-etags-mode ,
     it is a list of major-modes ,in which will funcional the etags for complemention. you can
     add some major-mode to it
*** comany-mode
**** how company-mode works?
     1. backend for the completion sources and front end to display the condidates
        #+BEGIN_SRC
        Its value is (company-bbdb company-nxml company-css company-eclim company-semantic company-clang company-xcode company-cmake company-capf company-files
	       (company-dabbrev-code company-gtags company-etags company-keywords)
	       company-oddmuse company-dabbrev)
        #+END_SRC
        - 从前到后,依次查看所有 *backend* 是否适合当前输入的文字
        - 可以从 buffer 状态栏查看当前使用的 *backend* (会根据文本自动切换 backend)
        - 也可以手动通过 M-x <input backend-name> 来手动激活该 backend 的自动补全
     2. *C-h v company-bakends*
     3. try company-file and company-ispell, M-x
     4. *C-h C-f* to view the backend implementation
     | company-frontends | 是指前端補全框架                                                                                               |
     | company-backends  | 有很多.其中最后一个,就是前面都匹配不到了,最后一个是 compnay-Deabbre ,他会匹配你当前打开的所有 buffer 中的词项. |
     |                   | company-File 这是另一个 backend, 是负责输入文件目录.'/' 触发.                                                  |
**** why my company sucks
***** 为什么我的 company 会失效?
      1. 失效如何定位?
	  首先看补全 package 是否需要 server 端,还是只有本地 backends.
	  我的 ubuntu 就是因为没有安装 python-pip,所以一直显示 "can't install anaconda-server"
	  安装之后,又提示 jedi 有什么问题.
      2. 然后确定自己是否使用了正确的 backends

***** 如何指定某个 backend
      我们可以自己写个函数来给某些 mode 添加 backend
      比如默认 python 中可能是没有 company-anaconda backend 的
      我们可以这样
      #+BEGIN_SRC emacs-lisp
      (add-hook 'python-mode-hook
        (lambda()
          (set (make-local-variable 'company-bakcends)  '(company-anaconda))))
      #+END_SRC
***** 两种补全方式
      1. [本地]就是在本地存有很多 backends.然后根据本地 backends 补全.
      2. [远程]就是 company-(anaconda/jedi/ycmd/tern) 的补全方式,需要安装服务器端.
*** cask
    [cask] 目前学习了两种安装方式,一个是 cask 一个是非 cask 的. 非 cask 是首先检查
    initpackage 列表中的 pkg 是否都安装了?如果没有会安装他们,之后才开始进行一些列的
    init.el 配置. cask 的方式,是要通过设定你的 export path 来设置 emacs 默认启动版本
    和 cask 的安装路径,来通过 cask install 来安装. 这之后才会执行一些 init.el 配置.
    这里都是先装包,再配置. 这样做的目的只有一个: 再一个新的环境中,下载我们的配置,直
    接使用. 或称: 配置,正确迁移. [progn] 是将多条语句捆绑成一条. 经常用在只允许
    一条语句的地方.
    [pp] 是 pretty print .
    [macroexpand] 用来展开一个宏,注意在后面加 quote--- '
**** 如何通过 cask 回退 older-version pkg?
     1. melpa 是通过 pkg 源码的 github,抓取最新 release.github 上每个 release 都有自己的 commit 号和 MD5 码.
     2. 可以通过 ~/.emacs.d/cask 文件来管理 *下载源* *每个包的下载 commit 号*
	 *格式: (depends-on "pkg-name" :git "pkgpage-in-github" :reg "commit-code")*
     - pkgpage 是 melpa 中每个 pkg 的 github 页;
     - commit-code 可以在该 github 页上通过 release 找到稳定版, 通过 commit 找到提交版.
       eg: (depends-on "monokai-theme" :git "https://github.com/oneKelvinSmith/monokai-emacs" :ref "61c0ff7")
       3. (不要通过 emacs package 删除) *通过 terminal 删除要回退的包*
       4. 通过 terminal cask install 安装 cask 文件中指定的版本
	 这样是可以安装回任意版本的 pkg.但是重启 emacs 之后, *不要* 去 package-list 中更新.因为还是会更新最新的.

*** usa-package
**** use-package 是更安全的 require
     上面是 use-package 通过 macroexpand 展开的内容. 注意提示符 message Cannot load %s.这个经常在 emacs 编译 init.el 时出现.
**** use-package a-pkg 分成多个部分
     - :init 是表示在 require a-pkg 之前定义
     - :config 是表示在 require a-pkg 之后定义
       [tips] 我们尽量少的使用 require 整个 pkg,而是应当通过 autoload 来事先加载一部分功能,从而使用需要的命令
     - :commands 是 usepackage 声明 autoload 的方法.
     - :bind 用来绑定快捷键,甚至可以制定 mode-map
     - :ensure 保证在 use-packge 执行之前,从源中下载最新版
     - :pin 如果想下载另一个源,可以在这里指定

*** anaconda-mode
    通過 pip install anaconda-mode 會直接安裝三個依賴包
    - anaconda 是一个用于数据分析的 py 包的库,维护了几百个可用的 py 包.
    - anaconda-mode 是专门为 emacs 的 python-mode 编写的自动补全 pkg,专门用来从一个本地服务器匹配补全.
      - anaconda-mode:其工作需要本地端有 factory-service 的支持,用于获取自动补全的内容(可以通过 pip 安装)
      - Jedi:是一个自动补全和静态分析 python 库的工具,anaconda-mode 依赖了这个包(可以通过 pip 安装)
    - company-mode 提供了更好的 ui 和更多的补全设置,eg 很多类型的 backends. 可以配合 anaconda-mode 提供的 backends 使用
**** 安装过程出现的问题
     1. Server error: ValueError('need more than 0 values to unpack',)
        有人提出这个问题,但是 anaconda-mode 作者说,这是 jedi 的 bug [[https://github.com/proofit404/anaconda-mode/issues/224][jedi 的 bug?]]
*** multiple-cursor-mode and cua-mode ?
    it is so annoying to make this list of checkboxes, I refer =cua-mode= , =multiple-cursor-mode= , but both are not execute very well in
    evil edit-mode ,so i frequently swich emacs-mode and evil-mode by =C-z= .
    1. I copy all the text from onenote from the chrome;
    2. I get how to toggle the check-box between SOLVED and UNSOLVED, by =C-z= ;
    3. I add '[]' to the head of all lines by cua-mode in evil-mode, FAILED!
    4. I googled a mode which pre-installed in zilong'configurations--- =multiple-cursor-mode= ;
    5. it also sucks in evil-mode.
    6. I find the configuration and hotkey re-defined by zilong ,in =/.spacemacs.d/layers/zilongshanren-misc/packages.el=
       1. switch to emacs-mode
       2. =C-spc= to select several chars , then =C-s-f= to mark all the identical highlight
       3. =C-spc= again to cancel the highlight state, then you get MULTIPLE CURSOR
       4. now, its your fasion time!
** configuration
*** 如何安装不在 melpa 的包(自己写的包)
    1. 查看该包 github 网站,获得其.el 文件中的 provide 值-->也就是具体包名
    2. 自己 layer 的 packages 函数中包含该名,并加参数
       #+BEGIN_SRC emacs-lisp
       (<pkgName> :location (recipe :fetch github :repo "<URLofpkgInGithub>"))
       #+END_SRC
    3. 配置该包的 init 函数
*** layers.el---如何大量配置包参数
    通过自定义的 layer->packages.el->post-init-pkgname()去进行简单的 pkg 参数
    调教是没问题的,但是如果我对大部分参数都不满意,参数又多达几百个,这种方法不适用.
    1. 自己 layer 下,定义 layer.el,用于移除掉一些 layer.
    2. 比如 Chinese layer 下有个 youdao 字典的包,我不想要.
       #+BEGIN_SRC emacs-lisp
       (configuration-layer/remove-layer 'youdao-dictionary)
       #+END_SRC
*** set all customize settings in one file
    最好通过下面的语句,这样会在 init.el 同层目录生成一个 custom.el 文件,用来存放这些个性化配置
    (setq custom-file (expand-file-name "custom.el" dotspacemacs-directory))
    (load custom-file 'no-error 'no-message)
*** where other settings locate
    spc f e d 下面 dotspacemacs/user-congfig() 函数里
*** install package not included in spacemacs
    spc f e d 下面 dotspacemacs-additional-packages '() 列表中
*** find README of any layer in spacemacs
    (通过 SPC h SPC 进入)
    每一个 layer 的配置文件的同层目录中(spc f j) 都存放了一个 readme 文件,详细介绍了这个 layer 中所有包的说明及安装方式/hotkeys

    每一个 layer 都有很多变量, 这些变量都在 readme 里面有介绍.
    每一个 layer 的文件夹内,都存有 config.el, 其中的配置可以在(layer 层配置的 variables 配置),
    当加载这个 layer 的时候,会配置 config.el

    直接在 init.el 文件的 configuration-layer 中的 layer 对应位置:
    #+BEGIN_SRC
   (better-defaults :variable better-defaults-move-to-end-of-code-first t)
    #+END_SRC
*** exclude some unwanted packages
    - 我想查看 SPC fed congfig 下某个 layer 都安装了哪些 package.怎么做?
      在 dotspacemacs-configuration-layers 下面的某个 layer 名字上 SPC-h-SPC
      查询到 package 后, SPC-fed ,配置文件里有个 "dotspacemacs-exclude-packages '()" 名字放到括号里即可
      然后选择一个进去,可以看到整个 layer 的配置.
    - 如果 spacemacs 启动的时候某个 pkg 报错,实在找不到原因,也可以通过上面的方法删除之.
** debug
*** hotkeys for debug
**** emacs is frozen
     use a comman in terminal to display the call stack in emacs
     #+BEGIN_SRC sh
    pkill -SIGUSR2 -i emacs
    =M-x: toggle-debug-on-quit=
     #+END_SRC

**** emacs is slow
     use the following two commands to profile the CPU
     #+BEGIN_SRC sh
     profiler-start
     profiler-report
     #+END_SRC

**** emacs start-up time is long
     use the following command
     #+BEGIN_SRC sh
     $PAHT_TO_EMACS/emacs --timed-requires --profile
     #+END_SRC
     =spc b b= to find a buffer called "*load time*", can you find the threshold package
** hack tip
*** I want a feature from other editors, how could i implement it in emacs?
    emacs is a collection of packages, every package is a collection of tools.
    she also gives you the way to re-organize them to fit you well.

    - FIRST RULE, you must know what are the tools in your bag
      read all the doc of packages, get the knowledge of all the core functions.
      these functions are the tools,gears to composite your weapon.
    - SECOND RULE, you must know how to combine them in emacs
      emacs is like a traslator to transport information between different packages.
      you need to know the node and tube, the methods how to use them.

* pandoc
need install pandoc in os
~sudo apt-get install pandoc~
http://pandoc.org/
http://joostkremers.github.io/pandoc-mode/
* Blog Ideas
* 有点意思

徐州经济 gdp

|         |  xuzhou | changzhou | nanjing | suzhou |
|---------+---------+-----------+---------+--------|
| 2017t   |    5809 |           |         |        |
| 2017tq1 | 1286.15 |           |         |        |
| 2017tq2 |         |           |         |        |
| 2017tq3 |         |           |         |        |
| 2017tq4 |         |           |         |        |
| 2017p   |         |           |         |        |
| p       |         |           |         |        |
|---------+---------+-----------+---------+--------|
| 2018t   |    6600 |           |         |        |
| 2018tq1 | 1489.31 |           |         |        |
| 2018tq2 | 1828.78 |           |         |        |
| 2018tq3 | 1664.58 |           |         |        |
| 2018tq4 | 1617.33 |           |         |        |
| 2018p   |         |           |         |        |
| p       |         |           |         |        |
|---------+---------+-----------+---------+--------|
| 2019t   |         |           |         |        |
| 2019tq1 |    1575 | 1692      | 3112    | 4152   |
| 2019tq2 |         |           |         |        |
| 2019tq3 |         |           |         |        |
| 2019tq4 |         |           |         |        |
| 2017p   |         |           |         |        |
| p       |    880w | 470w      | 833w    | 1068w  |
#+TBLFM: @13$2='(- @9$2 @10$2 @11$2 @12$2);N

